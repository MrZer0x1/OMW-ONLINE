diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2d264b5f028033b71e2d60852176406477007c6a..5c64b831bc0bd539f409b0d5bed1665bfe8373e0 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -128,6 +128,7 @@
     Feature #2858: Add a tab to the launcher for handling datafolders
     Feature #3245: Grid and angle snapping for the OpenMW-CS
     Feature #3616: Allow Zoom levels on the World Map
+    Feature #4067: Post Processing
     Feature #4297: Implement APPLIED_ONCE flag for magic effects
     Feature #4414: Handle duration of EXTRA SPELL magic effect
     Feature #4595: Unique object identifier
diff --git a/apps/launcher/advancedpage.cpp b/apps/launcher/advancedpage.cpp
index fc1d84a61fe21e65b0a06b229e9bb36ab11eb38f..6f4ca60edf5ad3a486d8b9f1b871a0af45a82afd 100644
--- a/apps/launcher/advancedpage.cpp
+++ b/apps/launcher/advancedpage.cpp
@@ -145,6 +145,12 @@ bool Launcher::AdvancedPage::loadSettings()
         objectPagingMinSizeComboBox->setValue(Settings::Manager::getDouble("object paging min size", "Terrain"));
 
         loadSettingBool(nightDaySwitchesCheckBox, "day night switches", "Game");
+
+        connect(postprocessEnabledCheckBox, SIGNAL(toggled(bool)), this, SLOT(slotPostProcessToggled(bool)));
+        loadSettingBool(postprocessEnabledCheckBox, "enabled", "Post Processing");
+        loadSettingBool(postprocessLiveReloadCheckBox, "live reload", "Post Processing");
+        loadSettingBool(postprocessTransparentPostpassCheckBox, "transparent postpass", "Post Processing");
+        postprocessHDRTimeComboBox->setValue(Settings::Manager::getDouble("hdr exposure time", "Post Processing"));
     }
 
     // Audio
@@ -302,6 +308,11 @@ void Launcher::AdvancedPage::saveSettings()
             Settings::Manager::setDouble("object paging min size", "Terrain", objectPagingMinSize);
 
         saveSettingBool(nightDaySwitchesCheckBox, "day night switches", "Game");
+
+        saveSettingBool(postprocessEnabledCheckBox, "enabled", "Post Processing");
+        saveSettingBool(postprocessLiveReloadCheckBox, "live reload", "Post Processing");
+        saveSettingBool(postprocessTransparentPostpassCheckBox, "transparent postpass", "Post Processing");
+        Settings::Manager::setDouble("hdr exposure time", "Post Processing", postprocessHDRTimeComboBox->value());
     }
     
     // Audio
@@ -464,3 +475,11 @@ void Launcher::AdvancedPage::slotViewOverShoulderToggled(bool checked)
 {
     viewOverShoulderVerticalLayout->setEnabled(viewOverShoulderCheckBox->checkState());
 }
+
+void Launcher::AdvancedPage::slotPostProcessToggled(bool checked)
+{
+    postprocessLiveReloadCheckBox->setEnabled(checked);
+    postprocessTransparentPostpassCheckBox->setEnabled(checked);
+    postprocessHDRTimeComboBox->setEnabled(checked);
+    postprocessHDRTimeLabel->setEnabled(checked);
+}
diff --git a/apps/launcher/advancedpage.hpp b/apps/launcher/advancedpage.hpp
index 1d16fae706c4da1d3c33be29575b6ed1c3226347..6a3f8319d2ea51b4701823e14313c1f22f40effc 100644
--- a/apps/launcher/advancedpage.hpp
+++ b/apps/launcher/advancedpage.hpp
@@ -30,6 +30,7 @@ namespace Launcher
         void on_runScriptAfterStartupBrowseButton_clicked();
         void slotAnimSourcesToggled(bool checked);
         void slotViewOverShoulderToggled(bool checked);
+        void slotPostProcessToggled(bool checked);
 
     private:
         Config::GameSettings &mGameSettings;
diff --git a/apps/opencs/model/world/data.cpp b/apps/opencs/model/world/data.cpp
index 12274b912fdb8df1a9eb788dfb1246d667ef8dee..b10efaa3a4adda75b248d2de947aae89944276c2 100644
--- a/apps/opencs/model/world/data.cpp
+++ b/apps/opencs/model/world/data.cpp
@@ -84,6 +84,7 @@ CSMWorld::Data::Data (ToUTF8::FromType encoding, bool fsStrict, const Files::Pat
     defines["radialFog"] = "0";
     defines["lightingModel"] = "0";
     defines["reverseZ"] = "0";
+    defines["refraction_enabled"] = "0";
     for (const auto& define : shadowDefines)
         defines[define.first] = define.second;
     mResourceSystem->getSceneManager()->getShaderManager().setGlobalDefines(defines);
diff --git a/apps/openmw/CMakeLists.txt b/apps/openmw/CMakeLists.txt
index 7bbf179d950618381dc1c2fe5fbe54ac88311031..175682416471bfdb4f4ee05c3f992707efd45aa3 100644
--- a/apps/openmw/CMakeLists.txt
+++ b/apps/openmw/CMakeLists.txt
@@ -22,7 +22,8 @@ add_openmw_dir (mwrender
     actors objects renderingmanager animation rotatecontroller sky skyutil npcanimation vismask
     creatureanimation effectmanager util renderinginterface pathgrid rendermode weaponanimation screenshotmanager
     bulletdebugdraw globalmap characterpreview camera localmap water terrainstorage ripplesimulation
-    renderbin actoranimation landmanager navmesh actorspaths recastmesh fogmanager objectpaging groundcover postprocessor
+    renderbin actoranimation landmanager navmesh actorspaths recastmesh fogmanager objectpaging groundcover
+    postprocessor pingpongcull hdr pingpongcanvas transparentpass
     )
 
 add_openmw_dir (mwinput
@@ -43,6 +44,7 @@ add_openmw_dir (mwgui
     tradeitemmodel companionitemmodel pickpocketitemmodel controllers savegamedialog
     recharge mode videowidget backgroundimage itemwidget screenfader debugwindow spellmodel spellview
     draganddrop timeadvancer jailscreen itemchargeview keyboardnavigation textcolours statswatcher
+    postprocessorhud
     )
 
 add_openmw_dir (mwdialogue
@@ -59,7 +61,7 @@ add_openmw_dir (mwscript
 add_openmw_dir (mwlua
     luamanagerimp object worldview userdataserializer eventqueue
     luabindings localscripts playerscripts objectbindings cellbindings asyncbindings settingsbindings
-    camerabindings uibindings inputbindings nearbybindings stats
+    camerabindings uibindings inputbindings nearbybindings postprocessingbindings stats
     types/types types/door types/actor types/container types/weapon types/npc types/creature
     )
 
diff --git a/apps/openmw/engine.cpp b/apps/openmw/engine.cpp
index 982ae92f11ca875e69780378d3af3ed6b446b694..af3db12b5f183ef5009840356135d58e792bf480 100644
--- a/apps/openmw/engine.cpp
+++ b/apps/openmw/engine.cpp
@@ -46,6 +46,8 @@
 #include <components/sceneutil/color.hpp>
 #include <components/sceneutil/util.hpp>
 
+#include <components/settings/shadermanager.hpp>
+
 #include "mwinput/inputmanagerimp.hpp"
 
 #include "mwgui/windowmanagerimp.hpp"
@@ -987,6 +989,8 @@ void OMW::Engine::go()
     Settings::Manager settings;
     std::string settingspath = settings.load(mCfgMgr);
 
+    Settings::ShaderManager::get().load((mCfgMgr.getUserConfigPath() / "shaders.yaml").string());
+
     MWClass::registerClasses();
 
     // Create encoder
@@ -1110,6 +1114,7 @@ void OMW::Engine::go()
 
     // Save user settings
     settings.saveUser(settingspath);
+    Settings::ShaderManager::get().save();
     mLuaManager->savePermanentStorage(mCfgMgr.getUserConfigPath().string());
 
     Log(Debug::Info) << "Quitting peacefully.";
diff --git a/apps/openmw/mwbase/windowmanager.hpp b/apps/openmw/mwbase/windowmanager.hpp
index b0076b02f2c497f322ac6861d2570345c8186594..c1c99436cb013cb1445418a6f5de11577c723f1f 100644
--- a/apps/openmw/mwbase/windowmanager.hpp
+++ b/apps/openmw/mwbase/windowmanager.hpp
@@ -70,6 +70,7 @@ namespace MWGui
     class WindowModal;
     class JailScreen;
     class MessageBox;
+    class PostProcessorHud;
 
     enum ShowInDialogueMode {
         ShowInDialogueMode_IfPossible,
@@ -147,6 +148,7 @@ namespace MWBase
             virtual MWGui::ConfirmationDialog* getConfirmationDialog() = 0;
             virtual MWGui::TradeWindow* getTradeWindow() = 0;
             virtual const std::vector<MWGui::MessageBox*> getActiveMessageBoxes() = 0;
+            virtual MWGui::PostProcessorHud* getPostProcessorHud() = 0;
 
             /// Make the player use an item, while updating GUI state accordingly
             virtual void useItem(const MWWorld::Ptr& item, bool force=false) = 0;
@@ -326,6 +328,7 @@ namespace MWBase
 
             virtual void toggleConsole() = 0;
             virtual void toggleDebugWindow() = 0;
+            virtual void togglePostProcessorHud() = 0;
 
             /// Cycle to next or previous spell
             virtual void cycleSpell(bool next) = 0;
diff --git a/apps/openmw/mwbase/world.hpp b/apps/openmw/mwbase/world.hpp
index 336af37a89a2e648c0fc6aea6b97eebe8ef47564..15177b43018198d985544579d97ddf2c687f4e75 100644
--- a/apps/openmw/mwbase/world.hpp
+++ b/apps/openmw/mwbase/world.hpp
@@ -67,6 +67,7 @@ namespace MWRender
     class Animation;
     class Camera;
     class RenderingManager;
+    class PostProcessor;
 }
 
 namespace MWMechanics
@@ -238,6 +239,10 @@ namespace MWBase
 
             virtual int getCurrentWeather() const = 0;
 
+            virtual int getNextWeather() const = 0;
+
+            virtual float getWeatherTransition() const = 0;
+
             virtual unsigned int getNightDayMode() const = 0;
 
             virtual int getMasserPhase() const = 0;
@@ -664,6 +669,8 @@ namespace MWBase
             virtual Misc::Rng::Generator& getPrng() = 0;
 
             virtual MWRender::RenderingManager* getRenderingManager() = 0;
+
+            virtual MWRender::PostProcessor* getPostProcessor() = 0;
     };
 }
 
diff --git a/apps/openmw/mwgui/postprocessorhud.cpp b/apps/openmw/mwgui/postprocessorhud.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..cfdbfda7e8a6aff915bfac7674e571545981d372
--- /dev/null
+++ b/apps/openmw/mwgui/postprocessorhud.cpp
@@ -0,0 +1,454 @@
+#include "postprocessorhud.hpp"
+
+#include <MyGUI_Window.h>
+#include <MyGUI_Button.h>
+#include <MyGUI_TabItem.h>
+#include <MyGUI_TabControl.h>
+#include <MyGUI_RenderManager.h>
+#include <MyGUI_FactoryManager.h>
+
+#include <components/fx/widgets.hpp>
+#include <components/fx/technique.hpp>
+
+#include <components/widgets/box.hpp>
+
+#include "../mwrender/postprocessor.hpp"
+
+#include "../mwbase/world.hpp"
+#include "../mwbase/environment.hpp"
+#include "../mwbase/windowmanager.hpp"
+
+namespace
+{
+    void saveChain()
+    {
+        auto* processor = MWBase::Environment::get().getWorld()->getPostProcessor();
+
+        std::ostringstream chain;
+
+        for (size_t i = 1; i < processor->getTechniques().size(); ++i)
+        {
+            auto technique = processor->getTechniques()[i];
+
+            if (!technique)
+                continue;
+
+            chain << technique->getName();
+
+            if (i < processor-> getTechniques().size() - 1)
+                chain << ",";
+        }
+
+        Settings::Manager::setString("chain", "Post Processing", chain.str());
+    }
+}
+
+namespace MWGui
+{
+    void PostProcessorHud::ListWrapper::onKeyButtonPressed(MyGUI::KeyCode key, MyGUI::Char ch)
+    {
+        if (MyGUI::InputManager::getInstance().isShiftPressed() && (key == MyGUI::KeyCode::ArrowUp || key == MyGUI::KeyCode::ArrowDown))
+            return;
+
+        MyGUI::ListBox::onKeyButtonPressed(key, ch);
+    }
+
+    PostProcessorHud::PostProcessorHud()
+        : WindowBase("openmw_postprocessor_hud.layout")
+    {
+        getWidget(mTabConfiguration, "TabConfiguration");
+        getWidget(mActiveList, "ActiveList");
+        getWidget(mInactiveList, "InactiveList");
+        getWidget(mModeToggle, "ModeToggle");
+        getWidget(mConfigLayout, "ConfigLayout");
+        getWidget(mFilter, "Filter");
+        getWidget(mButtonActivate, "ButtonActivate");
+        getWidget(mButtonDeactivate, "ButtonDeactivate");
+        getWidget(mButtonUp, "ButtonUp");
+        getWidget(mButtonDown, "ButtonDown");
+
+        mButtonActivate->eventMouseButtonClick += MyGUI::newDelegate(this, &PostProcessorHud::notifyActivatePressed);
+        mButtonDeactivate->eventMouseButtonClick += MyGUI::newDelegate(this, &PostProcessorHud::notifyDeactivatePressed);
+        mButtonUp->eventMouseButtonClick += MyGUI::newDelegate(this, &PostProcessorHud::notifyShaderUpPressed);
+        mButtonDown->eventMouseButtonClick += MyGUI::newDelegate(this, &PostProcessorHud::notifyShaderDownPressed);
+
+        mActiveList->eventKeyButtonPressed += MyGUI::newDelegate(this, &PostProcessorHud::notifyKeyButtonPressed);
+        mInactiveList->eventKeyButtonPressed += MyGUI::newDelegate(this, &PostProcessorHud::notifyKeyButtonPressed);
+
+        mActiveList->eventListChangePosition += MyGUI::newDelegate(this, &PostProcessorHud::notifyListChangePosition);
+        mInactiveList->eventListChangePosition += MyGUI::newDelegate(this, &PostProcessorHud::notifyListChangePosition);
+
+        mModeToggle->eventMouseButtonClick += MyGUI::newDelegate(this, &PostProcessorHud::notifyModeToggle);
+
+        mFilter->eventEditTextChange += MyGUI::newDelegate(this, &PostProcessorHud::notifyFilterChanged);
+
+        mMainWidget->castType<MyGUI::Window>()->eventWindowChangeCoord += MyGUI::newDelegate(this, &PostProcessorHud::notifyWindowResize);
+
+        mShaderInfo = mConfigLayout->createWidget<Gui::AutoSizedEditBox>("HeaderText", {}, MyGUI::Align::Default);
+        mShaderInfo->setUserString("VStretch", "true");
+        mShaderInfo->setUserString("HStretch", "true");
+        mShaderInfo->setTextAlign(MyGUI::Align::Left | MyGUI::Align::Top);
+        mShaderInfo->setEditReadOnly(true);
+        mShaderInfo->setEditWordWrap(true);
+        mShaderInfo->setEditMultiLine(true);
+
+        mConfigLayout->setVisibleVScroll(true);
+
+        mConfigArea = mConfigLayout->createWidget<MyGUI::Widget>("", {}, MyGUI::Align::Default);
+    }
+
+    void PostProcessorHud::notifyFilterChanged(MyGUI::EditBox* sender)
+    {
+        updateTechniques();
+    }
+
+    void PostProcessorHud::notifyWindowResize(MyGUI::Window* sender)
+    {
+        layout();
+    }
+
+    void PostProcessorHud::notifyResetButtonClicked(MyGUI::Widget* sender)
+    {
+        for (size_t i = 1; i < mConfigArea->getChildCount(); ++i)
+        {
+            if (auto* child = dynamic_cast<fx::Widgets::UniformBase*>(mConfigArea->getChildAt(i)))
+                child->toDefault();
+        }
+    }
+
+    void PostProcessorHud::notifyListChangePosition(MyGUI::ListBox* sender, size_t index)
+    {
+        if (sender == mActiveList)
+            mInactiveList->clearIndexSelected();
+        else if (sender == mInactiveList)
+            mActiveList->clearIndexSelected();
+
+        if (index >= sender->getItemCount())
+            return;
+
+        updateConfigView(sender->getItemNameAt(index));
+    }
+
+    void PostProcessorHud::toggleTechnique(bool enabled)
+    {
+        auto* list = enabled ? mInactiveList : mActiveList;
+
+        size_t selected = list->getIndexSelected();
+
+        if (selected != MyGUI::ITEM_NONE)
+        {
+            auto* processor = MWBase::Environment::get().getWorld()->getPostProcessor();
+            mOverrideHint = list->getItemNameAt(selected);
+            if (enabled)
+                processor->enableTechnique(*list->getItemDataAt<std::shared_ptr<fx::Technique>>(selected));
+            else
+                processor->disableTechnique(*list->getItemDataAt<std::shared_ptr<fx::Technique>>(selected));
+            saveChain();
+        }
+    }
+
+    void PostProcessorHud::notifyActivatePressed(MyGUI::Widget* sender)
+    {
+        toggleTechnique(true);
+    }
+
+    void PostProcessorHud::notifyDeactivatePressed(MyGUI::Widget* sender)
+    {
+        toggleTechnique(false);
+    }
+
+    void PostProcessorHud::moveShader(Direction direction)
+    {
+        auto* processor = MWBase::Environment::get().getWorld()->getPostProcessor();
+
+        size_t selected = mActiveList->getIndexSelected();
+
+        if (selected == MyGUI::ITEM_NONE)
+            return;
+
+        int index = direction == Direction::Up ? static_cast<int>(selected) - 1 : selected + 1;
+        index = std::clamp<int>(index, 0, mActiveList->getItemCount() - 1);
+
+        if (static_cast<size_t>(index) != selected)
+        {
+            if (processor->enableTechnique(*mActiveList->getItemDataAt<std::shared_ptr<fx::Technique>>(selected), index))
+                saveChain();
+        }
+    }
+
+    void PostProcessorHud::notifyShaderUpPressed(MyGUI::Widget* sender)
+    {
+        moveShader(Direction::Up);
+    }
+
+    void PostProcessorHud::notifyShaderDownPressed(MyGUI::Widget* sender)
+    {
+        moveShader(Direction::Down);
+    }
+
+    void PostProcessorHud::notifyKeyButtonPressed(MyGUI::Widget* sender, MyGUI::KeyCode key, MyGUI::Char ch)
+    {
+        MyGUI::ListBox* list = static_cast<MyGUI::ListBox*>(sender);
+
+        if (list->getIndexSelected() == MyGUI::ITEM_NONE)
+            return;
+
+        if (key == MyGUI::KeyCode::ArrowLeft && list == mActiveList)
+        {
+            if (MyGUI::InputManager::getInstance().isShiftPressed())
+            {
+                toggleTechnique(false);
+            }
+            else
+            {
+                MWBase::Environment::get().getWindowManager()->setKeyFocusWidget(mInactiveList);
+                mActiveList->clearIndexSelected();
+                select(mInactiveList, 0);
+            }
+        }
+        else if (key == MyGUI::KeyCode::ArrowRight && list == mInactiveList)
+        {
+            if (MyGUI::InputManager::getInstance().isShiftPressed())
+            {
+                toggleTechnique(true);
+            }
+            else
+            {
+                MWBase::Environment::get().getWindowManager()->setKeyFocusWidget(mActiveList);
+                mInactiveList->clearIndexSelected();
+                select(mActiveList, 0);
+            }
+        }
+        else if (list == mActiveList && MyGUI::InputManager::getInstance().isShiftPressed() && (key == MyGUI::KeyCode::ArrowUp || key == MyGUI::KeyCode::ArrowDown))
+        {
+            moveShader(key == MyGUI::KeyCode::ArrowUp ? Direction::Up : Direction::Down);
+        }
+    }
+
+    void PostProcessorHud::notifyModeToggle(MyGUI::Widget* sender)
+    {
+        Settings::ShaderManager::Mode prev = Settings::ShaderManager::get().getMode();
+        toggleMode(prev == Settings::ShaderManager::Mode::Debug ? Settings::ShaderManager::Mode::Normal : Settings::ShaderManager::Mode::Debug);
+    }
+
+    void PostProcessorHud::onOpen()
+    {
+        toggleMode(Settings::ShaderManager::Mode::Debug);
+        updateTechniques();
+    }
+
+    void PostProcessorHud::onClose()
+    {
+        toggleMode(Settings::ShaderManager::Mode::Normal);
+    }
+
+    void PostProcessorHud::layout()
+    {
+        constexpr int padding = 12;
+        constexpr int padding2 = padding * 2;
+        mShaderInfo->setCoord(padding, padding, mConfigLayout->getSize().width - padding2 - padding, mShaderInfo->getTextSize().height);
+
+        int totalHeight = mShaderInfo->getTop() + mShaderInfo->getTextSize().height + padding;
+
+        mConfigArea->setCoord({padding, totalHeight, mShaderInfo->getSize().width, mConfigLayout->getHeight()});
+
+        int childHeights = 0;
+		MyGUI::EnumeratorWidgetPtr enumerator = mConfigArea->getEnumerator();
+		while (enumerator.next())
+		{
+			enumerator.current()->setCoord(padding, childHeights + padding, mShaderInfo->getSize().width - padding2, enumerator.current()->getHeight());
+            childHeights += enumerator.current()->getHeight() + padding;
+		}
+        totalHeight += childHeights;
+
+        mConfigArea->setSize(mConfigArea->getWidth(), childHeights);
+
+        mConfigLayout->setCanvasSize(mConfigLayout->getWidth() - padding2, totalHeight);
+        mConfigLayout->setSize(mConfigLayout->getWidth(), mConfigLayout->getParentSize().height - padding2);
+    }
+
+    void PostProcessorHud::select(ListWrapper* list, size_t index)
+    {
+        list->setIndexSelected(index);
+        notifyListChangePosition(list, index);
+    }
+
+    void PostProcessorHud::toggleMode(Settings::ShaderManager::Mode mode)
+    {
+        Settings::ShaderManager::get().setMode(mode);
+
+        mModeToggle->setCaptionWithReplacing(mode == Settings::ShaderManager::Mode::Debug ? "#{sOn}" :"#{sOff}");
+
+        MWBase::Environment::get().getWorld()->getPostProcessor()->toggleMode();
+
+        if (!isVisible())
+            return;
+
+        if (mInactiveList->getIndexSelected() != MyGUI::ITEM_NONE)
+            updateConfigView(mInactiveList->getItemNameAt(mInactiveList->getIndexSelected()));
+        else if (mActiveList->getIndexSelected() != MyGUI::ITEM_NONE)
+            updateConfigView(mActiveList->getItemNameAt(mActiveList->getIndexSelected()));
+    }
+
+    void PostProcessorHud::updateConfigView(const std::string& name)
+    {
+        auto* processor = MWBase::Environment::get().getWorld()->getPostProcessor();
+
+        auto technique = processor->loadTechnique(name);
+
+        if (!technique)
+            return;
+
+        while (mConfigArea->getChildCount() > 0)
+            MyGUI::Gui::getInstance().destroyWidget(mConfigArea->getChildAt(0));
+
+        mShaderInfo->setCaption("");
+
+        if (!technique)
+            return;
+
+        std::ostringstream ss;
+
+        const std::string NA = "NA";
+        const std::string endl = "\n";
+
+        std::string author = technique->getAuthor().empty() ? NA : std::string(technique->getAuthor());
+        std::string version = technique->getVersion().empty() ? NA : std::string(technique->getVersion());
+        std::string description = technique->getDescription().empty() ? NA : std::string(technique->getDescription());
+
+        auto serializeBool = [](bool value) {
+            return value ? "#{sYes}" : "#{sNo}";
+        };
+
+        const auto flags = technique->getFlags();
+
+        const auto flag_interior = serializeBool (!(flags & fx::Technique::Flag_Disable_Interiors));
+        const auto flag_exterior = serializeBool (!(flags & fx::Technique::Flag_Disable_Exteriors));
+        const auto flag_underwater = serializeBool(!(flags & fx::Technique::Flag_Disable_Underwater));
+        const auto flag_abovewater = serializeBool(!(flags & fx::Technique::Flag_Disable_Abovewater));
+
+        switch (technique->getStatus())
+        {
+            case fx::Technique::Status::Success:
+            case fx::Technique::Status::Uncompiled:
+                ss  << "#{fontcolourhtml=header}Author:      #{fontcolourhtml=normal} " << author << endl << endl
+                    << "#{fontcolourhtml=header}Version:     #{fontcolourhtml=normal} " << version << endl << endl
+                    << "#{fontcolourhtml=header}Description: #{fontcolourhtml=normal} " << description << endl << endl
+                    << "#{fontcolourhtml=header}Interiors: #{fontcolourhtml=normal} " << flag_interior
+                    << "#{fontcolourhtml=header}   Exteriors: #{fontcolourhtml=normal} " << flag_exterior
+                    << "#{fontcolourhtml=header}   Underwater: #{fontcolourhtml=normal} " << flag_underwater
+                    << "#{fontcolourhtml=header}   Abovewater: #{fontcolourhtml=normal} " << flag_abovewater;
+                break;
+            case fx::Technique::Status::File_Not_exists:
+                ss  << "#{fontcolourhtml=negative}Shader Error: #{fontcolourhtml=header} <" << std::string(technique->getFileName()) << ">#{fontcolourhtml=normal} not found." << endl << endl
+                    << "Ensure the shader file is in a 'Shaders/' sub directory in a data files directory";
+                break;
+            case fx::Technique::Status::Parse_Error:
+                ss  << "#{fontcolourhtml=negative}Shader Compile Error: #{fontcolourhtml=normal} <" << std::string(technique->getName()) << "> failed to compile." << endl << endl
+                    << technique->getLastError();
+                break;
+        }
+
+        mShaderInfo->setCaptionWithReplacing(ss.str());
+
+        if (Settings::ShaderManager::get().getMode() == Settings::ShaderManager::Mode::Debug)
+        {
+            if (technique->getUniformMap().size() > 0)
+            {
+                MyGUI::Button* resetButton = mConfigArea->createWidget<MyGUI::Button>("MW_Button", {0,0,0,24}, MyGUI::Align::Default);
+                resetButton->setCaption("Reset all to default");
+                resetButton->setTextAlign(MyGUI::Align::Center);
+                resetButton->eventMouseButtonClick += MyGUI::newDelegate(this, &PostProcessorHud::notifyResetButtonClicked);
+            }
+
+            for (const auto& uniform : technique->getUniformMap())
+            {
+                if (!uniform->mStatic || uniform->mSamplerType)
+                    continue;
+
+                if (!uniform->mHeader.empty())
+                    mConfigArea->createWidget<Gui::AutoSizedTextBox>("MW_UniformGroup", {0,0,0,34}, MyGUI::Align::Default)->setCaption(uniform->mHeader);
+
+                fx::Widgets::UniformBase* uwidget = mConfigArea->createWidget<fx::Widgets::UniformBase>("MW_UniformEdit", {0,0,0,22}, MyGUI::Align::Default);
+                uwidget->init(uniform);
+            }
+        }
+
+        layout();
+    }
+
+    void PostProcessorHud::updateTechniques()
+    {
+        if (!isVisible())
+            return;
+
+        std::string hint;
+        ListWrapper* hintWidget = nullptr;
+        if (mInactiveList->getIndexSelected() != MyGUI::ITEM_NONE)
+        {
+            hint = mInactiveList->getItemNameAt(mInactiveList->getIndexSelected());
+            hintWidget = mInactiveList;
+        }
+        else if (mActiveList->getIndexSelected() != MyGUI::ITEM_NONE)
+        {
+            hint = mActiveList->getItemNameAt(mActiveList->getIndexSelected());
+            hintWidget = mActiveList;
+        }
+
+        mInactiveList->removeAllItems();
+        mActiveList->removeAllItems();
+
+        auto* processor = MWBase::Environment::get().getWorld()->getPostProcessor();
+
+        for (const auto& [name, _] : processor->getTechniqueMap())
+        {
+            auto technique = processor->loadTechnique(name);
+
+            if (!technique)
+                continue;
+
+            if (!technique->getHidden() && !processor->isTechniqueEnabled(technique) && name.find(mFilter->getCaption()) != std::string::npos)
+                mInactiveList->addItem(name, technique);
+        }
+
+        for (auto technique : processor->getTechniques())
+        {
+            if (!technique->getHidden())
+                mActiveList->addItem(technique->getName(), technique);
+        }
+
+        auto tryFocus = [this](ListWrapper* widget, const std::string& hint)
+        {
+            size_t index = widget->findItemIndexWith(hint);
+
+            if (index != MyGUI::ITEM_NONE)
+            {
+                MWBase::Environment::get().getWindowManager()->setKeyFocusWidget(widget);
+                select(widget, index);
+            }
+        };
+
+        if (!mOverrideHint.empty())
+        {
+            tryFocus(mActiveList, mOverrideHint);
+            tryFocus(mInactiveList, mOverrideHint);
+
+            mOverrideHint.clear();
+        }
+        else if (hintWidget && !hint.empty())
+            tryFocus(hintWidget, hint);
+    }
+
+    void PostProcessorHud::registerMyGUIComponents()
+    {
+        MyGUI::FactoryManager& factory = MyGUI::FactoryManager::getInstance();
+        factory.registerFactory<fx::Widgets::UniformBase>("Widget");
+        factory.registerFactory<fx::Widgets::EditNumberFloat4>("Widget");
+        factory.registerFactory<fx::Widgets::EditNumberFloat3>("Widget");
+        factory.registerFactory<fx::Widgets::EditNumberFloat2>("Widget");
+        factory.registerFactory<fx::Widgets::EditNumberFloat>("Widget");
+        factory.registerFactory<fx::Widgets::EditNumberInt>("Widget");
+        factory.registerFactory<fx::Widgets::EditBool>("Widget");
+        factory.registerFactory<ListWrapper>("Widget");
+    }
+}
diff --git a/apps/openmw/mwgui/postprocessorhud.hpp b/apps/openmw/mwgui/postprocessorhud.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..44baf79b638ef61c7d7538d78c8b90332eefc81c
--- /dev/null
+++ b/apps/openmw/mwgui/postprocessorhud.hpp
@@ -0,0 +1,107 @@
+#ifndef MYGUI_POSTPROCESSOR_HUD_H
+#define MYGUI_POSTPROCESSOR_HUD_H
+
+#include "windowbase.hpp"
+
+#include <MyGUI_Gui.h>
+#include <MyGUI_ListBox.h>
+
+#include <components/settings/shadermanager.hpp>
+
+namespace MyGUI
+{
+    class ScrollView;
+    class EditBox;
+    class TabItem;
+}
+namespace Gui
+{
+    class AutoSizedButton;
+    class AutoSizedEditBox;
+}
+
+namespace MWGui
+{
+    class PostProcessorHud : public WindowBase
+    {
+        class ListWrapper final : public MyGUI::ListBox
+        {
+            MYGUI_RTTI_DERIVED(ListWrapper)
+        protected:
+            void onKeyButtonPressed(MyGUI::KeyCode key, MyGUI::Char ch) override;
+        };
+
+    public:
+        PostProcessorHud();
+
+        void onOpen() override;
+
+        void onClose() override;
+
+        void updateTechniques();
+
+        void toggleMode(Settings::ShaderManager::Mode mode);
+
+        static void registerMyGUIComponents();
+
+    private:
+
+        void notifyWindowResize(MyGUI::Window* sender);
+
+        void notifyFilterChanged(MyGUI::EditBox* sender);
+
+        void updateConfigView(const std::string& name);
+
+        void notifyModeToggle(MyGUI::Widget* sender);
+
+        void notifyResetButtonClicked(MyGUI::Widget* sender);
+
+        void notifyListChangePosition(MyGUI::ListBox* sender, size_t index);
+
+        void notifyKeyButtonPressed(MyGUI::Widget* sender, MyGUI::KeyCode key, MyGUI::Char ch);
+
+        void notifyActivatePressed(MyGUI::Widget* sender);
+
+        void notifyDeactivatePressed(MyGUI::Widget* sender);
+
+        void notifyShaderUpPressed(MyGUI::Widget* sender);
+
+        void notifyShaderDownPressed(MyGUI::Widget* sender);
+
+        enum class Direction
+        {
+            Up,
+            Down
+        };
+
+        void moveShader(Direction direction);
+
+        void toggleTechnique(bool enabled);
+
+        void select(ListWrapper* list, size_t index);
+
+        void layout();
+
+        MyGUI::TabItem* mTabConfiguration;
+
+        ListWrapper* mActiveList;
+        ListWrapper* mInactiveList;
+
+        Gui::AutoSizedButton* mButtonActivate;
+        Gui::AutoSizedButton* mButtonDeactivate;
+        Gui::AutoSizedButton* mButtonDown;
+        Gui::AutoSizedButton* mButtonUp;
+
+        MyGUI::ScrollView* mConfigLayout;
+
+        MyGUI::Widget* mConfigArea;
+
+        MyGUI::EditBox* mFilter;
+        Gui::AutoSizedButton* mModeToggle;
+        Gui::AutoSizedEditBox* mShaderInfo;
+
+        std::string mOverrideHint;
+    };
+}
+
+#endif
diff --git a/apps/openmw/mwgui/windowmanagerimp.cpp b/apps/openmw/mwgui/windowmanagerimp.cpp
index 80fb1e546bc4ce17d273a6b1750b9d9282481855..3b79b21a7c9e5e980799bfb20a7c32471cf18f2d 100644
--- a/apps/openmw/mwgui/windowmanagerimp.cpp
+++ b/apps/openmw/mwgui/windowmanagerimp.cpp
@@ -71,6 +71,7 @@
 #include "../mwmechanics/actorutil.hpp"
 
 #include "../mwrender/localmap.hpp"
+#include "../mwrender/postprocessor.hpp"
 
 #include "console.hpp"
 #include "journalwindow.hpp"
@@ -113,6 +114,7 @@
 #include "itemwidget.hpp"
 #include "screenfader.hpp"
 #include "debugwindow.hpp"
+#include "postprocessorhud.hpp"
 #include "spellview.hpp"
 #include "draganddrop.hpp"
 #include "container.hpp"
@@ -164,6 +166,7 @@ namespace MWGui
       , mHitFader(nullptr)
       , mScreenFader(nullptr)
       , mDebugWindow(nullptr)
+      , mPostProcessorHud(nullptr)
       , mJailScreen(nullptr)
       , mContainerWindow(nullptr)
       , mTranslationDataStorage (translationDataStorage)
@@ -217,7 +220,8 @@ namespace MWGui
         MyGUI::FactoryManager::getInstance().registerFactory<BackgroundImage>("Widget");
         MyGUI::FactoryManager::getInstance().registerFactory<osgMyGUI::AdditiveLayer>("Layer");
         MyGUI::FactoryManager::getInstance().registerFactory<osgMyGUI::ScalingLayer>("Layer");
-        BookPage::registerMyGUIComponents ();
+        BookPage::registerMyGUIComponents();
+        PostProcessorHud::registerMyGUIComponents();
         ItemView::registerComponents();
         ItemChargeView::registerComponents();
         ItemWidget::registerComponents();
@@ -469,6 +473,10 @@ namespace MWGui
         mDebugWindow = new DebugWindow();
         mWindows.push_back(mDebugWindow);
 
+        mPostProcessorHud = new PostProcessorHud();
+        mWindows.push_back(mPostProcessorHud);
+        trackWindow(mPostProcessorHud, "postprocessor");
+
         mInputBlocker = MyGUI::Gui::getInstance().createWidget<MyGUI::Widget>("",0,0,w,h,MyGUI::Align::Stretch,"InputBlocker");
 
         mHud->setVisible(true);
@@ -897,6 +905,8 @@ namespace MWGui
 
         mDebugWindow->onFrame(frameDuration);
 
+        mPostProcessorHud->onFrame(frameDuration);
+
         if (mCharGen)
             mCharGen->onFrame(frameDuration);
 
@@ -1400,6 +1410,7 @@ namespace MWGui
     MWGui::CountDialog* WindowManager::getCountDialog() { return mCountDialog; }
     MWGui::ConfirmationDialog* WindowManager::getConfirmationDialog() { return mConfirmationDialog; }
     MWGui::TradeWindow* WindowManager::getTradeWindow() { return mTradeWindow; }
+    MWGui::PostProcessorHud* WindowManager::getPostProcessorHud() { return mPostProcessorHud; }
 
     void WindowManager::useItem(const MWWorld::Ptr &item, bool bypassBeastRestrictions)
     {
@@ -1488,6 +1499,7 @@ namespace MWGui
         return
             !mGuiModes.empty() ||
             isConsoleMode() ||
+            (mPostProcessorHud && mPostProcessorHud->isVisible()) ||
             (mMessageBoxManager && mMessageBoxManager->isInteractiveMessageBox());
     }
 
@@ -2054,6 +2066,24 @@ namespace MWGui
 #endif
     }
 
+    void WindowManager::togglePostProcessorHud()
+    {
+        if (!MWBase::Environment::get().getWorld()->getPostProcessor()->isEnabled())
+            return;
+
+        bool visible = mPostProcessorHud->isVisible();
+
+        if (!visible && !mGuiModes.empty())
+            mKeyboardNavigation->saveFocus(mGuiModes.back());
+
+        mPostProcessorHud->setVisible(!visible);
+
+        if (visible && !mGuiModes.empty())
+            mKeyboardNavigation->restoreFocus(mGuiModes.back());
+
+        updateVisible();
+    }
+
     void WindowManager::cycleSpell(bool next)
     {
         if (!isGuiMode())
diff --git a/apps/openmw/mwgui/windowmanagerimp.hpp b/apps/openmw/mwgui/windowmanagerimp.hpp
index 9a4de2b33f5a1cca7a984f222de36bef59358257..58400ec76b6fa67b8a719ee2beb3fe9b5fb5c67f 100644
--- a/apps/openmw/mwgui/windowmanagerimp.hpp
+++ b/apps/openmw/mwgui/windowmanagerimp.hpp
@@ -123,6 +123,7 @@ namespace MWGui
   class WindowModal;
   class ScreenFader;
   class DebugWindow;
+  class PostProcessorHud;
   class JailScreen;
   class KeyboardNavigation;
 
@@ -188,6 +189,7 @@ namespace MWGui
     MWGui::ConfirmationDialog* getConfirmationDialog() override;
     MWGui::TradeWindow* getTradeWindow() override;
     const std::vector<MWGui::MessageBox*> getActiveMessageBoxes() override;
+    MWGui::PostProcessorHud* getPostProcessorHud() override;
 
     /// Make the player use an item, while updating GUI state accordingly
     void useItem(const MWWorld::Ptr& item, bool bypassBeastRestrictions=false) override;
@@ -366,6 +368,7 @@ namespace MWGui
 
     void toggleConsole() override;
     void toggleDebugWindow() override;
+    void togglePostProcessorHud() override;
 
     /// Cycle to next or previous spell
     void cycleSpell(bool next) override;
@@ -452,6 +455,7 @@ namespace MWGui
     ScreenFader* mHitFader;
     ScreenFader* mScreenFader;
     DebugWindow* mDebugWindow;
+    PostProcessorHud* mPostProcessorHud;
     JailScreen* mJailScreen;
     ContainerWindow* mContainerWindow;
 
diff --git a/apps/openmw/mwinput/actionmanager.cpp b/apps/openmw/mwinput/actionmanager.cpp
index eae6996acd6cc19a465aa524a9bc2f006e7b7575..6b5a1007226793e53e683b91674edbce5e39496b 100644
--- a/apps/openmw/mwinput/actionmanager.cpp
+++ b/apps/openmw/mwinput/actionmanager.cpp
@@ -241,6 +241,9 @@ namespace MWInput
         case A_ToggleDebug:
             windowManager->toggleDebugWindow();
             break;
+        case A_TogglePostProcessorHUD:
+            windowManager->togglePostProcessorHud();
+            break;
         case A_QuickSave:
             quickSave();
             break;
diff --git a/apps/openmw/mwinput/actions.hpp b/apps/openmw/mwinput/actions.hpp
index a1c1607126c0de1860b9a0a9c45c55cdc3cf6946..c7bdbf28d30e35448aa4384d1fca1c59a56ba64c 100644
--- a/apps/openmw/mwinput/actions.hpp
+++ b/apps/openmw/mwinput/actions.hpp
@@ -73,6 +73,8 @@ namespace MWInput
         A_ZoomIn,
         A_ZoomOut,
 
+        A_TogglePostProcessorHUD,
+
         A_Last                      // Marker for the last item
     };
 }
diff --git a/apps/openmw/mwinput/bindingsmanager.cpp b/apps/openmw/mwinput/bindingsmanager.cpp
index 68be849dbd57954dd2bbb693da9f53a5b36e85a3..82a469890ce02c2c9a8c6e62f28021561de92e32 100644
--- a/apps/openmw/mwinput/bindingsmanager.cpp
+++ b/apps/openmw/mwinput/bindingsmanager.cpp
@@ -286,6 +286,7 @@ namespace MWInput
         defaultKeyBindings[A_AlwaysRun] = SDL_SCANCODE_CAPSLOCK;
         defaultKeyBindings[A_QuickSave] = SDL_SCANCODE_F5;
         defaultKeyBindings[A_QuickLoad] = SDL_SCANCODE_F9;
+        defaultKeyBindings[A_TogglePostProcessorHUD] = SDL_SCANCODE_F2;
 
         std::map<int, int> defaultMouseButtonBindings;
         defaultMouseButtonBindings[A_Inventory] = SDL_BUTTON_RIGHT;
@@ -502,6 +503,8 @@ namespace MWInput
                 return "#{sQuickSaveCmd}";
             case A_QuickLoad:
                 return "#{sQuickLoadCmd}";
+            case A_TogglePostProcessorHUD:
+                return "Toggle Post Processor HUD";
             default:
                 return std::string(); // not configurable
         }
@@ -563,7 +566,8 @@ namespace MWInput
             A_CycleSpellLeft, A_CycleSpellRight, A_CycleWeaponLeft, A_CycleWeaponRight, A_AutoMove,
             A_Jump, A_Inventory, A_Journal, A_Rest, A_Console, A_QuickSave, A_QuickLoad,
             A_ToggleHUD, A_Screenshot, A_QuickKeysMenu, A_QuickKey1, A_QuickKey2, A_QuickKey3,
-            A_QuickKey4, A_QuickKey5, A_QuickKey6, A_QuickKey7, A_QuickKey8, A_QuickKey9, A_QuickKey10
+            A_QuickKey4, A_QuickKey5, A_QuickKey6, A_QuickKey7, A_QuickKey8, A_QuickKey9, A_QuickKey10,
+            A_TogglePostProcessorHUD
         };
 
         return actions;
diff --git a/apps/openmw/mwlua/inputbindings.cpp b/apps/openmw/mwlua/inputbindings.cpp
index 1be6e086fa4f04b8c47f37f38df6608e27f4ccc1..fc16f514fde059aadd5ebe826654d80a4f82f52e 100644
--- a/apps/openmw/mwlua/inputbindings.cpp
+++ b/apps/openmw/mwlua/inputbindings.cpp
@@ -136,6 +136,7 @@ namespace MWLua
 
             {"ToggleHUD", MWInput::A_ToggleHUD},
             {"ToggleDebug", MWInput::A_ToggleDebug},
+            {"TogglePostProcessorHUD", MWInput::A_TogglePostProcessorHUD},
 
             {"ZoomIn", MWInput::A_ZoomIn},
             {"ZoomOut", MWInput::A_ZoomOut}
diff --git a/apps/openmw/mwlua/luabindings.hpp b/apps/openmw/mwlua/luabindings.hpp
index 41bc8b29aea8f1b92bb5bc7620a26d80458ba871..af41199ad9e474221feb8ff76496625f43ef27b7 100644
--- a/apps/openmw/mwlua/luabindings.hpp
+++ b/apps/openmw/mwlua/luabindings.hpp
@@ -21,6 +21,7 @@ namespace MWLua
 
     sol::table initCorePackage(const Context&);
     sol::table initWorldPackage(const Context&);
+    sol::table initPostprocessingPackage(const Context&);
 
     sol::table initGlobalStoragePackage(const Context&, LuaUtil::LuaStorage* globalStorage);
     sol::table initLocalStoragePackage(const Context&, LuaUtil::LuaStorage* globalStorage);
diff --git a/apps/openmw/mwlua/luamanagerimp.cpp b/apps/openmw/mwlua/luamanagerimp.cpp
index 602f32710fa739dd1e30211050a189f9e377829b..b0e22db110eda435b2d6c355dfaa9445862add89 100644
--- a/apps/openmw/mwlua/luamanagerimp.cpp
+++ b/apps/openmw/mwlua/luamanagerimp.cpp
@@ -95,6 +95,7 @@ namespace MWLua
         mPlayerSettingsPackage = initPlayerSettingsPackage(localContext);
         mLocalStoragePackage = initLocalStoragePackage(localContext, &mGlobalStorage);
         mPlayerStoragePackage = initPlayerStoragePackage(localContext, &mGlobalStorage, &mPlayerStorage);
+        mPostprocessingPackage = initPostprocessingPackage(localContext);
 
         initConfiguration();
         mInitialized = true;
@@ -407,6 +408,7 @@ namespace MWLua
             scripts->addPackage("openmw.input", mInputPackage);
             scripts->addPackage("openmw.settings", mPlayerSettingsPackage);
             scripts->addPackage("openmw.storage", mPlayerStoragePackage);
+            scripts->addPackage("openmw.postprocessing", mPostprocessingPackage);
         }
         else
         {
diff --git a/apps/openmw/mwlua/luamanagerimp.hpp b/apps/openmw/mwlua/luamanagerimp.hpp
index a75cac2da97277109537255729c80a19da6e7b6c..07008954970773bef31b0a7a19fe903c9cd189fd 100644
--- a/apps/openmw/mwlua/luamanagerimp.hpp
+++ b/apps/openmw/mwlua/luamanagerimp.hpp
@@ -140,6 +140,7 @@ namespace MWLua
         sol::table mPlayerSettingsPackage;
         sol::table mLocalStoragePackage;
         sol::table mPlayerStoragePackage;
+        sol::table mPostprocessingPackage;
 
         GlobalScripts mGlobalScripts{&mLua};
         std::set<LocalScripts*> mActiveLocalScripts;
diff --git a/apps/openmw/mwlua/postprocessingbindings.cpp b/apps/openmw/mwlua/postprocessingbindings.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..b016c7716a50219b0292a4043bc057ec685aae47
--- /dev/null
+++ b/apps/openmw/mwlua/postprocessingbindings.cpp
@@ -0,0 +1,140 @@
+#include "luabindings.hpp"
+
+#include "../mwbase/environment.hpp"
+#include "../mwrender/postprocessor.hpp"
+
+#include "luamanagerimp.hpp"
+
+namespace
+{
+    template <class T>
+    class SetUniformShaderAction final : public MWLua::LuaManager::Action
+    {
+    public:
+        SetUniformShaderAction(LuaUtil::LuaState* state, std::shared_ptr<fx::Technique> shader, const std::string& name, const T& value)
+            : MWLua::LuaManager::Action(state), mShader(std::move(shader)), mName(name), mValue(value) {}
+
+        void apply(MWLua::WorldView&) const override
+        {
+            MWBase::Environment::get().getWorld()->getPostProcessor()->setUniform(mShader, mName, mValue);
+        }
+
+        std::string toString() const override
+        {
+            return  std::string("SetUniformShaderAction shader=") + (mShader ? mShader->getName() : "nil") +
+                    std::string("uniform=") + (mShader ? mName : "nil");
+        }
+
+    private:
+        std::shared_ptr<fx::Technique> mShader;
+        std::string mName;
+        T mValue;
+    };
+}
+
+namespace MWLua
+{
+    struct Shader;
+}
+
+namespace sol
+{
+    template <>
+    struct is_automagical<MWLua::Shader> : std::false_type {};
+}
+
+namespace MWLua
+{
+    struct Shader
+    {
+        std::shared_ptr<fx::Technique> mShader;
+
+        Shader(std::shared_ptr<fx::Technique> shader) : mShader(std::move(shader)) {}
+
+        std::string toString() const
+        {
+            if (!mShader)
+                return "Shader(nil)";
+
+            return Misc::StringUtils::format("Shader(%s, %s)", mShader->getName(), mShader->getFileName());
+        }
+
+        bool mQueuedAction = false;
+    };
+
+    sol::table initPostprocessingPackage(const Context& context)
+    {
+        sol::table api(context.mLua->sol(), sol::create);
+
+        sol::usertype<Shader> shader = context.mLua->sol().new_usertype<Shader>("Shader");
+        shader[sol::meta_function::to_string] = [](const Shader& shader) { return shader.toString(); };
+
+        shader["enable"] = [context](Shader& shader, sol::optional<int> optPos)
+        {
+            std::optional<int> pos = std::nullopt;
+            if (optPos)
+                pos = optPos.value();
+
+            if (shader.mShader && shader.mShader->isValid())
+                shader.mQueuedAction = true;
+
+            context.mLuaManager->addAction(
+                [&] { MWBase::Environment::get().getWorld()->getPostProcessor()->enableTechnique(shader.mShader, pos); },
+                "Enable shader " + (shader.mShader ? shader.mShader->getName() : "nil")
+            );
+        };
+
+        shader["disable"] = [context](Shader& shader)
+        {
+            shader.mQueuedAction = false;
+
+            context.mLuaManager->addAction(
+                [&] { MWBase::Environment::get().getWorld()->getPostProcessor()->disableTechnique(shader.mShader); },
+                "Disable shader " + (shader.mShader ? shader.mShader->getName() : "nil")
+            );
+        };
+
+        shader["isEnabled"] = [](const Shader& shader)
+        {
+            return shader.mQueuedAction;
+        };
+
+        shader["setBool"] = [context](const Shader& shader, const std::string& name, bool value)
+        {
+            context.mLuaManager->addAction(std::make_unique<SetUniformShaderAction<bool>>(context.mLua, shader.mShader, name, value));
+        };
+
+        shader["setFloat"] = [context](const Shader& shader, const std::string& name, float value)
+        {
+            context.mLuaManager->addAction(std::make_unique<SetUniformShaderAction<float>>(context.mLua, shader.mShader, name, value));
+        };
+
+        shader["setInt"] = [context](const Shader& shader, const std::string& name, int value)
+        {
+            context.mLuaManager->addAction(std::make_unique<SetUniformShaderAction<int>>(context.mLua, shader.mShader, name, value));
+        };
+
+        shader["setVector2"] = [context](const Shader& shader, const std::string& name, const osg::Vec2f& value)
+        {
+            context.mLuaManager->addAction(std::make_unique<SetUniformShaderAction<osg::Vec2f>>(context.mLua, shader.mShader, name, value));
+        };
+
+        shader["setVector3"] = [context](const Shader& shader, const std::string& name, const osg::Vec3f& value)
+        {
+            context.mLuaManager->addAction(std::make_unique<SetUniformShaderAction<osg::Vec3f>>(context.mLua, shader.mShader, name, value));
+        };
+
+        shader["setVector4"] = [context](const Shader& shader, const std::string& name, const osg::Vec4f& value)
+        {
+            context.mLuaManager->addAction(std::make_unique<SetUniformShaderAction<osg::Vec4f>>(context.mLua, shader.mShader, name, value));
+        };
+
+        api["load"] = [](const std::string& name)
+        {
+            return Shader(MWBase::Environment::get().getWorld()->getPostProcessor()->loadTechnique(name, false));
+        };
+
+        return LuaUtil::makeReadOnly(api);
+    }
+
+}
diff --git a/apps/openmw/mwrender/animation.cpp b/apps/openmw/mwrender/animation.cpp
index cb4c0745863d1c2b02232d9ed25b6670330cd6dd..0ec8d8885d028f4f59cda1613081472b3a1b0e22 100644
--- a/apps/openmw/mwrender/animation.cpp
+++ b/apps/openmw/mwrender/animation.cpp
@@ -8,6 +8,7 @@
 #include <osg/Material>
 #include <osg/Switch>
 #include <osg/LightModel>
+#include <osg/ColorMaski>
 
 #include <osgParticle/ParticleSystem>
 #include <osgParticle/ParticleProcessor>
@@ -1563,7 +1564,8 @@ namespace MWRender
 
         // Morrowind has a white ambient light attached to the root VFX node of the scenegraph
         node->getOrCreateStateSet()->setAttributeAndModes(getVFXLightModelInstance(), osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
-
+        if (mResourceSystem->getSceneManager()->getSupportsNormalsRT())
+            node->getOrCreateStateSet()->setAttribute(new osg::ColorMaski(1, false, false, false, false));
         SceneUtil::FindMaxControllerLengthVisitor findMaxLengthVisitor;
         node->accept(findMaxLengthVisitor);
 
diff --git a/apps/openmw/mwrender/characterpreview.cpp b/apps/openmw/mwrender/characterpreview.cpp
index f2bbe1046086a12993d1f9ebd4a18a14185f609f..3a6d2df7ff672140c3afdbec85133e2d978ed9f7 100644
--- a/apps/openmw/mwrender/characterpreview.cpp
+++ b/apps/openmw/mwrender/characterpreview.cpp
@@ -147,7 +147,7 @@ namespace MWRender
     class CharacterPreviewRTTNode : public SceneUtil::RTTNode
     {
         static constexpr float fovYDegrees = 12.3f;
-        static constexpr float znear = 0.1f;
+        static constexpr float znear = 4.0f;
         static constexpr float zfar = 10000.f;
 
     public:
@@ -162,31 +162,23 @@ namespace MWRender
             mGroup->getOrCreateStateSet()->addUniform(new osg::Uniform("projectionMatrix", mPerspectiveMatrix));
             mViewMatrix = osg::Matrixf::identity();
             setColorBufferInternalFormat(GL_RGBA);
+            setDepthBufferInternalFormat(GL_DEPTH24_STENCIL8);
         } 
 
         void setDefaults(osg::Camera* camera) override 
         {
-
-            // hints that the camera is not relative to the master camera
+            camera->setName("CharacterPreview");
             camera->setReferenceFrame(osg::Camera::ABSOLUTE_RF);
             camera->setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT, osg::Camera::PIXEL_BUFFER_RTT);
             camera->setClearColor(osg::Vec4(0.f, 0.f, 0.f, 0.f));
-            camera->setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+            camera->setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+            camera->setProjectionMatrixAsPerspective(fovYDegrees, mAspectRatio, znear, zfar);
             camera->setViewport(0, 0, width(), height());
             camera->setRenderOrder(osg::Camera::PRE_RENDER);
-            camera->setName("CharacterPreview");
-            camera->setComputeNearFarMode(osg::Camera::COMPUTE_NEAR_FAR_USING_BOUNDING_VOLUMES);
             camera->setCullMask(~(Mask_UpdateVisitor));
+            camera->setComputeNearFarMode(osg::Camera::DO_NOT_COMPUTE_NEAR_FAR);
             SceneUtil::setCameraClearDepth(camera);
 
-            // hints that the camera is not relative to the master camera
-            camera->setReferenceFrame(osg::Camera::ABSOLUTE_RF);
-            camera->setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT, osg::Camera::PIXEL_BUFFER_RTT);
-            camera->setClearColor(osg::Vec4(0.f, 0.f, 0.f, 0.f));
-            camera->setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-            camera->setProjectionMatrixAsPerspective(fovYDegrees, mAspectRatio, znear, zfar);
-            camera->setViewport(0, 0, width(), height());
-            camera->setRenderOrder(osg::Camera::PRE_RENDER);
 #ifdef OSG_HAS_MULTIVIEW
             if (shouldDoTextureArray())
             {
diff --git a/apps/openmw/mwrender/hdr.cpp b/apps/openmw/mwrender/hdr.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..95015da83a0211e868b9c2ba5d129285caea7862
--- /dev/null
+++ b/apps/openmw/mwrender/hdr.cpp
@@ -0,0 +1,123 @@
+#include "hdr.hpp"
+
+#include <components/settings/settings.hpp>
+#include <components/shader/shadermanager.hpp>
+
+#include "pingpongcanvas.hpp"
+
+namespace MWRender
+{
+    HDRDriver::HDRDriver(Shader::ShaderManager& shaderManager)
+        : mCompiled(false)
+        , mEnabled(false)
+        , mWidth(1)
+        , mHeight(1)
+    {
+        const float hdrExposureTime = std::clamp(Settings::Manager::getFloat("hdr exposure time", "Post Processing"), 0.f, 1.f);
+
+        constexpr float minLog = -9.0;
+        constexpr float maxLog = 4.0;
+        constexpr float logLumRange = (maxLog - minLog);
+        constexpr float invLogLumRange = 1.0 / logLumRange;
+        constexpr float epsilon = 0.004;
+
+        Shader::ShaderManager::DefineMap defines = {
+            {"minLog", std::to_string(minLog)},
+            {"maxLog", std::to_string(maxLog)},
+            {"logLumRange", std::to_string(logLumRange)},
+            {"invLogLumRange", std::to_string(invLogLumRange)},
+            {"hdrExposureTime", std::to_string(hdrExposureTime)},
+            {"epsilon", std::to_string(epsilon)},
+        };
+
+        auto vertex = shaderManager.getShader("fullscreen_tri_vertex.glsl", {}, osg::Shader::VERTEX);
+        auto hdrLuminance = shaderManager.getShader("hdr_luminance_fragment.glsl", defines, osg::Shader::FRAGMENT);
+        auto hdr = shaderManager.getShader("hdr_fragment.glsl", defines, osg::Shader::FRAGMENT);
+
+        mProgram = shaderManager.getProgram(vertex, hdr);
+        mLuminanceProgram = shaderManager.getProgram(vertex, hdrLuminance);
+    }
+
+    void HDRDriver::compile()
+    {
+        int mipmapLevels = osg::Image::computeNumberOfMipmapLevels(mWidth, mHeight);
+
+        for (auto& buffer : mBuffers)
+        {
+            buffer.texture = new osg::Texture2D;
+            buffer.texture->setInternalFormat(GL_R16F);
+            buffer.texture->setSourceFormat(GL_RED);
+            buffer.texture->setSourceType(GL_FLOAT);
+            buffer.texture->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR_MIPMAP_NEAREST);
+            buffer.texture->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);
+            buffer.texture->setTextureSize(mWidth, mHeight);
+            buffer.texture->setNumMipmapLevels(mipmapLevels);
+
+            buffer.finalTexture = new osg::Texture2D;
+            buffer.finalTexture->setInternalFormat(GL_R16F);
+            buffer.finalTexture->setSourceFormat(GL_RED);
+            buffer.finalTexture->setSourceType(GL_FLOAT);
+            buffer.finalTexture->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::NEAREST);
+            buffer.finalTexture->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::NEAREST);
+            buffer.finalTexture->setTextureSize(1, 1);
+
+            buffer.finalFbo = new osg::FrameBufferObject;
+            buffer.finalFbo->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0, osg::FrameBufferAttachment(buffer.finalTexture));
+
+            buffer.fullscreenFbo = new osg::FrameBufferObject;
+            buffer.fullscreenFbo->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0, osg::FrameBufferAttachment(buffer.texture));
+
+            buffer.mipmapFbo = new osg::FrameBufferObject;
+            buffer.mipmapFbo->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0, osg::FrameBufferAttachment(buffer.texture, mipmapLevels - 1));
+
+            buffer.fullscreenStateset = new osg::StateSet;
+            buffer.fullscreenStateset->setAttributeAndModes(mLuminanceProgram);
+            buffer.fullscreenStateset->addUniform(new osg::Uniform("sceneTex", 0));
+
+            buffer.mipmapStateset = new osg::StateSet;
+            buffer.mipmapStateset->setAttributeAndModes(mProgram);
+            buffer.mipmapStateset->setTextureAttributeAndModes(0, buffer.texture);
+            buffer.mipmapStateset->addUniform(new osg::Uniform("luminanceSceneTex", 0));
+            buffer.mipmapStateset->addUniform(new osg::Uniform("prevLuminanceSceneTex", 1));
+        }
+
+        mBuffers[0].mipmapStateset->setTextureAttributeAndModes(1, mBuffers[1].finalTexture);
+        mBuffers[1].mipmapStateset->setTextureAttributeAndModes(1, mBuffers[0].finalTexture);
+
+        mCompiled = true;
+    }
+
+    void HDRDriver::draw(const PingPongCanvas& canvas, osg::RenderInfo& renderInfo, osg::State& state, osg::GLExtensions* ext, size_t frameId)
+    {
+        if (!mEnabled)
+            return;
+
+        if (!mCompiled)
+            compile();
+
+        auto& hdrBuffer = mBuffers[frameId];
+        hdrBuffer.fullscreenFbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+        hdrBuffer.fullscreenStateset->setTextureAttributeAndModes(0, canvas.getSceneTexture(frameId));
+
+        state.apply(hdrBuffer.fullscreenStateset);
+        canvas.drawGeometry(renderInfo);
+
+        state.applyTextureAttribute(0, hdrBuffer.texture);
+        ext->glGenerateMipmap(GL_TEXTURE_2D);
+
+        hdrBuffer.mipmapFbo->apply(state, osg::FrameBufferObject::READ_FRAMEBUFFER);
+        hdrBuffer.finalFbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+
+        ext->glBlitFramebuffer(0, 0, 1, 1, 0, 0, 1, 1, GL_COLOR_BUFFER_BIT, GL_LINEAR);
+
+        state.apply(hdrBuffer.mipmapStateset);
+        canvas.drawGeometry(renderInfo);
+
+        ext->glBindFramebuffer(GL_FRAMEBUFFER_EXT, state.getGraphicsContext() ? state.getGraphicsContext()->getDefaultFboId() : 0);
+    }
+
+    osg::ref_ptr<osg::Texture2D> HDRDriver::getLuminanceTexture(size_t frameId) const
+    {
+        return mBuffers[frameId].finalTexture;
+    }
+}
\ No newline at end of file
diff --git a/apps/openmw/mwrender/hdr.hpp b/apps/openmw/mwrender/hdr.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..95bdc6aa0a184169db5ce073d4e08392bcdfc62d
--- /dev/null
+++ b/apps/openmw/mwrender/hdr.hpp
@@ -0,0 +1,71 @@
+#ifndef OPENMW_MWRENDER_HDR_H
+#define OPENMW_MWRENDER_HDR_H
+
+#include <array>
+
+#include <osg/FrameBufferObject>
+#include <osg/Texture2D>
+#include <osg/Program>
+
+namespace Shader
+{
+    class ShaderManager;
+}
+
+namespace MWRender
+{
+    class PingPongCanvas;
+
+    class HDRDriver
+    {
+
+    public:
+
+        HDRDriver() = default;
+
+        HDRDriver(Shader::ShaderManager& shaderManager);
+
+        void draw(const PingPongCanvas& canvas, osg::RenderInfo& renderInfo, osg::State& state, osg::GLExtensions* ext, size_t frameId);
+
+        bool isEnabled() const { return mEnabled; }
+
+        void enable() { mEnabled = true; }
+        void disable() { mEnabled = false; }
+
+        void dirty(int w, int h)
+        {
+            mWidth = w;
+            mHeight = h;
+            mCompiled = false;
+        }
+
+        osg::ref_ptr<osg::Texture2D> getLuminanceTexture(size_t frameId) const;
+
+    private:
+
+        void compile();
+
+        struct HDRContainer
+        {
+            osg::ref_ptr<osg::FrameBufferObject> fullscreenFbo;
+            osg::ref_ptr<osg::FrameBufferObject> mipmapFbo;
+            osg::ref_ptr<osg::FrameBufferObject> finalFbo;
+            osg::ref_ptr<osg::Texture2D> texture;
+            osg::ref_ptr<osg::Texture2D> finalTexture;
+            osg::ref_ptr<osg::StateSet> fullscreenStateset;
+            osg::ref_ptr<osg::StateSet> mipmapStateset;
+        };
+
+        std::array<HDRContainer, 2> mBuffers;
+        osg::ref_ptr<osg::Program> mLuminanceProgram;
+        osg::ref_ptr<osg::Program> mProgram;
+
+        bool mCompiled;
+        bool mEnabled;
+
+        int mWidth;
+        int mHeight;
+    };
+}
+
+#endif
diff --git a/apps/openmw/mwrender/localmap.cpp b/apps/openmw/mwrender/localmap.cpp
index 2fd3c8b7f71b7acd8059efdacac318dbbc451827..fda98a1589a2d6c00ea7c72510ea6ffc3392b30c 100644
--- a/apps/openmw/mwrender/localmap.cpp
+++ b/apps/openmw/mwrender/localmap.cpp
@@ -670,6 +670,7 @@ LocalMapRenderToTexture::LocalMapRenderToTexture(osg::Node* sceneRoot, int res,
     mViewMatrix.makeLookAt(osg::Vec3d(x, y, zmax + 5), osg::Vec3d(x, y, zmin), upVector);
 
     setUpdateCallback(new CameraLocalUpdateCallback);
+    setDepthBufferInternalFormat(GL_DEPTH24_STENCIL8);
 }
 
 void LocalMapRenderToTexture::setDefaults(osg::Camera* camera)
diff --git a/apps/openmw/mwrender/npcanimation.cpp b/apps/openmw/mwrender/npcanimation.cpp
index 0d74b8d30287bddedbca136eaea9b3b370bcf666..7ce5594f966e908bbe83409dc9df615ad908f523 100644
--- a/apps/openmw/mwrender/npcanimation.cpp
+++ b/apps/openmw/mwrender/npcanimation.cpp
@@ -327,24 +327,31 @@ public:
 
         state->applyAttribute(mDepth);
 
-        if (postProcessor && postProcessor->getFirstPersonRBProxy())
-        {
-            osg::GLExtensions* ext = state->get<osg::GLExtensions>();
+        unsigned int frameId = state->getFrameStamp()->getFrameNumber() % 2;
 
-            osg::FrameBufferAttachment(postProcessor->getFirstPersonRBProxy()).attach(*state, GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, ext);
+        if (postProcessor && postProcessor->getFbo(PostProcessor::FBO_FirstPerson, frameId))
+        {
+            postProcessor->getFbo(PostProcessor::FBO_FirstPerson, frameId)->apply(*state);
 
             glClear(GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
             // color accumulation pass
             bin->drawImplementation(renderInfo, previous);
 
-            auto primaryFBO = postProcessor->getMsaaFbo() ? postProcessor->getMsaaFbo() : postProcessor->getFbo();
-            primaryFBO->getAttachment(osg::FrameBufferObject::BufferComponent::PACKED_DEPTH_STENCIL_BUFFER).attach(*state, GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, ext);
+            auto primaryFBO = postProcessor->getPrimaryFbo(frameId);
+
+            if (postProcessor->getFbo(PostProcessor::FBO_OpaqueDepth, frameId))
+                postProcessor->getFbo(PostProcessor::FBO_OpaqueDepth, frameId)->apply(*state);
+            else
+                primaryFBO->apply(*state);
 
-            state->pushStateSet(mStateSet);
-            state->apply();
             // depth accumulation pass
+            osg::ref_ptr<osg::StateSet> restore = bin->getStateSet();
+            bin->setStateSet(mStateSet);
             bin->drawImplementation(renderInfo, previous);
-            state->popStateSet();
+            bin->setStateSet(restore);
+
+            if (postProcessor->getFbo(PostProcessor::FBO_OpaqueDepth, frameId))
+                primaryFBO->apply(*state);
         }
         else
         {
diff --git a/apps/openmw/mwrender/pingpongcanvas.cpp b/apps/openmw/mwrender/pingpongcanvas.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..9592a8bbba9e50dddca49bb15d5e3daf650a3695
--- /dev/null
+++ b/apps/openmw/mwrender/pingpongcanvas.cpp
@@ -0,0 +1,260 @@
+#include "pingpongcanvas.hpp"
+
+#include <components/shader/shadermanager.hpp>
+#include <components/debug/debuglog.hpp>
+
+#include "postprocessor.hpp"
+
+namespace MWRender
+{
+    PingPongCanvas::PingPongCanvas(Shader::ShaderManager& shaderManager)
+        : mFallbackStateSet(new osg::StateSet)
+        , mQueuedDispatchArray(std::nullopt)
+        , mQueuedDispatchFrameId(0)
+    {
+        setUseDisplayList(false);
+        setUseVertexBufferObjects(true);
+
+        osg::ref_ptr<osg::Vec3Array> verts = new osg::Vec3Array;
+        verts->push_back(osg::Vec3f(-1, -1, 0));
+        verts->push_back(osg::Vec3f(-1, 3, 0));
+        verts->push_back(osg::Vec3f(3, -1, 0));
+
+        setVertexArray(verts);
+
+        addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::TRIANGLES, 0, 3));
+
+        mHDRDriver = HDRDriver(shaderManager);
+        mHDRDriver.disable();
+
+        auto fallbackVertex = shaderManager.getShader("fullscreen_tri_vertex.glsl", {}, osg::Shader::VERTEX);
+        auto fallbackFragment = shaderManager.getShader("fullscreen_tri_fragment.glsl", {}, osg::Shader::FRAGMENT);
+        mFallbackProgram = shaderManager.getProgram(fallbackVertex, fallbackFragment);
+
+        mFallbackStateSet->setAttributeAndModes(mFallbackProgram);
+        mFallbackStateSet->addUniform(new osg::Uniform("omw_SamplerLastShader", 0));
+    }
+
+    void PingPongCanvas::setCurrentFrameData(size_t frameId, fx::DispatchArray&& data)
+    {
+        mQueuedDispatchArray = fx::DispatchArray(data);
+        mQueuedDispatchFrameId = !frameId;
+
+        mBufferData[frameId].data = std::move(data);
+    }
+
+    void PingPongCanvas::setMask(size_t frameId, bool underwater, bool exterior)
+    {
+        mBufferData[frameId].mask = 0;
+
+        mBufferData[frameId].mask |= underwater ? fx::Technique::Flag_Disable_Underwater : fx::Technique::Flag_Disable_Abovewater;
+        mBufferData[frameId].mask |= exterior ? fx::Technique::Flag_Disable_Exteriors : fx::Technique::Flag_Disable_Interiors;
+    }
+
+    void PingPongCanvas::drawGeometry(osg::RenderInfo& renderInfo) const
+    {
+        osg::Geometry::drawImplementation(renderInfo);
+    }
+
+    void PingPongCanvas::drawImplementation(osg::RenderInfo& renderInfo) const
+    {
+        osg::State& state = *renderInfo.getState();
+        osg::GLExtensions* ext = state.get<osg::GLExtensions>();
+
+        size_t frameId = state.getFrameStamp()->getFrameNumber() % 2;
+
+        auto& bufferData = mBufferData[frameId];
+
+        if (mQueuedDispatchArray && mQueuedDispatchFrameId == frameId)
+        {
+            mBufferData[frameId].data = std::move(mQueuedDispatchArray.value());
+            mQueuedDispatchArray = std::nullopt;
+        }
+
+        const auto& data = bufferData.data;
+
+        std::vector<size_t> filtered;
+
+        filtered.reserve(data.size());
+
+        const fx::DispatchNode::SubPass* resolvePass = nullptr;
+
+        for (size_t i = 0; i < data.size(); ++i)
+        {
+            const auto& node = data[i];
+
+            if (bufferData.mask & node.mFlags)
+                continue;
+
+            for (auto it = node.mPasses.crbegin(); it != node.mPasses.crend(); ++it)
+            {
+                if (!(*it).mRenderTarget)
+                {
+                    resolvePass = &(*it);
+                    break;
+                }
+            }
+
+            filtered.push_back(i);
+        }
+
+        auto* viewport = state.getCurrentViewport();
+
+        if (filtered.empty() || !bufferData.postprocessing)
+        {
+            if (bufferData.postprocessing)
+                Log(Debug::Error) << "Critical error, postprocess shaders failed to compile. Using default shader.";
+
+            mFallbackStateSet->setTextureAttributeAndModes(0, bufferData.sceneTex);
+
+            state.pushStateSet(mFallbackStateSet);
+            state.apply();
+            viewport->apply(state);
+
+            drawGeometry(renderInfo);
+            state.popStateSet();
+            return;
+        }
+
+        const unsigned int handle = mFbos[0] ? mFbos[0]->getHandle(state.getContextID()) : 0;
+
+        if (handle == 0 || bufferData.dirty)
+        {
+            for (auto& fbo : mFbos)
+            {
+                fbo = new osg::FrameBufferObject;
+                fbo->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0, osg::FrameBufferAttachment(new osg::Texture2D(*bufferData.sceneTexLDR)));
+                fbo->apply(state);
+                glClearColor(0.5, 0.5, 0.5, 1);
+                glClear(GL_COLOR_BUFFER_BIT);
+            }
+
+            mHDRDriver.dirty(bufferData.sceneTex->getTextureWidth(), bufferData.sceneTex->getTextureHeight());
+
+            bufferData.dirty = false;
+        }
+
+        constexpr std::array<std::array<int, 2>, 3> buffers = {{
+            {GL_COLOR_ATTACHMENT1_EXT, GL_COLOR_ATTACHMENT2_EXT},
+            {GL_COLOR_ATTACHMENT0_EXT, GL_COLOR_ATTACHMENT2_EXT},
+            {GL_COLOR_ATTACHMENT0_EXT, GL_COLOR_ATTACHMENT1_EXT}
+        }};
+
+        (bufferData.hdr) ? mHDRDriver.enable() : mHDRDriver.disable();
+
+        // A histogram based approach is superior way to calculate scene luminance. Using mipmaps is more broadly supported, so that's what we use for now.
+        mHDRDriver.draw(*this, renderInfo, state, ext, frameId);
+
+        auto buffer = buffers[0];
+
+        int lastDraw = 0;
+        int lastShader = 0;
+
+        unsigned int lastApplied = handle;
+
+        const unsigned int cid = state.getContextID();
+
+        const osg::ref_ptr<osg::FrameBufferObject>& destinationFbo = bufferData.destination ? bufferData.destination : nullptr;
+        unsigned int destinationHandle = destinationFbo ? destinationFbo->getHandle(cid) : 0;
+
+        auto bindDestinationFbo = [&]() {
+            if (destinationFbo)
+            {
+                destinationFbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+                lastApplied = destinationHandle;
+            }
+            else
+            {
+                ext->glBindFramebuffer(GL_DRAW_FRAMEBUFFER_EXT, 0);
+
+                lastApplied = 0;
+            }
+        };
+
+        for (const size_t& index : filtered)
+        {
+            const auto& node = data[index];
+
+            node.mRootStateSet->setTextureAttribute(PostProcessor::Unit_Depth, bufferData.depthTex);
+
+            if (bufferData.hdr)
+                node.mRootStateSet->setTextureAttribute(PostProcessor::TextureUnits::Unit_EyeAdaptation, mHDRDriver.getLuminanceTexture(frameId));
+
+            if (bufferData.normalsTex)
+                node.mRootStateSet->setTextureAttribute(PostProcessor::TextureUnits::Unit_Normals, bufferData.normalsTex);
+
+            state.pushStateSet(node.mRootStateSet);
+            state.apply();
+
+            for (size_t passIndex = 0; passIndex < node.mPasses.size(); ++passIndex)
+            {
+                const auto& pass = node.mPasses[passIndex];
+
+                bool lastPass = passIndex == node.mPasses.size() - 1;
+
+                if (lastShader == 0)
+                    pass.mStateSet->setTextureAttribute(PostProcessor::Unit_LastShader, bufferData.sceneTex);
+                else
+                    pass.mStateSet->setTextureAttribute(PostProcessor::Unit_LastShader, (osg::Texture2D*)mFbos[lastShader - GL_COLOR_ATTACHMENT0_EXT]->getAttachment(osg::Camera::COLOR_BUFFER0).getTexture());
+
+                if (lastDraw == 0)
+                    pass.mStateSet->setTextureAttribute(PostProcessor::Unit_LastPass, bufferData.sceneTex);
+                else
+                    pass.mStateSet->setTextureAttribute(PostProcessor::Unit_LastPass, (osg::Texture2D*)mFbos[lastDraw - GL_COLOR_ATTACHMENT0_EXT]->getAttachment(osg::Camera::COLOR_BUFFER0).getTexture());
+
+                if (pass.mRenderTarget)
+                {
+                    pass.mRenderTarget->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+
+                    if (pass.mRenderTexture->getNumMipmapLevels() > 0)
+                    {
+                        state.setActiveTextureUnit(0);
+                        state.applyTextureAttribute(0, pass.mRenderTarget->getAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0).getTexture());
+                        ext->glGenerateMipmap(GL_TEXTURE_2D);
+                    }
+
+                    lastApplied = pass.mRenderTarget->getHandle(state.getContextID());;
+                }
+                else if (&pass == resolvePass)
+                {
+                    bindDestinationFbo();
+                }
+                else if (lastPass)
+                {
+                    lastDraw = buffer[0];
+                    lastShader = buffer[0];
+                    mFbos[buffer[0] - GL_COLOR_ATTACHMENT0_EXT]->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+                    buffer = buffers[lastShader - GL_COLOR_ATTACHMENT0_EXT];
+
+                    lastApplied = mFbos[buffer[0] - GL_COLOR_ATTACHMENT0_EXT]->getHandle(cid);
+                }
+                else
+                {
+                    mFbos[buffer[0] - GL_COLOR_ATTACHMENT0_EXT]->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+                    lastDraw = buffer[0];
+                    std::swap(buffer[0], buffer[1]);
+
+                    lastApplied = mFbos[buffer[0] - GL_COLOR_ATTACHMENT0_EXT]->getHandle(cid);
+                }
+
+                state.pushStateSet(pass.mStateSet);
+                state.apply();
+
+                if (!state.getLastAppliedProgramObject())
+                    mFallbackProgram->apply(state);
+
+                drawGeometry(renderInfo);
+
+                state.popStateSet();
+                state.apply();
+            }
+
+            state.popStateSet();
+        }
+
+        if (lastApplied != destinationHandle)
+        {
+            bindDestinationFbo();
+        }
+    }
+}
diff --git a/apps/openmw/mwrender/pingpongcanvas.hpp b/apps/openmw/mwrender/pingpongcanvas.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..bb39f9bcf3d8f417f92f8893a75d6934959990a7
--- /dev/null
+++ b/apps/openmw/mwrender/pingpongcanvas.hpp
@@ -0,0 +1,88 @@
+#ifndef OPENMW_MWRENDER_PINGPONGCANVAS_H
+#define OPENMW_MWRENDER_PINGPONGCANVAS_H
+
+#include <array>
+#include <optional>
+
+#include <osg/Geometry>
+#include <osg/Texture2D>
+#include <osg/FrameBufferObject>
+
+#include <components/fx/technique.hpp>
+
+#include "postprocessor.hpp"
+#include "hdr.hpp"
+
+namespace Shader
+{
+    class ShaderManager;
+}
+
+namespace MWRender
+{
+    class PingPongCanvas : public osg::Geometry
+    {
+    public:
+        PingPongCanvas(Shader::ShaderManager& shaderManager);
+
+        void drawImplementation(osg::RenderInfo& renderInfo) const override;
+
+        void dirty(size_t frameId) { mBufferData[frameId].dirty = true; }
+
+        const fx::DispatchArray& getCurrentFrameData(size_t frame) { return mBufferData[frame % 2].data; }
+
+        // Sets current frame pass data and stores copy of dispatch array to apply to next frame data
+        void setCurrentFrameData(size_t frameId, fx::DispatchArray&& data);
+
+        void setMask(size_t frameId, bool underwater, bool exterior);
+
+        void setSceneTexture(size_t frameId, osg::ref_ptr<osg::Texture> tex) { mBufferData[frameId].sceneTex = tex; }
+
+        void setLDRSceneTexture(size_t frameId, osg::ref_ptr<osg::Texture2D> tex) { mBufferData[frameId].sceneTexLDR = tex; }
+
+        void setDepthTexture(size_t frameId, osg::ref_ptr<osg::Texture> tex) { mBufferData[frameId].depthTex = tex; }
+
+        void setNormalsTexture(size_t frameId, osg::ref_ptr<osg::Texture2D> tex) { mBufferData[frameId].normalsTex = tex; }
+
+        void setHDR(size_t frameId, bool hdr) { mBufferData[frameId].hdr = hdr; }
+
+        void setPostProcessing(size_t frameId, bool postprocessing) { mBufferData[frameId].postprocessing = postprocessing; }
+
+        const osg::ref_ptr<osg::Texture>& getSceneTexture(size_t frameId) const { return mBufferData[frameId].sceneTex; }
+
+        void drawGeometry(osg::RenderInfo& renderInfo) const;
+
+    private:
+        void copyNewFrameData(size_t frameId) const;
+
+        mutable HDRDriver mHDRDriver;
+
+        osg::ref_ptr<osg::Program> mFallbackProgram;
+        osg::ref_ptr<osg::StateSet> mFallbackStateSet;
+
+        struct BufferData
+        {
+            bool dirty = false;
+            bool hdr = false;
+            bool postprocessing = true;
+
+            fx::DispatchArray data;
+            fx::FlagsType mask;
+
+            osg::ref_ptr<osg::FrameBufferObject> destination;
+
+            osg::ref_ptr<osg::Texture> sceneTex;
+            osg::ref_ptr<osg::Texture> depthTex;
+            osg::ref_ptr<osg::Texture2D> sceneTexLDR;
+            osg::ref_ptr<osg::Texture2D> normalsTex;
+        };
+
+        mutable std::array<BufferData, 2> mBufferData;
+        mutable std::array<osg::ref_ptr<osg::FrameBufferObject>, 3> mFbos;
+
+        mutable std::optional<fx::DispatchArray> mQueuedDispatchArray;
+        mutable size_t mQueuedDispatchFrameId;
+    };
+}
+
+#endif
diff --git a/apps/openmw/mwrender/pingpongcull.cpp b/apps/openmw/mwrender/pingpongcull.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..2bec155bbbaf0666a3d1a2e2680cd67d80dbc31d
--- /dev/null
+++ b/apps/openmw/mwrender/pingpongcull.cpp
@@ -0,0 +1,47 @@
+#include "pingpongcull.hpp"
+
+#include <osg/Camera>
+#include <osg/FrameBufferObject>
+#include <osgUtil/CullVisitor>
+
+#include "postprocessor.hpp"
+#include "pingpongcanvas.hpp"
+
+namespace MWRender
+{
+    void PingPongCull::operator()(osg::Node* node, osgUtil::CullVisitor* cv)
+    {
+        osgUtil::RenderStage* renderStage = cv->getCurrentRenderStage();
+        size_t frame = cv->getTraversalNumber();
+        size_t frameId = frame % 2;
+
+        MWRender::PostProcessor* postProcessor = dynamic_cast<MWRender::PostProcessor*>(cv->getCurrentCamera()->getUserData());
+
+        postProcessor->getStateUpdater()->setViewMatrix(cv->getCurrentCamera()->getViewMatrix());
+        postProcessor->getStateUpdater()->setInvViewMatrix(cv->getCurrentCamera()->getInverseViewMatrix());
+        postProcessor->getStateUpdater()->setPrevViewMatrix(mLastViewMatrix);
+        mLastViewMatrix = cv->getCurrentCamera()->getViewMatrix();
+        postProcessor->getStateUpdater()->setEyePos(cv->getEyePoint());
+        postProcessor->getStateUpdater()->setEyeVec(cv->getLookVectorLocal());
+
+        if (!postProcessor || !postProcessor->getFbo(PostProcessor::FBO_Primary, frameId))
+        {
+            renderStage->setMultisampleResolveFramebufferObject(nullptr);
+            renderStage->setFrameBufferObject(nullptr);
+            traverse(node, cv);
+            return;
+        }
+
+        if (!postProcessor->getFbo(PostProcessor::FBO_Multisample, frameId))
+        {
+            renderStage->setFrameBufferObject(postProcessor->getFbo(PostProcessor::FBO_Primary, frameId));
+        }
+        else
+        {
+            renderStage->setMultisampleResolveFramebufferObject(postProcessor->getFbo(PostProcessor::FBO_Primary, frameId));
+            renderStage->setFrameBufferObject(postProcessor->getFbo(PostProcessor::FBO_Multisample, frameId));
+        }
+
+        traverse(node, cv);
+    }
+}
diff --git a/apps/openmw/mwrender/pingpongcull.hpp b/apps/openmw/mwrender/pingpongcull.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..d4514e20d3e7f4a4631db5a47c70868ee7d3bd9b
--- /dev/null
+++ b/apps/openmw/mwrender/pingpongcull.hpp
@@ -0,0 +1,22 @@
+#ifndef OPENMW_MWRENDER_PINGPONGCULL_H
+#define OPENMW_MWRENDER_PINGPONGCULL_H
+
+#include <array>
+
+#include <components/sceneutil/nodecallback.hpp>
+
+#include "postprocessor.hpp"
+
+namespace MWRender
+{
+    class PostProcessor;
+    class PingPongCull : public SceneUtil::NodeCallback<PingPongCull, osg::Node*, osgUtil::CullVisitor*>
+    {
+    public:
+        void operator()(osg::Node* node, osgUtil::CullVisitor* nv);
+    private:
+        osg::Matrixf mLastViewMatrix;
+    };
+}
+
+#endif
diff --git a/apps/openmw/mwrender/postprocessor.cpp b/apps/openmw/mwrender/postprocessor.cpp
index 9fbc5de528ea83177e3925d6986db795f8c4f687..df42daa34c5e5c1cfeb371fc5d81e04f45212b41 100644
--- a/apps/openmw/mwrender/postprocessor.cpp
+++ b/apps/openmw/mwrender/postprocessor.cpp
@@ -2,354 +2,719 @@
 
 #include <SDL_opengl_glext.h>
 
-#include <osg/Group>
-#include <osg/Camera>
-#include <osg/Callback>
+#include <osg/Texture1D>
 #include <osg/Texture2D>
+#include <osg/Texture3D>
 #include <osg/Texture2DArray>
-#include <osg/FrameBufferObject>
-
-#include <osgViewer/Viewer>
 
 #include <components/settings/settings.hpp>
 #include <components/sceneutil/depth.hpp>
 #include <components/sceneutil/color.hpp>
 #include <components/sceneutil/nodecallback.hpp>
-#include <components/debug/debuglog.hpp>
-
+#include <components/sceneutil/util.hpp>
+#include <components/resource/scenemanager.hpp>
+#include <components/shader/shadermanager.hpp>
+#include <components/misc/stringops.hpp>
+#include <components/vfs/manager.hpp>
 #include <components/stereo/multiview.hpp>
 #include <components/stereo/stereomanager.hpp>
 
+#include "../mwbase/world.hpp"
+#include "../mwbase/environment.hpp"
+#include "../mwbase/windowmanager.hpp"
+
+#include "../mwgui/postprocessorhud.hpp"
+
+#include "transparentpass.hpp"
+#include "pingpongcull.hpp"
+#include "renderingmanager.hpp"
 #include "vismask.hpp"
+#include "sky.hpp"
 
 namespace
 {
-    osg::ref_ptr<osg::Geometry> createFullScreenTri()
+    struct ResizedCallback : osg::GraphicsContext::ResizedCallback
     {
-        osg::ref_ptr<osg::Geometry> geom = new osg::Geometry;
-
-        osg::ref_ptr<osg::Vec3Array> verts = new osg::Vec3Array;
-        verts->push_back(osg::Vec3f(-1, -1, 0));
-        verts->push_back(osg::Vec3f(-1, 3, 0));
-        verts->push_back(osg::Vec3f(3, -1, 0));
+        ResizedCallback(MWRender::PostProcessor* postProcessor)
+            : mPostProcessor(postProcessor)
+        { }
 
-        geom->setVertexArray(verts);
+        void resizedImplementation(osg::GraphicsContext* gc, int x, int y, int width, int height) override
+        {
+            gc->resizedImplementation(x, y, width, height);
 
-        geom->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::TRIANGLES, 0, 3));
+            mPostProcessor->setRenderTargetSize(width, height);
+            mPostProcessor->resize();
+        }
 
-        return geom;
-    }
+        MWRender::PostProcessor* mPostProcessor;
+    };
 
-    class CullCallback : public SceneUtil::NodeCallback<CullCallback, osg::Node*, osgUtil::CullVisitor*>
+    class HUDCullCallback : public SceneUtil::NodeCallback<HUDCullCallback, osg::Camera*, osgUtil::CullVisitor*>
     {
     public:
-        CullCallback(MWRender::PostProcessor* pp)
-            : mPostProcessor(pp)
+        void operator()(osg::Camera* camera, osgUtil::CullVisitor* cv)
         {
+            osg::ref_ptr<osg::StateSet> stateset = new osg::StateSet;
+            auto& sm = Stereo::Manager::instance();
+            auto* fullViewport = camera->getViewport();
+            if (sm.getEye(cv) == Stereo::Eye::Left)
+                stateset->setAttributeAndModes(new osg::Viewport(0, 0, fullViewport->width() / 2, fullViewport->height()));
+            if (sm.getEye(cv) == Stereo::Eye::Right)
+                stateset->setAttributeAndModes(new osg::Viewport(fullViewport->width() / 2, 0, fullViewport->width() / 2, fullViewport->height()));
+
+            cv->pushStateSet(stateset);
+            traverse(camera, cv);
+            cv->popViewport();
         }
+    };
+}
 
-        void operator()(osg::Node* node, osgUtil::CullVisitor* cv)
-        {
-            osgUtil::RenderStage* renderStage = cv->getCurrentRenderStage();
+namespace MWRender
+{
+    PostProcessor::PostProcessor(RenderingManager& rendering, osgViewer::Viewer* viewer, osg::Group* rootNode, const VFS::Manager* vfs)
+        : osg::Group()
+        , mRootNode(rootNode)
+        , mSamples(Settings::Manager::getInt("antialiasing", "Video"))
+        , mDirty(false)
+        , mDirtyFrameId(0)
+        , mRendering(rendering)
+        , mViewer(viewer)
+        , mVFS(vfs)
+        , mReload(false)
+        , mEnabled(false)
+        , mUsePostProcessing(false)
+        , mSoftParticles(false)
+        , mDisableDepthPasses(false)
+        , mLastFrameNumber(0)
+        , mLastSimulationTime(0.f)
+        , mExteriorFlag(false)
+        , mUnderwater(false)
+        , mHDR(false)
+        , mNormals(false)
+        , mPrevNormals(false)
+        , mNormalsSupported(false)
+        , mPassLights(false)
+        , mPrevPassLights(false)
+        , mMainTemplate(new osg::Texture2D)
+    {
+        mSoftParticles = Settings::Manager::getBool("soft particles", "Shaders") && !Stereo::getStereo() && !Stereo::getMultiview();
+        mUsePostProcessing = Settings::Manager::getBool("enabled", "Post Processing");
 
-            if (!mPostProcessor->getMsaaFbo())
-            {
-                renderStage->setFrameBufferObject(mPostProcessor->getFbo());
-            }
-            else
-            {
-                renderStage->setMultisampleResolveFramebufferObject(mPostProcessor->getFbo());
-                renderStage->setFrameBufferObject(mPostProcessor->getMsaaFbo());
-            }
+        osg::GraphicsContext* gc = viewer->getCamera()->getGraphicsContext();
+        osg::GLExtensions* ext = gc->getState()->get<osg::GLExtensions>();
 
-            traverse(node, cv);
-        }
+        mWidth = gc->getTraits()->width;
+        mHeight = gc->getTraits()->height;
 
-    private:
-        MWRender::PostProcessor* mPostProcessor;
-    };
+        if (!ext->glDisablei && ext->glDisableIndexedEXT)
+            ext->glDisablei = ext->glDisableIndexedEXT;
 
-    struct ResizedCallback : osg::GraphicsContext::ResizedCallback
+#ifdef ANDROID
+        ext->glDisablei = nullptr;
+#endif
+
+        if (ext->glDisablei)
+            mNormalsSupported = true;
+        else
+            Log(Debug::Error) << "'glDisablei' unsupported, pass normals will not be available to shaders.";
+
+        if (mSoftParticles)
+            for (int i = 0; i < 2; ++i)
+                mTextures[i][Tex_OpaqueDepth] = new osg::Texture2D;
+
+        mGLSLVersion = ext->glslLanguageVersion * 100;
+        mUBO = ext && ext->isUniformBufferObjectSupported && mGLSLVersion >= 330;
+        mStateUpdater = new fx::StateUpdater(mUBO);
+
+        if (!SceneUtil::AutoDepth::isReversed() && !mSoftParticles && !mUsePostProcessing && !Stereo::getStereo() && !Stereo::getMultiview())
+            return;
+
+        enable(mUsePostProcessing);
+    }
+
+    PostProcessor::~PostProcessor()
     {
-        ResizedCallback(MWRender::PostProcessor* postProcessor)
-            : mPostProcessor(postProcessor)
-        {
-        }
+        if (auto* bin = osgUtil::RenderBin::getRenderBinPrototype("DepthSortedBin"))
+            bin->setDrawCallback(nullptr);
+    }
 
-        void resizedImplementation(osg::GraphicsContext* gc, int x, int y, int width, int height) override
+    void PostProcessor::resize()
+    {
+        for (auto& technique : mTechniques)
         {
-            gc->resizedImplementation(x, y, width, height);
-            mPostProcessor->resize(width, height);
+            for (auto& [name, rt] : technique->getRenderTargetsMap())
+            {
+                const auto [w, h] = rt.mSize.get(mWidth, mHeight);
+                rt.mTarget->setTextureSize(w, h);
+                rt.mTarget->dirtyTextureObject();
+            }
         }
 
-        MWRender::PostProcessor* mPostProcessor;
-    };
+        size_t frameId = frame() % 2;
+
+        createTexturesAndCamera(frameId);
+        createObjectsForFrame(frameId);
+
+        mHUDCamera->resize(mWidth, mHeight);
+        mViewer->getCamera()->resize(mWidth, mHeight);
+        mRendering.updateProjectionMatrix();
+        mRendering.setScreenRes(mWidth, mHeight);
+
+        dirtyTechniques();
+
+        mPingPongCanvas->dirty(frameId);
 
-    // Copies the currently bound depth attachment to a new texture so drawables in transparent renderbin can safely sample from depth.
-    class OpaqueDepthCopyCallback : public osgUtil::RenderBin::DrawCallback
+        mDirty = true;
+        mDirtyFrameId = !frameId;
+
+        if (Stereo::getStereo())
+            Stereo::Manager::instance().screenResolutionChanged();
+    }
+
+    void PostProcessor::enable(bool usePostProcessing)
     {
-    public:
-        OpaqueDepthCopyCallback(osg::ref_ptr<osg::Texture2D> opaqueDepthTex, osg::ref_ptr<osg::FrameBufferObject> sourceFbo)
-            : mOpaqueDepthFbo(new osg::FrameBufferObject)
-            , mSourceFbo(sourceFbo)
-            , mOpaqueDepthTex(opaqueDepthTex)
-            , mColorAttached(false)
-        {
-            mOpaqueDepthFbo->setAttachment(osg::FrameBufferObject::BufferComponent::DEPTH_BUFFER, osg::FrameBufferAttachment(opaqueDepthTex));
+        mReload = true;
+        mEnabled = true;
+        bool postPass = Settings::Manager::getBool("transparent postpass", "Post Processing");
+        mUsePostProcessing = usePostProcessing && !Stereo::getStereo() && !Stereo::getMultiview();
 
-#ifdef __APPLE__
-            // Mac OS drivers complain that a FBO is incomplete if it has no color attachment
-            mOpaqueDepthFbo->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER, osg::FrameBufferAttachment(new osg::RenderBuffer(mOpaqueDepthTex->getTextureWidth(), mOpaqueDepthTex->getTextureHeight(), GL_RGB)));
-            mColorAttached = true;
+        mDisableDepthPasses = !mSoftParticles && !postPass;
+
+#ifdef ANDROID
+        mDisableDepthPasses = true;
 #endif
+
+        if (!mDisableDepthPasses && !Stereo::getStereo() && !Stereo::getMultiview())
+        {
+            mTransparentDepthPostPass = new TransparentDepthBinCallback(mRendering.getResourceSystem()->getSceneManager()->getShaderManager(), postPass);
+            osgUtil::RenderBin::getRenderBinPrototype("DepthSortedBin")->setDrawCallback(mTransparentDepthPostPass);
         }
 
-        void drawImplementation(osgUtil::RenderBin* bin, osg::RenderInfo& renderInfo, osgUtil::RenderLeaf*& previous) override
+        if (mUsePostProcessing && mTechniqueFileMap.empty())
         {
-            if (bin->getStage()->getFrameBufferObject() == mSourceFbo)
+            for (const auto& name : mVFS->getRecursiveDirectoryIterator(fx::Technique::sSubdir))
             {
-                osg::State& state = *renderInfo.getState();
-                osg::GLExtensions* ext = state.get<osg::GLExtensions>();
+                std::filesystem::path path = name;
+                std::string fileExt = Misc::StringUtils::lowerCase(path.extension().string());
+                if (!path.parent_path().has_parent_path() && fileExt == fx::Technique::sExt)
+                {
+                    auto absolutePath = std::filesystem::path(mVFS->getAbsoluteFileName(name));
 
-                mSourceFbo->apply(state, osg::FrameBufferObject::READ_FRAMEBUFFER);
-                postBindOperation(state);
+                    mTechniqueFileMap[absolutePath.stem().string()] = absolutePath;
+                }
+            }
+        }
 
-                mOpaqueDepthFbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
-                postBindOperation(state);
+        mMainTemplate->setFilter(osg::Texture::MIN_FILTER, osg::Texture::LINEAR);
+        mMainTemplate->setFilter(osg::Texture::MAG_FILTER, osg::Texture::LINEAR);
+        mMainTemplate->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP_TO_EDGE);
+        mMainTemplate->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_EDGE);
+        mMainTemplate->setInternalFormat(GL_RGBA);
+        mMainTemplate->setSourceType(GL_UNSIGNED_BYTE);
+        mMainTemplate->setSourceFormat(GL_RGBA);
 
-                ext->glBlitFramebuffer(0, 0, mOpaqueDepthTex->getTextureWidth(), mOpaqueDepthTex->getTextureHeight(), 0, 0, mOpaqueDepthTex->getTextureWidth(), mOpaqueDepthTex->getTextureHeight(), GL_DEPTH_BUFFER_BIT, GL_NEAREST);
+        createTexturesAndCamera(frame() % 2);
 
-                mSourceFbo->apply(state);
-            }
+        removeChild(mHUDCamera);
+        removeChild(mRootNode);
 
-            bin->drawImplementation(renderInfo, previous);
-        }
-    private:
-        void postBindOperation(osg::State& state)
+        addChild(mHUDCamera);
+        addChild(mRootNode);
+
+        mViewer->setSceneData(this);
+        mViewer->getCamera()->setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT);
+        mViewer->getCamera()->setImplicitBufferAttachmentMask(0, 0);
+        mViewer->getCamera()->getGraphicsContext()->setResizedCallback(new ResizedCallback(this));
+        mViewer->getCamera()->setUserData(this);
+
+        setCullCallback(mStateUpdater);
+        mHUDCamera->setCullCallback(new HUDCullCallback);
+
+        static bool init = false;
+
+        if (init)
         {
-            if (mColorAttached)
-                return;
-            #if !defined(OSG_GLES1_AVAILABLE) && !defined(OSG_GLES2_AVAILABLE) && !defined(OSG_GLES3_AVAILABLE)
-            state.glDrawBuffer(GL_NONE);
-            state.glReadBuffer(GL_NONE);
-            #endif
+            resize();
+            init = true;
         }
 
-        osg::ref_ptr<osg::FrameBufferObject> mOpaqueDepthFbo;
-        osg::ref_ptr<osg::FrameBufferObject> mSourceFbo;
-        osg::ref_ptr<osg::Texture2D> mOpaqueDepthTex;
-        bool mColorAttached;
-    };
-}
+        init = true;
+    }
 
-namespace MWRender
-{
-    PostProcessor::PostProcessor(osgViewer::Viewer* viewer, osg::Group* rootNode)
-        : mViewer(viewer)
-        , mRootNode(new osg::Group)
+    void PostProcessor::disable()
     {
-        bool softParticles = Settings::Manager::getBool("soft particles", "Shaders");
+        if (!mSoftParticles)
+            osgUtil::RenderBin::getRenderBinPrototype("DepthSortedBin")->setDrawCallback(nullptr);
 
-        if (!SceneUtil::AutoDepth::isReversed() && !softParticles && !Stereo::getStereo())
-            return;
+        if (!SceneUtil::AutoDepth::isReversed() && !mSoftParticles && !Stereo::getStereo() && !Stereo::getMultiview())
+        {
+            removeChild(mHUDCamera);
+            setCullCallback(nullptr);
 
-        osg::GraphicsContext* gc = viewer->getCamera()->getGraphicsContext();
-        osg::GLExtensions* ext = gc->getState()->get<osg::GLExtensions>();
+            mViewer->getCamera()->setRenderTargetImplementation(osg::Camera::FRAME_BUFFER);
+            mViewer->getCamera()->getGraphicsContext()->setResizedCallback(nullptr);
+            mViewer->getCamera()->setUserData(nullptr);
 
-        constexpr char errPreamble[] = "Postprocessing and floating point depth buffers disabled: ";
+            mEnabled = false;
+        }
 
-        if (!ext->isFrameBufferObjectSupported)
+        mUsePostProcessing = false;
+        mRendering.getSkyManager()->setSunglare(true);
+    }
+
+    void PostProcessor::traverse(osg::NodeVisitor& nv)
+    {
+        if (!mEnabled)
         {
-            Log(Debug::Warning) << errPreamble << "FrameBufferObject unsupported.";
+            osg::Group::traverse(nv);
             return;
         }
 
-        if (Settings::Manager::getInt("antialiasing", "Video") > 1 && !ext->isRenderbufferMultisampleSupported())
+        size_t frameId = nv.getTraversalNumber() % 2;
+
+        if (nv.getVisitorType() == osg::NodeVisitor::CULL_VISITOR)
+            cull(frameId, static_cast<osgUtil::CullVisitor*>(&nv));
+        else if (nv.getVisitorType() == osg::NodeVisitor::UPDATE_VISITOR)
+            update(frameId);
+
+        osg::Group::traverse(nv);
+    }
+
+    void PostProcessor::cull(size_t frameId, osgUtil::CullVisitor* cv)
+    {
+        const auto& fbo = getFbo(FBO_Intercept, frameId);
+        if (fbo)
         {
-            Log(Debug::Warning) << errPreamble << "RenderBufferMultiSample unsupported. Disabling antialiasing will resolve this issue.";
-            return;
+            osgUtil::RenderStage* rs = cv->getRenderStage();
+            if (rs && rs->getMultisampleResolveFramebufferObject())
+                rs->setMultisampleResolveFramebufferObject(fbo);
+        }
+
+        mPingPongCanvas->setPostProcessing(frameId, mUsePostProcessing);
+        mPingPongCanvas->setNormalsTexture(frameId, mNormals ? getTexture(Tex_Normal, frameId) : nullptr);
+        mPingPongCanvas->setMask(frameId, mUnderwater, mExteriorFlag);
+        mPingPongCanvas->setHDR(frameId, getHDR());
+
+        if (Stereo::getStereo())
+        {
+            auto& sm = Stereo::Manager::instance();
+
+            int index = sm.getEye(cv) == Stereo::Eye::Left ? 0 : 1;
+
+            mPingPongCanvas->setSceneTexture(frameId, sm.multiviewFramebuffer()->layerColorBuffer(index));
+            mPingPongCanvas->setDepthTexture(frameId, sm.multiviewFramebuffer()->layerDepthBuffer(index));
         }
+        else if (Stereo::getMultiview())
+        {
+            auto& sm = Stereo::Manager::instance();
 
-        if (SceneUtil::AutoDepth::isReversed())
+            mPingPongCanvas->setSceneTexture(frameId, sm.multiviewFramebuffer()->multiviewColorBuffer());
+            mPingPongCanvas->setDepthTexture(frameId, sm.multiviewFramebuffer()->multiviewDepthBuffer());
+        }
+        else
         {
-            if(SceneUtil::AutoDepth::depthSourceType() != GL_FLOAT_32_UNSIGNED_INT_24_8_REV)
+            mPingPongCanvas->setSceneTexture(frameId, getTexture(Tex_Scene, frameId));
+            if (mDisableDepthPasses)
+                mPingPongCanvas->setDepthTexture(frameId, getTexture(Tex_Depth, frameId));
+            else
+                mPingPongCanvas->setDepthTexture(frameId, getTexture(Tex_OpaqueDepth, frameId));
+
+            mPingPongCanvas->setLDRSceneTexture(frameId, getTexture(Tex_Scene_LDR, frameId));
+
+            if (mTransparentDepthPostPass)
             {
-                // TODO: Once we have post-processing implemented we want to skip this return and continue with setup.
-                // Rendering to a FBO to fullscreen geometry has overhead (especially when MSAA is enabled) and there are no
-                // benefits if no floating point depth formats are supported.
-                if (!softParticles && !Stereo::getStereo())
-                    return;
+                mTransparentDepthPostPass->mFbo[frameId] = mFbos[frameId][FBO_Primary];
+                mTransparentDepthPostPass->mMsaaFbo[frameId] = mFbos[frameId][FBO_Multisample];
+                mTransparentDepthPostPass->mOpaqueFbo[frameId] = mFbos[frameId][FBO_OpaqueDepth];
             }
         }
 
-        auto* traits = gc->getTraits();
-        int width = traits->width;
-        int height = traits->height;
+        size_t frame = cv->getTraversalNumber();
+
+        mStateUpdater->setResolution(osg::Vec2f(cv->getViewport()->width(), cv->getViewport()->height()));
 
-        createTexturesAndCamera(width, height);
-        resize(width, height);
+        // per-frame data
+        if (frame != mLastFrameNumber)
+        {
+            mLastFrameNumber = frame;
+
+            auto stamp = cv->getFrameStamp();
+
+            mStateUpdater->setSimulationTime(static_cast<float>(stamp->getSimulationTime()));
+            mStateUpdater->setDeltaSimulationTime(static_cast<float>(stamp->getSimulationTime() - mLastSimulationTime));
+            mLastSimulationTime = stamp->getSimulationTime();
+
+            for (const auto& dispatchNode : mPingPongCanvas->getCurrentFrameData(frame))
+            {
+                for (auto& uniform : dispatchNode.mHandle->getUniformMap())
+                {
+                    if (uniform->getType().has_value() && !uniform->mSamplerType)
+                        if (auto* u = dispatchNode.mRootStateSet->getUniform(uniform->mName))
+                            uniform->setUniform(u);
+                }
+            }
+        }
+    }
 
-        mRootNode->addChild(mHUDCamera);
-        mRootNode->addChild(rootNode);
-        mViewer->setSceneData(mRootNode);
+    void PostProcessor::update(size_t frameId)
+    {
+        static const bool liveReload = Settings::Manager::getBool("live reload", "Post Processing");
 
-        if (!Stereo::getStereo())
+        if (liveReload)
         {
-            // We need to manually set the FBO and resolve FBO during the cull callback. If we were using a separate
-            // RTT camera this would not be needed.
-            mViewer->getCamera()->addCullCallback(new CullCallback(this));
-            mViewer->getCamera()->setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT);
-            mViewer->getCamera()->attach(osg::Camera::COLOR_BUFFER0, mSceneTex);
-        mViewer->getCamera()->attach(osg::Camera::PACKED_DEPTH_STENCIL_BUFFER, mDepthTex);
+            for (auto& technique : mTechniques)
+            {
+                if (technique->getStatus() == fx::Technique::Status::File_Not_exists)
+                    continue;
+
+                technique->setLastModificationTime(std::filesystem::last_write_time(mTechniqueFileMap[technique->getName()]));
+
+                if(technique->isValid() && !technique->isDirty())
+                    continue;
+
+                if (technique->isDirty())
+                {
+                    technique->compile();
+
+                    if (technique->isValid())
+                        Log(Debug::Info) << "Reloaded technique : " << mTechniqueFileMap[technique->getName()].string();
+
+                    if (!mReload)
+                        mReload = technique->isValid();
+                }
+            }
         }
 
-        mViewer->getCamera()->getGraphicsContext()->setResizedCallback(new ResizedCallback(this));
+        if (mReload)
+        {
+            mReload = false;
+
+            if (!mTechniques.empty())
+                reloadMainPass(*mTechniques[0]);
+
+            reloadTechniques();
+
+            if (!mUsePostProcessing)
+                resize();
+        }
+
+        if (mDirty && mDirtyFrameId == frameId)
+        {
+            createTexturesAndCamera(frameId);
+            createObjectsForFrame(frameId);
+            mDirty = false;
+        }
+
+        if ((mNormalsSupported && mNormals != mPrevNormals) || (mPassLights != mPrevPassLights))
+        {
+            mPrevNormals = mNormals;
+            mPrevPassLights = mPassLights;
+
+            mViewer->stopThreading();
+
+            auto& shaderManager = MWBase::Environment::get().getResourceSystem()->getSceneManager()->getShaderManager();
+            auto defines = shaderManager.getGlobalDefines();
+            defines["disableNormals"] = mNormals ? "0" : "1";
+            shaderManager.setGlobalDefines(defines);
+
+            mRendering.getLightRoot()->setCollectPPLights(mPassLights);
+            mStateUpdater->bindPointLights(mPassLights ? mRendering.getLightRoot()->getPPLightsBuffer() : nullptr);
+            mStateUpdater->reset();
+
+            mViewer->startThreading();
+
+            createTexturesAndCamera(frameId);
+            createObjectsForFrame(frameId);
+
+            mDirty = true;
+            mDirtyFrameId = !frameId;
+        }
     }
 
-    void PostProcessor::resize(int width, int height)
+    void PostProcessor::createObjectsForFrame(size_t frameId)
     {
-        mDepthTex->setTextureSize(width, height);
-        mSceneTex->setTextureSize(width, height);
-        mDepthTex->dirtyTextureObject();
-        mSceneTex->dirtyTextureObject();
+        if (Stereo::getStereo() || Stereo::getMultiview())
+            return;
 
-        if (mOpaqueDepthTex)
+        auto& fbos = mFbos[frameId];
+        auto& textures = mTextures[frameId];
+
+        for (auto& tex : textures)
         {
-            mOpaqueDepthTex->setTextureSize(width, height);
-            mOpaqueDepthTex->dirtyTextureObject();
+            if (!tex)
+                continue;
+
+            tex->setTextureSize(mWidth, mHeight);
+            tex->dirtyTextureObject();
         }
 
-        int samples = Settings::Manager::getInt("antialiasing", "Video");
+        fbos[FBO_Primary] = new osg::FrameBufferObject;
+        fbos[FBO_Primary]->setAttachment(osg::Camera::COLOR_BUFFER0, osg::FrameBufferAttachment(textures[Tex_Scene]));
+        if (mNormals && mNormalsSupported)
+            fbos[FBO_Primary]->setAttachment(osg::Camera::COLOR_BUFFER1, osg::FrameBufferAttachment(textures[Tex_Normal]));
+        fbos[FBO_Primary]->setAttachment(osg::Camera::PACKED_DEPTH_STENCIL_BUFFER, osg::FrameBufferAttachment(textures[Tex_Depth]));
 
-        mFbo = new osg::FrameBufferObject;
-        mFbo->setAttachment(osg::Camera::COLOR_BUFFER0, osg::FrameBufferAttachment(mSceneTex));
-        mFbo->setAttachment(osg::Camera::PACKED_DEPTH_STENCIL_BUFFER, osg::FrameBufferAttachment(mDepthTex));
+        fbos[FBO_FirstPerson] = new osg::FrameBufferObject;
+        osg::ref_ptr<osg::RenderBuffer> fpDepthRb = new osg::RenderBuffer(mWidth, mHeight, textures[Tex_Depth]->getInternalFormat(), mSamples > 1 ? mSamples : 0);
+        fbos[FBO_FirstPerson]->setAttachment(osg::FrameBufferObject::BufferComponent::PACKED_DEPTH_STENCIL_BUFFER, osg::FrameBufferAttachment(fpDepthRb));
 
         // When MSAA is enabled we must first render to a render buffer, then
         // blit the result to the FBO which is either passed to the main frame
         // buffer for display or used as the entry point for a post process chain.
-        if (samples > 1)
+        if (mSamples > 1)
         {
-            mMsaaFbo = new osg::FrameBufferObject;
-            osg::ref_ptr<osg::RenderBuffer> colorRB = new osg::RenderBuffer(width, height, mSceneTex->getInternalFormat(), samples);
-            osg::ref_ptr<osg::RenderBuffer> depthRB = new osg::RenderBuffer(width, height, mDepthTex->getInternalFormat(), samples);
-            mMsaaFbo->setAttachment(osg::Camera::COLOR_BUFFER0, osg::FrameBufferAttachment(colorRB));
-            mMsaaFbo->setAttachment(osg::Camera::PACKED_DEPTH_STENCIL_BUFFER, osg::FrameBufferAttachment(depthRB));
+            fbos[FBO_Multisample] = new osg::FrameBufferObject;
+            osg::ref_ptr<osg::RenderBuffer> colorRB = new osg::RenderBuffer(mWidth, mHeight, textures[Tex_Scene]->getInternalFormat(), mSamples);
+            if (mNormals && mNormalsSupported)
+            {
+                osg::ref_ptr<osg::RenderBuffer> normalRB = new osg::RenderBuffer(mWidth, mHeight, textures[Tex_Normal]->getInternalFormat(), mSamples);
+                fbos[FBO_Multisample]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER1, osg::FrameBufferAttachment(normalRB));
+                fbos[FBO_FirstPerson]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER1, osg::FrameBufferAttachment(normalRB));
+            }
+            osg::ref_ptr<osg::RenderBuffer> depthRB = new osg::RenderBuffer(mWidth, mHeight, textures[Tex_Depth]->getInternalFormat(), mSamples);
+            fbos[FBO_Multisample]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0, osg::FrameBufferAttachment(colorRB));
+            fbos[FBO_Multisample]->setAttachment(osg::FrameBufferObject::BufferComponent::PACKED_DEPTH_STENCIL_BUFFER, osg::FrameBufferAttachment(depthRB));
+            fbos[FBO_FirstPerson]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0, osg::FrameBufferAttachment(colorRB));
+
+            fbos[FBO_Intercept] = new osg::FrameBufferObject;
+            fbos[FBO_Intercept]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0, osg::FrameBufferAttachment(textures[Tex_Scene]));
+            fbos[FBO_Intercept]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER1, osg::FrameBufferAttachment(textures[Tex_Normal]));
+        }
+        else
+        {
+            fbos[FBO_FirstPerson]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0, osg::FrameBufferAttachment(textures[Tex_Scene]));
+            if (mNormals && mNormalsSupported)
+                fbos[FBO_FirstPerson]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER1, osg::FrameBufferAttachment(textures[Tex_Normal]));
         }
 
-        if (const auto depthProxy = std::getenv("OPENMW_ENABLE_DEPTH_CLEAR_PROXY"))
-            mFirstPersonDepthRBProxy = new osg::RenderBuffer(width, height, mDepthTex->getInternalFormat(), samples);
-
-        if (Settings::Manager::getBool("soft particles", "Shaders"))
-            osgUtil::RenderBin::getRenderBinPrototype("DepthSortedBin")->setDrawCallback(new OpaqueDepthCopyCallback(mOpaqueDepthTex, mMsaaFbo ? mMsaaFbo : mFbo));
-
-        mViewer->getCamera()->resize(width, height);
-        mHUDCamera->resize(width, height);
+        if (textures[Tex_OpaqueDepth])
+        {
+            fbos[FBO_OpaqueDepth] = new osg::FrameBufferObject;
+            fbos[FBO_OpaqueDepth]->setAttachment(osg::FrameBufferObject::BufferComponent::PACKED_DEPTH_STENCIL_BUFFER, osg::FrameBufferAttachment(textures[Tex_OpaqueDepth]));
+        }
 
-        if (Stereo::getStereo())
-            Stereo::Manager::instance().screenResolutionChanged();
+#ifdef __APPLE__
+        if (textures[Tex_OpaqueDepth])
+            fbos[FBO_OpaqueDepth]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER, osg::FrameBufferAttachment(new osg::RenderBuffer(textures[Tex_OpaqueDepth]->getTextureWidth(), textures[Tex_OpaqueDepth]->getTextureHeight(), textures[Tex_Scene]->getInternalFormat())));
+#endif
     }
 
-    class HUDCameraStatesetUpdater final : public SceneUtil::StateSetUpdater
+    void PostProcessor::dirtyTechniques()
     {
-    public:
-    public:
-        HUDCameraStatesetUpdater(osg::ref_ptr<osg::Camera> HUDCamera, osg::ref_ptr<osg::Program> program, osg::ref_ptr<osg::Texture2D> sceneTex)
-            : mHUDCamera(HUDCamera)
-            , mProgram(program)
-            , mSceneTex(sceneTex)
-        {
-        }
+        if (!isEnabled())
+            return;
+
+        fx::DispatchArray data;
+
+        bool sunglare = true;
+        mHDR = false;
+        mNormals = false;
+        mPassLights = false;
 
-        void setDefaults(osg::StateSet* stateset) override
+        for (const auto& technique : mTechniques)
         {
-            stateset->setTextureAttributeAndModes(0, mSceneTex, osg::StateAttribute::ON);
-            stateset->setAttributeAndModes(mProgram, osg::StateAttribute::ON);
-            stateset->addUniform(new osg::Uniform("sceneTex", 0));
-            stateset->setMode(GL_LIGHTING, osg::StateAttribute::OFF);
-            stateset->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
+            if (!technique->isValid())
+                continue;
 
-            if (osg::DisplaySettings::instance()->getStereo())
+            if (technique->getGLSLVersion() > mGLSLVersion)
             {
-                stateset->setAttribute(new osg::Viewport);
-                stateset->addUniform(new osg::Uniform("viewportIndex", 0));
+                Log(Debug::Warning) << "Technique " << technique->getName() << " requires GLSL version " << technique->getGLSLVersion() << " which is unsupported by your hardware.";
+                continue;
             }
+
+            fx::DispatchNode node;
+
+            node.mFlags = technique->getFlags();
+
+            if (technique->getHDR())
+                mHDR = true;
+
+            if (technique->getNormals())
+                mNormals = true;
+
+            if (technique->getLights())
+                mPassLights = true;
+
+            if (node.mFlags & fx::Technique::Flag_Disable_SunGlare)
+                sunglare = false;
+
+            // required default samplers available to every shader pass
+            node.mRootStateSet->addUniform(new osg::Uniform("omw_SamplerLastShader", Unit_LastShader));
+            node.mRootStateSet->addUniform(new osg::Uniform("omw_SamplerLastPass", Unit_LastPass));
+            node.mRootStateSet->addUniform(new osg::Uniform("omw_SamplerDepth", Unit_Depth));
+
+            if (mNormals)
+                node.mRootStateSet->addUniform(new osg::Uniform("omw_SamplerNormals", Unit_Normals));
+
+            if (technique->getHDR())
+                node.mRootStateSet->addUniform(new osg::Uniform("omw_EyeAdaptation", Unit_EyeAdaptation));
+
+            int texUnit = Unit_NextFree;
+
+            // user-defined samplers
+            for (const osg::Texture* texture : technique->getTextures())
+            {
+                if (const auto* tex1D = dynamic_cast<const osg::Texture1D*>(texture))
+                    node.mRootStateSet->setTextureAttribute(texUnit, new osg::Texture1D(*tex1D));
+                else if (const auto* tex2D = dynamic_cast<const osg::Texture2D*>(texture))
+                    node.mRootStateSet->setTextureAttribute(texUnit, new osg::Texture2D(*tex2D));
+                else if (const auto* tex3D = dynamic_cast<const osg::Texture3D*>(texture))
+                    node.mRootStateSet->setTextureAttribute(texUnit, new osg::Texture3D(*tex3D));
+
+                node.mRootStateSet->addUniform(new osg::Uniform(texture->getName().c_str(), texUnit++));
+            }
+
+            // user-defined uniforms
+            for (auto& uniform : technique->getUniformMap())
+            {
+                if (uniform->mSamplerType) continue;
+
+                if (auto type = uniform->getType())
+                    uniform->setUniform(node.mRootStateSet->getOrCreateUniform(uniform->mName, type.value()));
+            }
+
+            int subTexUnit = texUnit;
+
+            for (const auto& pass : technique->getPasses())
+            {
+                fx::DispatchNode::SubPass subPass;
+
+                pass->prepareStateSet(subPass.mStateSet, technique->getName());
+
+                node.mHandle = technique;
+
+                if (!pass->getTarget().empty())
+                {
+                    const auto& rt = technique->getRenderTargetsMap()[pass->getTarget()];
+
+                    const auto [w, h] = rt.mSize.get(mWidth, mHeight);
+
+                    subPass.mRenderTexture = new osg::Texture2D(*rt.mTarget);
+                    subPass.mRenderTexture->setTextureSize(w, h);
+                    subPass.mRenderTexture->setName(std::string(pass->getTarget()));
+
+                    if (rt.mMipMap)
+                        subPass.mRenderTexture->setNumMipmapLevels(osg::Image::computeNumberOfMipmapLevels(w, h));
+
+                    subPass.mRenderTarget = new osg::FrameBufferObject;
+                    subPass.mRenderTarget->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0, osg::FrameBufferAttachment(subPass.mRenderTexture));
+                    subPass.mStateSet->setAttributeAndModes(new osg::Viewport(0, 0, w, h));
+
+                    node.mRootStateSet->setTextureAttributeAndModes(subTexUnit, subPass.mRenderTexture);
+                    node.mRootStateSet->addUniform(new osg::Uniform(subPass.mRenderTexture->getName().c_str(), subTexUnit++));
+                }
+                node.mPasses.emplace_back(std::move(subPass));
+            }
+
+            data.emplace_back(std::move(node));
         }
 
-        void apply(osg::StateSet* stateset, osg::NodeVisitor* nv) override
+        size_t frameId = frame() % 2;
+
+        mPingPongCanvas->setCurrentFrameData(frameId, std::move(data));
+
+        if (auto hud = MWBase::Environment::get().getWindowManager()->getPostProcessorHud())
+            hud->updateTechniques();
+
+        mRendering.getSkyManager()->setSunglare(sunglare);
+    }
+
+    bool PostProcessor::enableTechnique(std::shared_ptr<fx::Technique> technique, std::optional<int> location)
+    {
+        if (!technique || technique->getName() == "main" || (location.has_value() && location.value() <= 0))
+            return false;
+
+        disableTechnique(technique, false);
+
+        int pos = std::min<int>(location.value_or(mTechniques.size()), mTechniques.size());
+
+        mTechniques.insert(mTechniques.begin() + pos, technique);
+        dirtyTechniques();
+
+        return true;
+    }
+
+    bool PostProcessor::disableTechnique(std::shared_ptr<fx::Technique> technique, bool dirty)
+    {
+        for (size_t i = 1; i < mTechniques.size(); ++i)
         {
-            if (Stereo::getMultiview())
+            if (technique.get() == mTechniques[i].get())
             {
-                auto& multiviewFbo = Stereo::Manager::instance().multiviewFramebuffer();
-                stateset->setTextureAttributeAndModes(0, multiviewFbo->multiviewColorBuffer(), osg::StateAttribute::ON);
+                mTechniques.erase(mTechniques.begin() + i);
+                if (dirty)
+                    dirtyTechniques();
+                return true;
             }
         }
 
-        void applyLeft(osg::StateSet* stateset, osgUtil::CullVisitor* cv) override
+        return false;
+    }
+
+    bool PostProcessor::isTechniqueEnabled(const std::shared_ptr<fx::Technique>& technique) const
+    {
+        for (const auto& t : mTechniques)
+        {
+            if (technique.get() == t.get())
+                return technique->isValid();
+        }
+
+        return false;
+    }
+
+    void PostProcessor::createTexturesAndCamera(size_t frameId)
+    {
+        auto& textures = mTextures[frameId];
+
+        for (auto& texture : textures)
         {
-            auto& multiviewFbo = Stereo::Manager::instance().multiviewFramebuffer();
-            stateset->setTextureAttributeAndModes(0, multiviewFbo->layerColorBuffer(0), osg::StateAttribute::ON);
-
-            auto viewport = static_cast<osg::Viewport*>(stateset->getAttribute(osg::StateAttribute::VIEWPORT));
-            auto fullViewport = mHUDCamera->getViewport();
-            viewport->setViewport(
-                0,
-                0,
-                fullViewport->width() / 2,
-                fullViewport->height()
-            );
+            if (!texture)
+                texture = new osg::Texture2D;
+            texture->setTextureSize(mWidth, mHeight);
+            texture->setSourceFormat(GL_RGBA);
+            texture->setSourceType(GL_UNSIGNED_BYTE);
+            texture->setInternalFormat(GL_RGBA);
+            texture->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture::LINEAR);
+            texture->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture::LINEAR);
+            texture->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP_TO_EDGE);
+            texture->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_EDGE);
+            texture->setResizeNonPowerOfTwoHint(false);
         }
 
-        void applyRight(osg::StateSet* stateset, osgUtil::CullVisitor* cv) override
+        textures[Tex_Normal]->setSourceFormat(GL_RGB);
+        textures[Tex_Normal]->setInternalFormat(GL_RGB);
+
+        if (mMainTemplate)
         {
-            auto& multiviewFbo = Stereo::Manager::instance().multiviewFramebuffer();
-            stateset->setTextureAttributeAndModes(0, multiviewFbo->layerColorBuffer(1), osg::StateAttribute::ON);
-
-            auto viewport = static_cast<osg::Viewport*>(stateset->getAttribute(osg::StateAttribute::VIEWPORT));
-            auto fullViewport = mHUDCamera->getViewport();
-            viewport->setViewport(
-                fullViewport->width() / 2,
-                0,
-                fullViewport->width() / 2,
-                fullViewport->height()
-            );
+            textures[Tex_Scene]->setSourceFormat(mMainTemplate->getSourceFormat());
+            textures[Tex_Scene]->setSourceType(mMainTemplate->getSourceType());
+            textures[Tex_Scene]->setInternalFormat(mMainTemplate->getInternalFormat());
+            textures[Tex_Scene]->setFilter(osg::Texture2D::MIN_FILTER, mMainTemplate->getFilter(osg::Texture2D::MIN_FILTER));
+            textures[Tex_Scene]->setFilter(osg::Texture2D::MAG_FILTER, mMainTemplate->getFilter(osg::Texture2D::MAG_FILTER));
+            textures[Tex_Scene]->setWrap(osg::Texture::WRAP_S, mMainTemplate->getWrap(osg::Texture2D::WRAP_S));
+            textures[Tex_Scene]->setWrap(osg::Texture::WRAP_T, mMainTemplate->getWrap(osg::Texture2D::WRAP_T));
         }
 
-    private:
-        osg::ref_ptr<osg::Camera> mHUDCamera;
-        osg::ref_ptr<osg::Program> mProgram;
-        osg::ref_ptr<osg::Texture2D> mSceneTex;
-    };
+        auto setupDepth = [] (osg::Texture2D* tex) {
+            tex->setSourceFormat(GL_DEPTH_STENCIL_EXT);
+            tex->setSourceType(SceneUtil::AutoDepth::depthSourceType());
+            tex->setInternalFormat(SceneUtil::AutoDepth::depthInternalFormat());
+        };
 
-    void PostProcessor::createTexturesAndCamera(int width, int height)
-    {
-        mDepthTex = new osg::Texture2D;
-        mDepthTex->setTextureSize(width, height);
-        mDepthTex->setSourceFormat(SceneUtil::AutoDepth::depthSourceFormat());
-        mDepthTex->setSourceType(SceneUtil::AutoDepth::depthSourceType());
-        mDepthTex->setInternalFormat(SceneUtil::AutoDepth::depthInternalFormat());
-        mDepthTex->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::NEAREST);
-        mDepthTex->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::NEAREST);
-        mDepthTex->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP_TO_EDGE);
-        mDepthTex->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_EDGE);
-        mDepthTex->setResizeNonPowerOfTwoHint(false);
-
-        if (Settings::Manager::getBool("soft particles", "Shaders"))
+        setupDepth(textures[Tex_Depth]);
+
+        if (mDisableDepthPasses)
         {
-            mOpaqueDepthTex = new osg::Texture2D(*mDepthTex);
-            mOpaqueDepthTex->setName("opaqueTexMap");
+            textures[Tex_OpaqueDepth] = nullptr;
+        }
+        else
+        {
+            setupDepth(textures[Tex_OpaqueDepth]);
+            textures[Tex_OpaqueDepth]->setName("opaqueTexMap");
         }
 
-        mSceneTex = new osg::Texture2D;
-        mSceneTex->setTextureSize(width, height);
-        mSceneTex->setSourceFormat(SceneUtil::Color::colorSourceFormat());
-        mSceneTex->setSourceType(SceneUtil::Color::colorSourceType());
-        mSceneTex->setInternalFormat(SceneUtil::Color::colorInternalFormat());
-        mSceneTex->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::NEAREST);
-        mSceneTex->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::NEAREST);
-        mSceneTex->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP_TO_EDGE);
-        mSceneTex->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_EDGE);
-        mSceneTex->setResizeNonPowerOfTwoHint(false);
+        if (mHUDCamera)
+            return;
 
         mHUDCamera = new osg::Camera;
         mHUDCamera->setReferenceFrame(osg::Camera::ABSOLUTE_RF);
@@ -358,64 +723,106 @@ namespace MWRender
         mHUDCamera->setClearMask(0);
         mHUDCamera->setProjectionMatrix(osg::Matrix::ortho2D(0, 1, 0, 1));
         mHUDCamera->setAllowEventFocus(false);
-        mHUDCamera->setViewport(0, 0, width, height);
+        mHUDCamera->setViewport(0, 0, mWidth, mHeight);
 
-        // Shaders calculate correct UV coordinates for our fullscreen triangle
-        constexpr char vertSrc[] = R"GLSL(
-            #version 120
+        mViewer->getCamera()->removeCullCallback(mPingPongCull);
+        mPingPongCull = new PingPongCull;
+        mViewer->getCamera()->addCullCallback(mPingPongCull);
 
-            varying vec2 uv;
+        mPingPongCanvas = new PingPongCanvas(mRendering.getResourceSystem()->getSceneManager()->getShaderManager());
 
-            void main()
-            {
-                gl_Position = vec4(gl_Vertex.xy, 0.0, 1.0);
-                uv = gl_Position.xy * 0.5 + 0.5;
-            }
-        )GLSL";
+        mHUDCamera->addChild(mPingPongCanvas);
+        mHUDCamera->setNodeMask(Mask_RenderToTexture);
 
-        constexpr char fragSrc[] = R"GLSL(
-            #version 120
+        mHUDCamera->getOrCreateStateSet()->setMode(GL_LIGHTING, osg::StateAttribute::OFF);
+        mHUDCamera->getOrCreateStateSet()->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
+    }
 
-            varying vec2 uv;
-            uniform sampler2D sceneTex;
+    std::shared_ptr<fx::Technique> PostProcessor::loadTechnique(const std::string& name, bool insert)
+    {
+        if (!isEnabled())
+            return nullptr;
 
-            void main()
-            {
-                gl_FragData[0] = texture2D(sceneTex, uv);
-            }
-        )GLSL";
+        for (size_t i = 0; i < mTemplates.size(); ++i)
+            if (name == mTemplates[i]->getName())
+                return mTemplates[i];
+
+        auto technique = std::make_shared<fx::Technique>(*mVFS, *mRendering.getResourceSystem()->getImageManager(), name, mWidth, mHeight, mUBO, mNormalsSupported);
+
+        technique->compile();
+
+        if (technique->getStatus() != fx::Technique::Status::File_Not_exists)
+            technique->setLastModificationTime(std::filesystem::last_write_time(mTechniqueFileMap[technique->getName()]), false);
+
+        if (!insert)
+            return technique;
+
+        reloadMainPass(*technique);
+
+        mTemplates.push_back(std::move(technique));
+
+        return mTemplates.back();
+    }
+
+    void PostProcessor::addTemplate(std::shared_ptr<fx::Technique> technique)
+    {
+        if (!isEnabled())
+            return;
+
+        for (size_t i = 0; i < mTemplates.size(); ++i)
+            if (technique.get() == mTemplates[i].get())
+                return;
+
+        mTemplates.push_back(technique);
+    }
+
+    void PostProcessor::reloadTechniques()
+    {
+        if (!isEnabled())
+            return;
+
+        mTechniques.clear();
 
-        constexpr char fragSrcMultiview[] = R"GLSL(
-            #version 330 compatibility
+        std::vector<std::string> techniqueStrings;
+        Misc::StringUtils::split(Settings::Manager::getString("chain", "Post Processing"), techniqueStrings, ",");
 
-            #extension GL_EXT_texture_array : require
+        techniqueStrings.insert(techniqueStrings.begin(), "main");
+
+        for (auto& techniqueName : techniqueStrings)
+        {
+            Misc::StringUtils::trim(techniqueName);
 
-            varying vec2 uv;
-            uniform sampler2DArray sceneTex;
+            if (techniqueName.empty())
+                continue;
 
-            void main()
+            if ((&techniqueName != &techniqueStrings.front()) && Misc::StringUtils::ciEqual(techniqueName, "main"))
             {
-                vec3 array_uv = vec3(uv.x * 2, uv.y, 0);
-                if(array_uv.x >= 1.0)
-                {
-                    array_uv.x -= 1.0;
-                    array_uv.z = 1;
-                }
-                gl_FragData[0] = texture2DArray(sceneTex, array_uv);
+                Log(Debug::Warning) << "main.omwfx techniqued specified in chain, this is not allowed. technique file will be ignored if it exists.";
+                continue;
             }
-        )GLSL";
 
-        osg::ref_ptr<osg::Shader> vertShader = new osg::Shader(osg::Shader::VERTEX, vertSrc);
-        osg::ref_ptr<osg::Shader> fragShader = new osg::Shader(osg::Shader::FRAGMENT, Stereo::getMultiview() ? fragSrcMultiview : fragSrc);
+            mTechniques.push_back(loadTechnique(techniqueName));
+        }
 
-        osg::ref_ptr<osg::Program> program = new osg::Program;
-        program->addShader(vertShader);
-        program->addShader(fragShader);
+        dirtyTechniques();
+    }
 
-        mHUDCamera->addChild(createFullScreenTri());
-        mHUDCamera->setNodeMask(Mask_RenderToTexture);
-        mHUDCamera->setCullCallback(new HUDCameraStatesetUpdater(mHUDCamera, program, mSceneTex));
+    void PostProcessor::reloadMainPass(fx::Technique& technique)
+    {
+        if (!technique.getMainTemplate())
+            return;
+
+        mMainTemplate = technique.getMainTemplate();
+
+        resize();
     }
 
+    void PostProcessor::toggleMode()
+    {
+        for (auto& technique : mTemplates)
+            technique->compile();
+
+        dirtyTechniques();
+    }
 }
 
diff --git a/apps/openmw/mwrender/postprocessor.hpp b/apps/openmw/mwrender/postprocessor.hpp
index b1217b011b9e9262664377f2dd52f49b9ed36df8..f81615c90b3b6022961244559842863611ac7e35 100644
--- a/apps/openmw/mwrender/postprocessor.hpp
+++ b/apps/openmw/mwrender/postprocessor.hpp
@@ -1,11 +1,26 @@
 #ifndef OPENMW_MWRENDER_POSTPROCESSOR_H
 #define OPENMW_MWRENDER_POSTPROCESSOR_H
 
+#include <array>
+#include <vector>
+#include <string>
+#include <unordered_map>
+
+#include <filesystem>
+
 #include <osg/Texture2D>
 #include <osg/Group>
 #include <osg/FrameBufferObject>
 #include <osg/Camera>
-#include <osg/ref_ptr>
+
+#include <osgViewer/Viewer>
+
+#include <components/fx/stateupdater.hpp>
+#include <components/fx/technique.hpp>
+#include <components/debug/debuglog.hpp>
+
+#include "pingpongcanvas.hpp"
+#include "transparentpass.hpp"
 
 #include <memory>
 
@@ -19,38 +34,199 @@ namespace Stereo
     class MultiviewFramebuffer;
 }
 
+namespace VFS
+{
+    class Manager;
+}
+
+namespace Shader
+{
+    class ShaderManager;
+}
+
 namespace MWRender
 {
-    class PostProcessor : public osg::Referenced
+    class RenderingManager;
+    class PingPongCull;
+    class PingPongCanvas;
+    class TransparentDepthBinCallback;
+
+    class PostProcessor : public osg::Group
     {
     public:
-        PostProcessor(osgViewer::Viewer* viewer, osg::Group* rootNode);
+        using FBOArray = std::array<osg::ref_ptr<osg::FrameBufferObject>, 5>;
+        using TextureArray = std::array<osg::ref_ptr<osg::Texture2D>, 5>;
+        using TechniqueList = std::vector<std::shared_ptr<fx::Technique>>;
+
+        enum TextureIndex
+        {
+            Tex_Scene,
+            Tex_Scene_LDR,
+            Tex_Depth,
+            Tex_OpaqueDepth,
+            Tex_Normal
+        };
+
+        enum FBOIndex
+        {
+            FBO_Primary,
+            FBO_Multisample,
+            FBO_FirstPerson,
+            FBO_OpaqueDepth,
+            FBO_Intercept
+        };
+
+        enum TextureUnits
+        {
+            Unit_LastShader = 0,
+            Unit_LastPass,
+            Unit_Depth,
+            Unit_EyeAdaptation,
+            Unit_Normals,
+            Unit_NextFree
+        };
+
+        PostProcessor(RenderingManager& rendering, osgViewer::Viewer* viewer, osg::Group* rootNode, const VFS::Manager* vfs);
+
+        ~PostProcessor();
+
+        void traverse(osg::NodeVisitor& nv) override;
+
+        osg::ref_ptr<osg::FrameBufferObject> getFbo(FBOIndex index, unsigned int frameId) { return mFbos[frameId][index]; }
+
+        osg::ref_ptr<osg::Texture2D> getTexture(TextureIndex index, unsigned int frameId) { return mTextures[frameId][index]; }
+
+        osg::ref_ptr<osg::FrameBufferObject> getPrimaryFbo(unsigned int frameId) { return mFbos[frameId][FBO_Multisample] ? mFbos[frameId][FBO_Multisample] : mFbos[frameId][FBO_Primary]; }
+
+        osg::ref_ptr<fx::StateUpdater> getStateUpdater() { return mStateUpdater; }
+
+        const TechniqueList& getTechniques() { return mTechniques; }
+
+        const TechniqueList& getTemplates() const { return mTemplates; }
+
+        osg::ref_ptr<PingPongCanvas> getCanvas() { return mPingPongCanvas; }
+
+        const auto& getTechniqueMap() const { return mTechniqueFileMap; }
+
+        void resize();
+
+        bool enableTechnique(std::shared_ptr<fx::Technique> technique, std::optional<int> location = std::nullopt);
+
+        bool disableTechnique(std::shared_ptr<fx::Technique> technique, bool dirty = true);
+
+        bool getSupportsNormalsRT() const { return mNormalsSupported; }
+
+        template <class T>
+        void setUniform(std::shared_ptr<fx::Technique> technique, const std::string& name, const T& value)
+        {
+            if (!isEnabled())
+                return;
+
+            auto it = technique->findUniform(name);
 
-        auto getMsaaFbo() { return mMsaaFbo; }
-        auto getFbo() { return mFbo; }
-        auto getFirstPersonRBProxy() { return mFirstPersonDepthRBProxy; }
+            if (it == technique->getUniformMap().end())
+                return;
 
-        osg::ref_ptr<osg::Texture2D> getOpaqueDepthTex() { return mOpaqueDepthTex; }
+            if ((*it)->mStatic)
+            {
+                Log(Debug::Warning) << "Attempting to set a configration variable [" << name << "] as a uniform";
+                return;
+            }
 
-        void resize(int width, int height);
+            (*it)->setValue(value);
+        }
+
+        bool isTechniqueEnabled(const std::shared_ptr<fx::Technique>& technique) const;
+
+        void setExteriorFlag(bool exterior) { mExteriorFlag = exterior; }
+
+        void setUnderwaterFlag(bool underwater) { mUnderwater = underwater; }
+
+        void toggleMode();
+
+        std::shared_ptr<fx::Technique> loadTechnique(const std::string& name, bool insert=true);
+
+        void addTemplate(std::shared_ptr<fx::Technique> technique);
+
+        bool isEnabled() const { return mUsePostProcessing && mEnabled; }
+
+        bool softParticlesEnabled() const {return mSoftParticles; }
+
+        bool getHDR() const { return mHDR; }
+
+        void disable();
+
+        void enable(bool usePostProcessing = true);
+
+        void setRenderTargetSize(int width, int height) { mWidth = width; mHeight = height; }
 
     private:
-        void createTexturesAndCamera(int width, int height);
+        size_t frame() const { return mViewer->getFrameStamp()->getFrameNumber(); }
+
+        void createObjectsForFrame(size_t frameId);
+
+        void createTexturesAndCamera(size_t frameId);
+
+        void reloadTechniques();
+
+        void reloadMainPass(fx::Technique& technique);
+
+        void dirtyTechniques();
+
+        void update(size_t frameId);
+
+        void cull(size_t frameId, osgUtil::CullVisitor* cv);
 
-        osgViewer::Viewer* mViewer;
         osg::ref_ptr<osg::Group> mRootNode;
         osg::ref_ptr<osg::Camera> mHUDCamera;
 
-        std::shared_ptr<Stereo::MultiviewFramebuffer> mMultiviewFbo;
-        osg::ref_ptr<osg::FrameBufferObject> mMsaaFbo;
-        osg::ref_ptr<osg::FrameBufferObject> mFbo;
-        osg::ref_ptr<osg::RenderBuffer> mFirstPersonDepthRBProxy;
+        std::array<TextureArray, 2> mTextures;
+        std::array<FBOArray, 2> mFbos;
+
+        TechniqueList mTechniques;
+        TechniqueList mTemplates;
+
+        std::unordered_map<std::string, std::filesystem::path> mTechniqueFileMap;
+
+        int mSamples;
+
+        bool mDirty;
+        size_t mDirtyFrameId;
 
-        osg::ref_ptr<osg::Texture2D> mSceneTex;
-        osg::ref_ptr<osg::Texture2D> mDepthTex;
-        osg::ref_ptr<osg::Texture2D> mOpaqueDepthTex;
+        RenderingManager& mRendering;
+        osgViewer::Viewer* mViewer;
+        const VFS::Manager* mVFS;
+
+        bool mReload;
+        bool mEnabled;
+        bool mUsePostProcessing;
+        bool mSoftParticles;
+        bool mDisableDepthPasses;
+
+        size_t mLastFrameNumber;
+        float mLastSimulationTime;
+
+        bool mExteriorFlag;
+        bool mUnderwater;
+        bool mHDR;
+        bool mNormals;
+        bool mPrevNormals;
+        bool mNormalsSupported;
+        bool mPassLights;
+        bool mPrevPassLights;
+        bool mUBO;
+        int mGLSLVersion;
+
+        osg::ref_ptr<osg::Texture2D> mMainTemplate;
+
+        osg::ref_ptr<fx::StateUpdater> mStateUpdater;
+        osg::ref_ptr<PingPongCull> mPingPongCull;
+        osg::ref_ptr<PingPongCanvas> mPingPongCanvas;
+        osg::ref_ptr<TransparentDepthBinCallback> mTransparentDepthPostPass;
+    
+        int mWidth;
+        int mHeight;
     };
 }
 
 #endif
-
diff --git a/apps/openmw/mwrender/renderingmanager.cpp b/apps/openmw/mwrender/renderingmanager.cpp
index 24e37a93eaf9eb7674f5714ee87e51b9a0b4153c..3c032e2fd6a48d1618f7969ac9fa648d1c17d987 100644
--- a/apps/openmw/mwrender/renderingmanager.cpp
+++ b/apps/openmw/mwrender/renderingmanager.cpp
@@ -42,6 +42,8 @@
 #include <components/sceneutil/writescene.hpp>
 #include <components/sceneutil/shadow.hpp>
 
+#include <components/misc/constants.hpp>
+
 #include <components/terrain/terraingrid.hpp>
 #include <components/terrain/quadtreeworld.hpp>
 
@@ -54,7 +56,9 @@
 #include "../mwworld/class.hpp"
 #include "../mwworld/groundcoverstore.hpp"
 #include "../mwgui/loadingscreen.hpp"
+#include "../mwgui/postprocessorhud.hpp"
 #include "../mwmechanics/actorutil.hpp"
+#include "../mwbase/windowmanager.hpp"
 
 #include "sky.hpp"
 #include "effectmanager.hpp"
@@ -114,7 +118,7 @@ namespace MWRender
             mProjectionMatrix = projectionMatrix;
         }
 
-        const osg::Matrixf& projectionMatrix() const
+        const osg::Matrixf& getProjectionMatrix() const
         {
             return mProjectionMatrix;
         }
@@ -208,7 +212,6 @@ namespace MWRender
             mPlayerPos = playerPos;
         }
 
-
     private:
         float mLinearFac;
         float mNear;
@@ -411,9 +414,11 @@ namespace MWRender
         globalDefines["clamp"] = Settings::Manager::getBool("clamp lighting", "Shaders") ? "1" : "0";
         globalDefines["preLightEnv"] = Settings::Manager::getBool("apply lighting to environment maps", "Shaders") ? "1" : "0";
         globalDefines["radialFog"] = Settings::Manager::getBool("radial fog", "Shaders") ? "1" : "0";
+        globalDefines["refraction_enabled"] = "0";
         globalDefines["useGPUShader4"] = "0";
         globalDefines["useOVR_multiview"] = "0";
         globalDefines["numViews"] = "1";
+        globalDefines["disableNormals"] = "1";
 
         for (auto itr = lightDefines.begin(); itr != lightDefines.end(); itr++)
             globalDefines[itr->first] = itr->second;
@@ -502,12 +507,9 @@ namespace MWRender
         mPerViewUniformStateUpdater = new PerViewUniformStateUpdater();
         rootNode->addCullCallback(mPerViewUniformStateUpdater);
 
-        mPostProcessor = new PostProcessor(viewer, mRootNode);
-        resourceSystem->getSceneManager()->setDepthFormat(SceneUtil::AutoDepth::depthInternalFormat());
-        resourceSystem->getSceneManager()->setOpaqueDepthTex(mPostProcessor->getOpaqueDepthTex());
-
-        if (reverseZ && !SceneUtil::isFloatingPointDepthFormat(SceneUtil::AutoDepth::depthInternalFormat()))
-            Log(Debug::Warning) << "Floating point depth format not in use but reverse-z buffer is enabled, consider disabling it.";
+        mPostProcessor = new PostProcessor(*this, viewer, mRootNode, resourceSystem->getVFS());
+        resourceSystem->getSceneManager()->setOpaqueDepthTex(mPostProcessor->getTexture(PostProcessor::Tex_OpaqueDepth, 0), mPostProcessor->getTexture(PostProcessor::Tex_OpaqueDepth, 1));
+        resourceSystem->getSceneManager()->setSupportsNormalsRT(mPostProcessor->getSupportsNormalsRT());
 
         // water goes after terrain for correct waterculling order
         mWater.reset(new Water(sceneRoot->getParent(0), sceneRoot, mResourceSystem, mViewer->getIncrementalCompileOperation(), resourcePath));
@@ -558,10 +560,9 @@ namespace MWRender
             cullingMode |= osg::CullStack::SMALL_FEATURE_CULLING;
         }
 
-        mViewer->getCamera()->setCullingMode( cullingMode );
-
         mViewer->getCamera()->setComputeNearFarMode(osg::Camera::DO_NOT_COMPUTE_NEAR_FAR);
         mViewer->getCamera()->setCullingMode(cullingMode);
+        mViewer->getCamera()->setName(Constants::SceneCamera);
 
         auto mask = ~(Mask_UpdateVisitor | Mask_SimpleWater);
         MWBase::Environment::get().getWindowManager()->setCullMask(mask);
@@ -650,7 +651,7 @@ namespace MWRender
         return mViewer->getFrameStamp()->getReferenceTime();
     }
 
-    osg::Group* RenderingManager::getLightRoot()
+    SceneUtil::LightManager* RenderingManager::getLightRoot()
     {
         return mSceneRoot.get();
     }
@@ -692,9 +693,10 @@ namespace MWRender
 
     void RenderingManager::configureAmbient(const ESM::Cell *cell)
     {
+        bool isInterior = !cell->isExterior() && !(cell->mData.mFlags & ESM::Cell::QuasiEx);
         bool needsAdjusting = false;
         if (mResourceSystem->getSceneManager()->getLightingMethod() != SceneUtil::LightingMethod::FFP)
-            needsAdjusting = !cell->isExterior() && !(cell->mData.mFlags & ESM::Cell::QuasiEx);
+            needsAdjusting = isInterior;
 
         auto ambient = SceneUtil::colourFromRGB(cell->mAmbi.mAmbient);
 
@@ -724,11 +726,14 @@ namespace MWRender
         mSunLight->setPosition(osg::Vec4f(-0.15f, 0.15f, 1.f, 0.f));
     }
 
-    void RenderingManager::setSunColour(const osg::Vec4f& diffuse, const osg::Vec4f& specular)
+    void RenderingManager::setSunColour(const osg::Vec4f& diffuse, const osg::Vec4f& specular, float sunVis)
     {
         // need to wrap this in a StateUpdater?
         mSunLight->setDiffuse(diffuse);
         mSunLight->setSpecular(specular);
+
+        mPostProcessor->getStateUpdater()->setSunColor(diffuse);
+        mPostProcessor->getStateUpdater()->setSunVis(sunVis);
     }
 
     void RenderingManager::setSunDirection(const osg::Vec3f &direction)
@@ -738,6 +743,8 @@ namespace MWRender
         mSunLight->setPosition(osg::Vec4(position.x(), position.y(), position.z(), 0));
 
         mSky->setSunDirection(position);
+
+        mPostProcessor->getStateUpdater()->setSunPos(mSunLight->getPosition(), mNight);
     }
 
     void RenderingManager::addCell(const MWWorld::CellStore *store)
@@ -779,6 +786,7 @@ namespace MWRender
             mShadowManager->enableOutdoorMode();
         else
             mShadowManager->enableIndoorMode();
+        mPostProcessor->getStateUpdater()->setIsInterior(!enabled);
     }
 
     bool RenderingManager::toggleBorders()
@@ -877,9 +885,28 @@ namespace MWRender
         mCamera->update(dt, paused);
 
         bool isUnderwater = mWater->isUnderwater(mCamera->getPosition());
-        mStateUpdater->setFogStart(mFog->getFogStart(isUnderwater));
-        mStateUpdater->setFogEnd(mFog->getFogEnd(isUnderwater));
-        setFogColor(mFog->getFogColor(isUnderwater));
+
+        float fogStart = mFog->getFogStart(isUnderwater);
+        float fogEnd = mFog->getFogEnd(isUnderwater);
+        osg::Vec4f fogColor = mFog->getFogColor(isUnderwater);
+
+        mStateUpdater->setFogStart(fogStart);
+        mStateUpdater->setFogEnd(fogEnd);
+        setFogColor(fogColor);
+
+        auto world = MWBase::Environment::get().getWorld();
+        const auto& stateUpdater = mPostProcessor->getStateUpdater();
+
+        stateUpdater->setFogRange(fogStart, fogEnd);
+        stateUpdater->setNearFar(mNearClip, mViewDistance);
+        stateUpdater->setIsUnderwater(isUnderwater);
+        stateUpdater->setFogColor(fogColor);
+        stateUpdater->setGameHour(world->getTimeStamp().getHour());
+        stateUpdater->setWeatherId(world->getCurrentWeather());
+        stateUpdater->setNextWeatherId(world->getNextWeather());
+        stateUpdater->setWeatherTransition(world->getWeatherTransition());
+        stateUpdater->setWindSpeed(world->getWindSpeed());
+        mPostProcessor->setUnderwaterFlag(isUnderwater);
     }
 
     void RenderingManager::updatePlayerPtr(const MWWorld::Ptr &ptr)
@@ -939,6 +966,8 @@ namespace MWRender
         mWater->setCullCallback(mTerrain->getHeightCullCallback(height, Mask_Water));
         mWater->setHeight(height);
         mSky->setWaterHeight(height);
+
+        mPostProcessor->getStateUpdater()->setWaterHeight(height);
     }
 
     void RenderingManager::screenshot(osg::Image* image, int w, int h)
@@ -1131,6 +1160,11 @@ namespace MWRender
         return mObjects->getAnimation(ptr);
     }
 
+    PostProcessor* RenderingManager::getPostProcessor()
+    {
+        return mPostProcessor;
+    }
+
     void RenderingManager::setupPlayer(const MWWorld::Ptr &player)
     {
         if (!mPlayerNode)
@@ -1218,9 +1252,9 @@ namespace MWRender
         {
             auto res = Stereo::Manager::instance().eyeResolution();
             mSharedUniformStateUpdater->setScreenRes(res.x(), res.y());
-            Stereo::Manager::instance().setMasterProjectionMatrix(mPerViewUniformStateUpdater->projectionMatrix());
+            Stereo::Manager::instance().setMasterProjectionMatrix(mPerViewUniformStateUpdater->getProjectionMatrix());
         }
-        else
+        else if (!mPostProcessor->isEnabled())
         {
             mSharedUniformStateUpdater->setScreenRes(width, height);
         }
@@ -1229,6 +1263,17 @@ namespace MWRender
         // Limit FOV here just for sure, otherwise viewing distance can be too high.
         float distanceMult = std::cos(osg::DegreesToRadians(std::min(fov, 140.f))/2.f);
         mTerrain->setViewDistance(mViewDistance * (distanceMult ? 1.f/distanceMult : 1.f));
+
+        if (mPostProcessor)
+        {
+            mPostProcessor->getStateUpdater()->setProjectionMatrix(mPerViewUniformStateUpdater->getProjectionMatrix());
+            mPostProcessor->getStateUpdater()->setFov(fov);
+        }
+    }
+
+    void RenderingManager::setScreenRes(int width, int height)
+    {
+        mSharedUniformStateUpdater->setScreenRes(width, height);
     }
 
     void RenderingManager::updateTextureFiltering()
@@ -1316,7 +1361,7 @@ namespace MWRender
                                                 it->second == "light fade start" ||
                                                 it->second == "max lights"))
             {
-                auto* lightManager = static_cast<SceneUtil::LightManager*>(getLightRoot());
+                auto* lightManager = getLightRoot();
                 lightManager->processChangedSettings(changed);
 
                 if (it->second == "max lights" && !lightManager->usingFFP())
@@ -1335,6 +1380,17 @@ namespace MWRender
                     mViewer->startThreading();
                 }
             }
+            else if (it->first == "Post Processing" && it->second == "enabled")
+            {
+                if (Settings::Manager::getBool("enabled", "Post Processing"))
+                    mPostProcessor->enable();
+                else
+                {
+                    mPostProcessor->disable();
+                    if (auto* hud = MWBase::Environment::get().getWindowManager()->getPostProcessorHud())
+                        hud->setVisible(false);
+                }
+            }
         }
 
         if (updateProjection)
diff --git a/apps/openmw/mwrender/renderingmanager.hpp b/apps/openmw/mwrender/renderingmanager.hpp
index 5b5c28b1983e3c7083f2572b4939fa1bb8c559a1..cd4b6edca4f72d7b9233836157c72aea832c983c 100644
--- a/apps/openmw/mwrender/renderingmanager.hpp
+++ b/apps/openmw/mwrender/renderingmanager.hpp
@@ -59,6 +59,7 @@ namespace SceneUtil
 {
     class ShadowManager;
     class WorkQueue;
+    class LightManager;
 }
 
 namespace DetourNavigator
@@ -116,7 +117,7 @@ namespace MWRender
 
         double getReferenceTime() const;
 
-        osg::Group* getLightRoot();
+        SceneUtil::LightManager* getLightRoot();
 
         void setNightEyeFactor(float factor);
 
@@ -128,7 +129,8 @@ namespace MWRender
         void skySetMoonColour(bool red);
 
         void setSunDirection(const osg::Vec3f& direction);
-        void setSunColour(const osg::Vec4f& diffuse, const osg::Vec4f& specular);
+        void setSunColour(const osg::Vec4f& diffuse, const osg::Vec4f& specular, float sunVis);
+        void setNight(bool isNight) { mNight = isNight; }
 
         void configureAmbient(const ESM::Cell* cell);
         void configureFog(const ESM::Cell* cell);
@@ -192,6 +194,8 @@ namespace MWRender
         Animation* getAnimation(const MWWorld::Ptr& ptr);
         const Animation* getAnimation(const MWWorld::ConstPtr& ptr) const;
 
+        PostProcessor* getPostProcessor();
+
         void addWaterRippleEmitter(const MWWorld::Ptr& ptr);
         void removeWaterRippleEmitter(const MWWorld::Ptr& ptr);
         void emitWaterRipple(const osg::Vec3f& pos);
@@ -247,6 +251,8 @@ namespace MWRender
 
         void updateProjectionMatrix();
 
+        void setScreenRes(int width, int height);
+
     private:
         void updateTextureFiltering();
         void updateAmbient();
@@ -266,7 +272,7 @@ namespace MWRender
 
         osg::ref_ptr<osgViewer::Viewer> mViewer;
         osg::ref_ptr<osg::Group> mRootNode;
-        osg::ref_ptr<osg::Group> mSceneRoot;
+        osg::ref_ptr<SceneUtil::LightManager> mSceneRoot;
         Resource::ResourceSystem* mResourceSystem;
 
         osg::ref_ptr<SceneUtil::WorkQueue> mWorkQueue;
@@ -310,6 +316,7 @@ namespace MWRender
         float mFieldOfView;
         float mFirstPersonFieldOfView;
         bool mUpdateProjectionMatrix = false;
+        bool mNight = false;
 
         void operator = (const RenderingManager&);
         RenderingManager(const RenderingManager&);
diff --git a/apps/openmw/mwrender/screenshotmanager.cpp b/apps/openmw/mwrender/screenshotmanager.cpp
index 65b6a1bdbcc706aeb984db51d26269c128caf7c0..64961bf037761853753b19ac50d584b0fec1fc58 100644
--- a/apps/openmw/mwrender/screenshotmanager.cpp
+++ b/apps/openmw/mwrender/screenshotmanager.cpp
@@ -106,17 +106,16 @@ namespace MWRender
 
             if (ext)
             {
+                size_t frameId = renderInfo.getState()->getFrameStamp()->getFrameNumber() % 2;
                 osg::FrameBufferObject* fbo = nullptr;
+
                 if (Stereo::getStereo())
                     fbo = Stereo::Manager::instance().multiviewFramebuffer()->layerFbo(0);
-                else if (postProcessor)
-                    fbo = postProcessor->getFbo();
+                else if (postProcessor && postProcessor->getFbo(PostProcessor::FBO_Primary, frameId))
+                    fbo = postProcessor->getFbo(PostProcessor::FBO_Primary, frameId);
 
                 if (fbo)
-                {
-                    ext->glBindFramebuffer(GL_FRAMEBUFFER_EXT, fbo->getHandle(renderInfo.getContextID()));
-                    renderInfo.getState()->glReadBuffer(GL_COLOR_ATTACHMENT0_EXT);
-                }
+                    fbo->apply(*renderInfo.getState(), osg::FrameBufferObject::READ_FRAMEBUFFER);
             }
 
             mImage->readPixels(leftPadding, topPadding, width, height, GL_RGB, GL_UNSIGNED_BYTE);
diff --git a/apps/openmw/mwrender/sky.cpp b/apps/openmw/mwrender/sky.cpp
index f0a591477a978057f2716ce266d0a0d8310aa4c8..d8add9a685f18197e65e54b96327b5edffec5ec4 100644
--- a/apps/openmw/mwrender/sky.cpp
+++ b/apps/openmw/mwrender/sky.cpp
@@ -248,6 +248,7 @@ namespace MWRender
         , mBaseWindSpeed(0.f)
         , mEnabled(true)
         , mSunEnabled(true)
+        , mSunglareEnabled(true)
         , mPrecipitationAlpha(0.f)
         , mDirtyParticlesEffect(false)
     {
@@ -303,6 +304,7 @@ namespace MWRender
         atmosphereNight->addUpdateCallback(mAtmosphereNightUpdater);
 
         mSun.reset(new Sun(mEarlyRenderBinRoot, *mSceneManager));
+        mSun->setSunglare(mSunglareEnabled);
         mMasser.reset(new Moon(mEarlyRenderBinRoot, *mSceneManager, Fallback::Map::getFloat("Moons_Masser_Size")/125, Moon::Type_Masser));
         mSecunda.reset(new Moon(mEarlyRenderBinRoot, *mSceneManager, Fallback::Map::getFloat("Moons_Secunda_Size")/125, Moon::Type_Secunda));
 
@@ -776,6 +778,14 @@ namespace MWRender
         return mBaseWindSpeed;
     }
 
+    void SkyManager::setSunglare(bool enabled)
+    {
+        mSunglareEnabled = enabled;
+
+        if (mSun)
+            mSun->setSunglare(mSunglareEnabled);
+    }
+
     void SkyManager::sunEnable()
     {
         if (!mCreated) return;
diff --git a/apps/openmw/mwrender/sky.hpp b/apps/openmw/mwrender/sky.hpp
index e2ceae45f418ad95dd8904b7d968cdf141e80f29..1fdf476bd5740d5c13bfa6cfc944913c787279b0 100644
--- a/apps/openmw/mwrender/sky.hpp
+++ b/apps/openmw/mwrender/sky.hpp
@@ -96,6 +96,8 @@ namespace MWRender
 
         float getBaseWindSpeed() const;
 
+        void setSunglare(bool enabled);
+
     private:
         void create();
         ///< no need to call this, automatically done on first enable()
@@ -184,6 +186,7 @@ namespace MWRender
 
         bool mEnabled;
         bool mSunEnabled;
+        bool mSunglareEnabled;
 
         float mPrecipitationAlpha;
         bool mDirtyParticlesEffect;
diff --git a/apps/openmw/mwrender/skyutil.cpp b/apps/openmw/mwrender/skyutil.cpp
index ec9e6e7635e8fe38cc2beaa213ecf8c7be0b21c5..843582064bf15a0c0dc1f571ede2c7264e6b0cc9 100644
--- a/apps/openmw/mwrender/skyutil.cpp
+++ b/apps/openmw/mwrender/skyutil.cpp
@@ -812,6 +812,12 @@ namespace MWRender
             mSunGlareCallback->setTimeOfDayFade(val);
     }
 
+    void Sun::setSunglare(bool enabled)
+    {
+        mSunGlareNode->setNodeMask(enabled ? ~0u : 0);
+        mSunFlashNode->setNodeMask(enabled ? ~0u : 0);
+    }
+
     osg::ref_ptr<osg::OcclusionQueryNode> Sun::createOcclusionQueryNode(osg::Group* parent, bool queryVisible)
     {
         osg::ref_ptr<osg::OcclusionQueryNode> oqn = new osg::OcclusionQueryNode;
diff --git a/apps/openmw/mwrender/skyutil.hpp b/apps/openmw/mwrender/skyutil.hpp
index a0d9ed72b4fcdea6b34576f404a802d390fa1429..604e5909e886c9fcf402356ec5c76135520e29a9 100644
--- a/apps/openmw/mwrender/skyutil.hpp
+++ b/apps/openmw/mwrender/skyutil.hpp
@@ -248,6 +248,7 @@ namespace MWRender
 
         void setDirection(const osg::Vec3f& direction);
         void setGlareTimeOfDayFade(float val);
+        void setSunglare(bool enabled);
 
     private:
         /// @param queryVisible If true, queries the amount of visible pixels. If false, queries the total amount of pixels.
diff --git a/apps/openmw/mwrender/transparentpass.cpp b/apps/openmw/mwrender/transparentpass.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..8bb5713230b2d5be900c7d5ad6c051837450f6be
--- /dev/null
+++ b/apps/openmw/mwrender/transparentpass.cpp
@@ -0,0 +1,89 @@
+#include "transparentpass.hpp"
+
+#include <osg/BlendFunc>
+#include <osg/Texture2D>
+
+#include <osgUtil/RenderStage>
+
+#include <components/shader/shadermanager.hpp>
+
+namespace MWRender
+{
+        TransparentDepthBinCallback::TransparentDepthBinCallback(Shader::ShaderManager& shaderManager, bool postPass)
+            : mStateSet(new osg::StateSet)
+            , mPostPass(postPass)
+        {
+            osg::ref_ptr<osg::Image> image = new osg::Image;
+            image->allocateImage(1, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE);
+            image->setColor(osg::Vec4(1,1,1,1), 0, 0);
+
+            osg::ref_ptr<osg::Texture2D> dummyTexture = new osg::Texture2D(image);
+
+            constexpr osg::StateAttribute::OverrideValue modeOff = osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE;
+            constexpr osg::StateAttribute::OverrideValue modeOn = osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE;
+
+            mStateSet->setTextureAttributeAndModes(0, dummyTexture);
+
+            osg::ref_ptr<osg::Shader> vertex = shaderManager.getShader("blended_depth_postpass_vertex.glsl", {}, osg::Shader::VERTEX);
+            osg::ref_ptr<osg::Shader> fragment = shaderManager.getShader("blended_depth_postpass_fragment.glsl", {}, osg::Shader::FRAGMENT);
+
+            mStateSet->setAttributeAndModes(new osg::BlendFunc, modeOff);
+            mStateSet->setAttributeAndModes(shaderManager.getProgram(vertex, fragment), modeOn);
+
+            for (unsigned int unit = 1; unit < 8; ++unit)
+                mStateSet->setTextureMode(unit, GL_TEXTURE_2D, modeOff);
+        }
+
+        void TransparentDepthBinCallback::drawImplementation(osgUtil::RenderBin* bin, osg::RenderInfo& renderInfo, osgUtil::RenderLeaf*& previous)
+        {
+            osg::State& state = *renderInfo.getState();
+            osg::GLExtensions* ext = state.get<osg::GLExtensions>();
+
+            bool validFbo = false;
+            unsigned int frameId = state.getFrameStamp()->getFrameNumber() % 2;
+
+            const auto& fbo = mFbo[frameId];
+            const auto& msaaFbo = mMsaaFbo[frameId];
+            const auto& opaqueFbo = mOpaqueFbo[frameId];
+
+            if (bin->getStage()->getMultisampleResolveFramebufferObject() && bin->getStage()->getMultisampleResolveFramebufferObject() == fbo)
+                validFbo = true;
+            else if (bin->getStage()->getFrameBufferObject() && (bin->getStage()->getFrameBufferObject() == fbo || bin->getStage()->getFrameBufferObject() == msaaFbo))
+                validFbo = true;
+
+            if (!validFbo)
+            {
+                bin->drawImplementation(renderInfo, previous);
+                return;
+            }
+
+            const osg::Texture* tex = opaqueFbo->getAttachment(osg::FrameBufferObject::BufferComponent::PACKED_DEPTH_STENCIL_BUFFER).getTexture();
+
+            opaqueFbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+
+            ext->glBlitFramebuffer(0, 0, tex->getTextureWidth(), tex->getTextureHeight(), 0, 0, tex->getTextureWidth(), tex->getTextureHeight(), GL_DEPTH_BUFFER_BIT, GL_NEAREST);
+
+            if (msaaFbo)
+                msaaFbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+            else
+                fbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+
+            // draws scene into primary attachments
+            bin->drawImplementation(renderInfo, previous);
+
+            if (!mPostPass)
+                return;
+
+            opaqueFbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+
+            osg::ref_ptr<osg::StateSet> restore = bin->getStateSet();
+            bin->setStateSet(mStateSet);
+            // draws transparent post-pass to populate a postprocess friendly depth texture with alpha-clipped geometry
+            bin->drawImplementation(renderInfo, previous);
+            bin->setStateSet(restore);
+
+            if (!msaaFbo)
+                fbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+        }
+
+}
\ No newline at end of file
diff --git a/apps/openmw/mwrender/transparentpass.hpp b/apps/openmw/mwrender/transparentpass.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..a933dde98922dcceb37202a627a76856733888fa
--- /dev/null
+++ b/apps/openmw/mwrender/transparentpass.hpp
@@ -0,0 +1,38 @@
+#ifndef OPENMW_MWRENDER_TRANSPARENTPASS_H
+#define OPENMW_MWRENDER_TRANSPARENTPASS_H
+
+#include <array>
+
+#include <osg/FrameBufferObject>
+#include <osg/StateSet>
+
+#include <osgUtil/RenderBin>
+
+#include "postprocessor.hpp"
+
+namespace Shader
+{
+    class ShaderManager;
+}
+
+namespace MWRender
+{
+    class TransparentDepthBinCallback : public osgUtil::RenderBin::DrawCallback
+    {
+    public:
+        TransparentDepthBinCallback(Shader::ShaderManager& shaderManager, bool postPass);
+
+        void drawImplementation(osgUtil::RenderBin* bin, osg::RenderInfo& renderInfo, osgUtil::RenderLeaf*& previous) override;
+
+        std::array<osg::ref_ptr<osg::FrameBufferObject>, 2> mFbo;
+        std::array<osg::ref_ptr<osg::FrameBufferObject>, 2> mMsaaFbo;
+        std::array<osg::ref_ptr<osg::FrameBufferObject>, 2> mOpaqueFbo;
+
+    private:
+        osg::ref_ptr<osg::StateSet> mStateSet;
+        bool mPostPass;
+    };
+
+}
+
+#endif
\ No newline at end of file
diff --git a/apps/openmw/mwrender/water.cpp b/apps/openmw/mwrender/water.cpp
index c67a206416740f2080477d3cb604502c40295351..9896893da2e75d53c5ed43dec2a6beb654b8a588 100644
--- a/apps/openmw/mwrender/water.cpp
+++ b/apps/openmw/mwrender/water.cpp
@@ -267,6 +267,7 @@ public:
         : RTTNode(rttSize, rttSize, 0, false, 1, StereoAwareness::Aware)
         , mNodeMask(Refraction::sDefaultCullMask)
     {
+        setDepthBufferInternalFormat(GL_DEPTH24_STENCIL8);
         mClipCullNode = new ClipCullNode;
     }
 
@@ -342,6 +343,7 @@ public:
         : RTTNode(rttSize, rttSize, 0, false, 0, StereoAwareness::Aware)
     {
         setInterior(isInterior);
+        setDepthBufferInternalFormat(GL_DEPTH24_STENCIL8);
         mClipCullNode = new ClipCullNode;
     }
 
diff --git a/apps/openmw/mwworld/scene.cpp b/apps/openmw/mwworld/scene.cpp
index 0da47a9a74821fec1c88d31672db6ef93a8e500e..db1b9e592f144cf4817375d605e2e166aaad4375 100644
--- a/apps/openmw/mwworld/scene.cpp
+++ b/apps/openmw/mwworld/scene.cpp
@@ -27,6 +27,7 @@
 
 #include "../mwrender/renderingmanager.hpp"
 #include "../mwrender/landmanager.hpp"
+#include "../mwrender/postprocessor.hpp"
 
 #include "../mwphysics/physicssystem.hpp"
 #include "../mwphysics/actor.hpp"
@@ -860,6 +861,8 @@ namespace MWWorld
         MWBase::Environment::get().getWindowManager()->changeCell(mCurrentCell);
 
         mNavigator.wait(*loadingListener, DetourNavigator::WaitConditionType::requiredTilesPresent);
+
+        MWBase::Environment::get().getWorld()->getPostProcessor()->setExteriorFlag(cell->getCell()->mData.mFlags & ESM::Cell::QuasiEx);
     }
 
     void Scene::changeToExteriorCell (const ESM::Position& position, bool adjustPlayerPos, bool changeEvent)
@@ -879,6 +882,8 @@ namespace MWWorld
 
         if (changeEvent)
             MWBase::Environment::get().getWindowManager()->fadeScreenIn(0.5);
+
+        MWBase::Environment::get().getWorld()->getPostProcessor()->setExteriorFlag(true);
     }
 
     CellStore* Scene::getCurrentCell ()
diff --git a/apps/openmw/mwworld/weather.cpp b/apps/openmw/mwworld/weather.cpp
index 16a0bef1319bca3ed119b0eefdda978ba3574123..eb0226d506e1ae0cf3d3ebf91e046b7c0c9074b1 100644
--- a/apps/openmw/mwworld/weather.cpp
+++ b/apps/openmw/mwworld/weather.cpp
@@ -786,6 +786,7 @@ namespace MWWorld
                 -0.268f, // approx tan( -15 degrees )
                 static_cast<float>(sin(theta)));
             mRendering.setSunDirection( final * -1 );
+            mRendering.setNight(is_night);
         }
 
         float underwaterFog = mUnderwaterFog.getValue(time.getHour(), mTimeSettings, "Fog");
@@ -807,7 +808,7 @@ namespace MWWorld
         mRendering.configureFog(mResult.mFogDepth, underwaterFog, mResult.mDLFogFactor,
                                 mResult.mDLFogOffset/100.0f, mResult.mFogColor);
         mRendering.setAmbientColour(mResult.mAmbientColor);
-        mRendering.setSunColour(mResult.mSunColor, mResult.mSunColor * mResult.mGlareView * glareFade);
+        mRendering.setSunColour(mResult.mSunColor, mResult.mSunColor * mResult.mGlareView * glareFade, mResult.mGlareView * glareFade);
 
         mRendering.getSkyManager()->setWeather(mResult);
 
@@ -857,11 +858,6 @@ namespace MWWorld
         mFastForward = !incremental ? true : mFastForward;
     }
 
-    unsigned int WeatherManager::getWeatherID() const
-    {
-        return mCurrentWeather;
-    }
-
     NightDayMode WeatherManager::getNightDayMode() const
     {
         return mNightDayMode;
diff --git a/apps/openmw/mwworld/weather.hpp b/apps/openmw/mwworld/weather.hpp
index b29ad9e994ac1eb5e9fdc07380b73123b252d6ef..21b690f7b661a9d5f7f74f424acf82fc837a6e0f 100644
--- a/apps/openmw/mwworld/weather.hpp
+++ b/apps/openmw/mwworld/weather.hpp
@@ -307,7 +307,11 @@ namespace MWWorld
 
         void advanceTime(double hours, bool incremental);
 
-        unsigned int getWeatherID() const;
+        int getWeatherID() const { return mCurrentWeather; }
+
+        int getNextWeatherID() const { return mNextWeather; }
+
+        float getTransitionFactor() const { return mTransitionFactor; }
 
         bool useTorches(float hour) const;
 
diff --git a/apps/openmw/mwworld/worldimp.cpp b/apps/openmw/mwworld/worldimp.cpp
index 851ba2daf440ca92512225624a53144912817a05..cda1940ac431959697e01af48b9079645df9ecc1 100644
--- a/apps/openmw/mwworld/worldimp.cpp
+++ b/apps/openmw/mwworld/worldimp.cpp
@@ -28,6 +28,7 @@
 #include <components/resource/resourcesystem.hpp>
 
 #include <components/sceneutil/positionattitudetransform.hpp>
+#include <components/sceneutil/lightmanager.hpp>
 
 #include <components/detournavigator/navigator.hpp>
 #include <components/detournavigator/settings.hpp>
@@ -55,6 +56,7 @@
 #include "../mwrender/renderingmanager.hpp"
 #include "../mwrender/camera.hpp"
 #include "../mwrender/vismask.hpp"
+#include "../mwrender/postprocessor.hpp"
 
 #include "../mwscript/globalscripts.hpp"
 
@@ -196,7 +198,7 @@ namespace MWWorld
         }
 
         mRendering.reset(new MWRender::RenderingManager(viewer, rootNode, resourceSystem, workQueue, resourcePath, *mNavigator, mGroundcoverStore));
-        mProjectileManager.reset(new ProjectileManager(mRendering->getLightRoot(), resourceSystem, mRendering.get(), mPhysics.get()));
+        mProjectileManager.reset(new ProjectileManager(mRendering->getLightRoot()->asGroup(), resourceSystem, mRendering.get(), mPhysics.get()));
         mRendering->preloadCommonAssets();
 
         mWeatherManager.reset(new MWWorld::WeatherManager(*mRendering, mStore));
@@ -2045,6 +2047,16 @@ namespace MWWorld
         return mWeatherManager->getWeatherID();
     }
 
+    int World::getNextWeather() const
+    {
+        return mWeatherManager->getNextWeatherID();
+    }
+
+    float World::getWeatherTransition() const
+    {
+        return mWeatherManager->getTransitionFactor();
+    }
+
     unsigned int World::getNightDayMode() const
     {
         return mWeatherManager->getNightDayMode();
@@ -3986,4 +3998,8 @@ namespace MWWorld
         return mPrng;
     }
 
+    MWRender::PostProcessor* World::getPostProcessor()
+    {
+        return mRendering->getPostProcessor();
+    }
 }
diff --git a/apps/openmw/mwworld/worldimp.hpp b/apps/openmw/mwworld/worldimp.hpp
index 8098c6ec20d98f22106cbec5923b9c7e07a206f0..088c4097aa3ae61c3d5e55ba1f3edd54a06c9bb3 100644
--- a/apps/openmw/mwworld/worldimp.hpp
+++ b/apps/openmw/mwworld/worldimp.hpp
@@ -54,6 +54,7 @@ namespace MWRender
     class SkyManager;
     class Animation;
     class Camera;
+    class PostProcessor;
 }
 
 namespace ToUTF8
@@ -329,6 +330,10 @@ namespace MWWorld
 
             int getCurrentWeather() const override;
 
+            int getNextWeather() const override;
+
+            float getWeatherTransition() const override;
+
             unsigned int getNightDayMode() const override;
 
             int getMasserPhase() const override;
@@ -747,6 +752,8 @@ namespace MWWorld
             Misc::Rng::Generator& getPrng() override;
 
             MWRender::RenderingManager* getRenderingManager() override { return mRendering.get(); }
+
+            MWRender::PostProcessor* getPostProcessor() override;
     };
 }
 
diff --git a/apps/openmw_test_suite/CMakeLists.txt b/apps/openmw_test_suite/CMakeLists.txt
index 7e42a49f66389a009eee856cedbf45a131a84e1a..b17e49207d6174a5bc127ce42f45b1e33fb445eb 100644
--- a/apps/openmw_test_suite/CMakeLists.txt
+++ b/apps/openmw_test_suite/CMakeLists.txt
@@ -52,6 +52,7 @@ if (GTEST_FOUND AND GMOCK_FOUND)
         serialization/integration.cpp
 
         settings/parser.cpp
+        settings/shadermanager.cpp
 
         shader/parsedefines.cpp
         shader/parsefors.cpp
@@ -75,6 +76,9 @@ if (GTEST_FOUND AND GMOCK_FOUND)
         toutf8/toutf8.cpp
 
         esm4/includes.cpp
+
+        fx/lexer.cpp
+        fx/technique.cpp
     )
 
     source_group(apps\\openmw_test_suite FILES openmw_test_suite.cpp ${UNITTEST_SRC_FILES})
diff --git a/apps/openmw_test_suite/fx/lexer.cpp b/apps/openmw_test_suite/fx/lexer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..5024622a71ef80999ed989bb7cbb46c2ffc54767
--- /dev/null
+++ b/apps/openmw_test_suite/fx/lexer.cpp
@@ -0,0 +1,216 @@
+#include <components/fx/lexer.hpp>
+
+#include <gtest/gtest.h>
+
+namespace
+{
+    using namespace testing;
+    using namespace fx::Lexer;
+
+    struct LexerTest : Test {};
+    
+    struct LexerSingleTokenTest : Test
+    {
+        template <class Token>
+        void test()
+        {
+            const std::string content = std::string(Token::repr);
+            Lexer lexer(content);
+
+            EXPECT_TRUE(std::holds_alternative<Token>(lexer.next()));
+        }
+    };
+
+    TEST_F(LexerSingleTokenTest, single_token_shared) { test<Shared>(); }
+    TEST_F(LexerSingleTokenTest, single_token_technique) { test<Technique>(); }
+    TEST_F(LexerSingleTokenTest, single_token_main_pass) { test<Main_Pass>(); }
+    TEST_F(LexerSingleTokenTest, single_token_render_target) { test<Render_Target>(); }
+    TEST_F(LexerSingleTokenTest, single_token_vertex) { test<Vertex>(); }
+    TEST_F(LexerSingleTokenTest, single_token_fragment) { test<Fragment>(); }
+    TEST_F(LexerSingleTokenTest, single_token_compute) { test<Compute>(); }
+    TEST_F(LexerSingleTokenTest, single_token_sampler_1d) { test<Sampler_1D>(); }
+    TEST_F(LexerSingleTokenTest, single_token_sampler_2d) { test<Sampler_2D>(); }
+    TEST_F(LexerSingleTokenTest, single_token_sampler_3d) { test<Sampler_3D>(); }
+    TEST_F(LexerSingleTokenTest, single_token_true) { test<True>(); }
+    TEST_F(LexerSingleTokenTest, single_token_false) { test<False>(); }
+    TEST_F(LexerSingleTokenTest, single_token_vec2) { test<Vec2>(); }
+    TEST_F(LexerSingleTokenTest, single_token_vec3) { test<Vec3>(); }
+    TEST_F(LexerSingleTokenTest, single_token_vec4) { test<Vec4>(); }
+
+    TEST(LexerTest, peek_whitespace_only_content_should_be_eof)
+    {
+        Lexer lexer(R"(
+
+        )");
+
+        EXPECT_TRUE(std::holds_alternative<Eof>(lexer.peek()));
+    }
+
+    TEST(LexerTest, float_with_no_prefixed_digits)
+    {
+        Lexer lexer(R"(
+            0.123;
+        )");
+
+        auto token = lexer.next();
+        EXPECT_TRUE(std::holds_alternative<Float>(token));
+        EXPECT_FLOAT_EQ(std::get<Float>(token).value, 0.123f);
+    }
+
+    TEST(LexerTest, float_with_alpha_prefix)
+    {
+        Lexer lexer(R"(
+            abc.123;
+        )");
+
+        EXPECT_TRUE(std::holds_alternative<Literal>(lexer.next()));
+
+        auto token = lexer.next();
+        EXPECT_TRUE(std::holds_alternative<Float>(token));
+        EXPECT_FLOAT_EQ(std::get<Float>(token).value, 0.123f);
+    }
+
+    TEST(LexerTest, float_with_numeric_prefix)
+    {
+        Lexer lexer(R"(
+            123.123;
+        )");
+
+        auto token = lexer.next();
+        EXPECT_TRUE(std::holds_alternative<Float>(token));
+        EXPECT_FLOAT_EQ(std::get<Float>(token).value, 123.123f);
+    }
+
+    TEST(LexerTest, int_should_not_be_float)
+    {
+        Lexer lexer(R"(
+            123
+        )");
+
+        auto token = lexer.next();
+        EXPECT_TRUE(std::holds_alternative<Integer>(token));
+        EXPECT_EQ(std::get<Integer>(token).value, 123);
+    }
+
+    TEST(LexerTest, simple_string)
+    {
+        Lexer lexer(R"(
+            "test string"
+        )");
+
+        auto token = lexer.next();
+        EXPECT_TRUE(std::holds_alternative<String>(token));
+
+        std::string parsed = std::string(std::get<String>(token).value);
+        EXPECT_EQ("test string", parsed);
+    }
+
+    TEST(LexerTest, fail_on_unterminated_double_quotes)
+    {
+        Lexer lexer(R"(
+            "unterminated string'
+        )");
+
+        EXPECT_THROW(lexer.next(), LexerException);
+    }
+
+    TEST(LexerTest, multiline_strings_with_single_quotes)
+    {
+        Lexer lexer(R"(
+            "string that is
+                on multiple with 'single quotes'
+            and correctly terminated!"
+        )");
+
+        auto token = lexer.next();
+        EXPECT_TRUE(std::holds_alternative<String>(token));
+    }
+
+    TEST(LexerTest, fail_on_unterminated_double_quotes_with_multiline_strings)
+    {
+        Lexer lexer(R"(
+            "string that is
+                on multiple with 'single quotes'
+            and but is unterminated :(
+        )");
+
+        EXPECT_THROW(lexer.next(), LexerException);
+    }
+
+    TEST(LexerTest, jump_with_single_nested_bracket)
+    {
+        const std::string content = R"(
+                #version 120
+
+                void main()
+                {
+                    return 0;
+                }})";
+
+        const std::string expected = content.substr(0, content.size() - 1);
+
+        Lexer lexer(content);
+
+        auto block = lexer.jump();
+    
+        EXPECT_NE(block, std::nullopt);
+        EXPECT_EQ(expected, std::string(block.value()));
+    }
+
+    TEST(LexerTest, jump_with_single_line_comments_and_mismatching_brackets)
+    {
+        const std::string content = R"(
+                #version 120
+
+                void main()
+                {
+                    // }
+                    return 0;
+                }})";
+
+        const std::string expected = content.substr(0, content.size() - 1);
+
+        Lexer lexer(content);
+
+        auto block = lexer.jump();
+    
+        EXPECT_NE(block, std::nullopt);
+        EXPECT_EQ(expected, std::string(block.value()));
+    }
+
+    TEST(LexerTest, jump_with_multi_line_comments_and_mismatching_brackets)
+    {
+        const std::string content = R"(
+                #version 120
+
+                void main()
+                {
+                    /*
+                        }
+                    */
+                    return 0;
+                }})";
+
+        const std::string expected = content.substr(0, content.size() - 1);
+
+        Lexer lexer(content);
+
+        auto block = lexer.jump();
+    
+        EXPECT_NE(block, std::nullopt);
+        EXPECT_EQ(expected, std::string(block.value()));
+    }
+
+    TEST(LexerTest, immediate_closed_blocks)
+    {
+        Lexer lexer(R"(block{})");
+
+        EXPECT_TRUE(std::holds_alternative<Literal>(lexer.next()));
+        EXPECT_TRUE(std::holds_alternative<Open_bracket>(lexer.next()));
+        auto block = lexer.jump();
+        EXPECT_TRUE(block.has_value());
+        EXPECT_TRUE(block.value().empty());
+        EXPECT_TRUE(std::holds_alternative<Close_bracket>(lexer.next()));
+    }
+
+}
diff --git a/apps/openmw_test_suite/fx/technique.cpp b/apps/openmw_test_suite/fx/technique.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..d10e1f1b370876e4c80b4dc30dd15c38ab925eed
--- /dev/null
+++ b/apps/openmw_test_suite/fx/technique.cpp
@@ -0,0 +1,204 @@
+#include "gmock/gmock.h"
+#include <gtest/gtest.h>
+
+#include <components/settings/settings.hpp>
+#include <components/fx/technique.hpp>
+#include <components/resource/imagemanager.hpp>
+#include <components/files/configurationmanager.hpp>
+
+#include "../lua/testing_util.hpp"
+
+namespace
+{
+
+TestFile technique_properties(R"(
+    fragment main {}
+    vertex main {}
+    technique {
+        passes = main;
+        version = "0.1a";
+        description = "description";
+        author = "author";
+        glsl_version = 330;
+        glsl_profile = "compatability";
+        glsl_extensions = GL_EXT_gpu_shader4, GL_ARB_uniform_buffer_object;
+        flags = disable_sunglare;
+        hdr = true;
+    }
+)");
+
+TestFile rendertarget_properties{R"(
+    render_target rendertarget {
+        width_ratio = 0.5;
+        height_ratio = 0.5;
+        internal_format = r16f;
+        source_type = float;
+        source_format = red;
+        mipmaps = true;
+        wrap_s = clamp_to_edge;
+        wrap_t = repeat;
+        min_filter = linear;
+        mag_filter = nearest;
+    }
+    fragment downsample2x(target=rendertarget) {
+
+        omw_In vec2 omw_TexCoord;
+
+        void main()
+        {
+            omw_FragColor.r = omw_GetLastShader(omw_TexCoord).r;
+        }
+    }
+    fragment main { }
+    technique { passes = downsample2x, main; }
+)"};
+
+
+TestFile uniform_properties{R"(
+    uniform_vec4 uVec4 {
+        default = vec4(0,0,0,0);
+        min = vec4(0,1,0,0);
+        max = vec4(0,0,1,0);
+        step = 0.5;
+        header = "header";
+        static = true;
+        description = "description";
+    }
+    fragment main { }
+    technique { passes = main; }
+)"};
+
+
+TestFile missing_sampler_source{R"(
+    sampler_1d mysampler1d { }
+    fragment main { }
+    technique { passes = main; }
+)"};
+
+TestFile repeated_shared_block{R"(
+    shared {
+        float myfloat = 1.0;
+    }
+    shared {}
+    fragment main { }
+    technique { passes = main; }
+)"};
+
+
+    using namespace testing;
+    using namespace fx;
+
+    struct TechniqueTest : Test
+    {
+        std::unique_ptr<VFS::Manager> mVFS;
+        Resource::ImageManager mImageManager;
+        std::unique_ptr<Technique> mTechnique;
+
+        TechniqueTest()
+            : mVFS(createTestVFS({
+                {"shaders/technique_properties.omwfx", &technique_properties},
+                {"shaders/rendertarget_properties.omwfx", &rendertarget_properties},
+                {"shaders/uniform_properties.omwfx", &uniform_properties},
+                {"shaders/missing_sampler_source.omwfx", &missing_sampler_source},
+                {"shaders/repeated_shared_block.omwfx", &repeated_shared_block},
+            }))
+            , mImageManager(mVFS.get())
+        {
+            Settings::Manager::setBool("radial fog", "Shaders", true);
+            Settings::Manager::setBool("stereo enabled", "Stereo", false);
+        }
+
+        void compile(const std::string& name)
+        {
+            mTechnique = std::make_unique<Technique>(*mVFS.get(), mImageManager, name, 1, 1, true, true);
+            mTechnique->compile();
+        }
+    };
+
+    TEST_F(TechniqueTest, technique_properties)
+    {
+        std::unordered_set<std::string> targetExtensions = {
+            "GL_EXT_gpu_shader4",
+            "GL_ARB_uniform_buffer_object"
+        };
+
+        compile("technique_properties");
+
+        EXPECT_EQ(mTechnique->getVersion(), "0.1a");
+        EXPECT_EQ(mTechnique->getDescription(), "description");
+        EXPECT_EQ(mTechnique->getAuthor(), "author");
+        EXPECT_EQ(mTechnique->getGLSLVersion(), 330);
+        EXPECT_EQ(mTechnique->getGLSLProfile(), "compatability");
+        EXPECT_EQ(mTechnique->getGLSLExtensions(), targetExtensions);
+        EXPECT_EQ(mTechnique->getFlags(), Technique::Flag_Disable_SunGlare);
+        EXPECT_EQ(mTechnique->getHDR(), true);
+        EXPECT_EQ(mTechnique->getPasses().size(), 1);
+        EXPECT_EQ(mTechnique->getPasses().front()->getName(), "main");
+    }
+
+    TEST_F(TechniqueTest, rendertarget_properties)
+    {
+        compile("rendertarget_properties");
+
+        EXPECT_EQ(mTechnique->getRenderTargetsMap().size(), 1);
+
+        const std::string_view name = mTechnique->getRenderTargetsMap().begin()->first;
+        auto& rt = mTechnique->getRenderTargetsMap().begin()->second;
+        auto& texture = rt.mTarget;
+
+        EXPECT_EQ(name, "rendertarget");
+        EXPECT_EQ(rt.mMipMap, true);
+        EXPECT_EQ(rt.mSize.mWidthRatio, 0.5f);
+        EXPECT_EQ(rt.mSize.mHeightRatio, 0.5f);
+        EXPECT_EQ(texture->getWrap(osg::Texture::WRAP_S), osg::Texture::CLAMP_TO_EDGE);
+        EXPECT_EQ(texture->getWrap(osg::Texture::WRAP_T), osg::Texture::REPEAT);
+        EXPECT_EQ(texture->getFilter(osg::Texture::MIN_FILTER), osg::Texture::LINEAR);
+        EXPECT_EQ(texture->getFilter(osg::Texture::MAG_FILTER), osg::Texture::NEAREST);
+        EXPECT_EQ(texture->getSourceType(), static_cast<GLenum>(GL_FLOAT));
+        EXPECT_EQ(texture->getSourceFormat(), static_cast<GLenum>(GL_RED));
+        EXPECT_EQ(texture->getInternalFormat(), static_cast<GLint>(GL_R16F));
+
+        EXPECT_EQ(mTechnique->getPasses().size(), 2);
+        EXPECT_EQ(mTechnique->getPasses()[0]->getTarget(), "rendertarget");
+    }
+
+    TEST_F(TechniqueTest, uniform_properties)
+    {
+        compile("uniform_properties");
+
+        EXPECT_EQ(mTechnique->getUniformMap().size(), 1);
+
+        const auto& uniform = mTechnique->getUniformMap().front();
+
+        EXPECT_TRUE(uniform->mStatic);
+        EXPECT_FLOAT_EQ(uniform->mStep, 0.5f);
+        EXPECT_EQ(uniform->getDefault<osg::Vec4f>(), osg::Vec4f(0,0,0,0));
+        EXPECT_EQ(uniform->getMin<osg::Vec4f>(), osg::Vec4f(0,1,0,0));
+        EXPECT_EQ(uniform->getMax<osg::Vec4f>(), osg::Vec4f(0,0,1,0));
+        EXPECT_EQ(uniform->mHeader, "header");
+        EXPECT_EQ(uniform->mDescription, "description");
+        EXPECT_EQ(uniform->mName, "uVec4");
+    }
+
+    TEST_F(TechniqueTest, fail_with_missing_source_for_sampler)
+    {
+        internal::CaptureStdout();
+
+        compile("missing_sampler_source");
+
+        std::string output = internal::GetCapturedStdout();
+        Log(Debug::Error) << output;
+        EXPECT_THAT(output, HasSubstr("sampler_1d 'mysampler1d' requires a filename"));
+    }
+
+    TEST_F(TechniqueTest, fail_with_repeated_shared_block)
+    {
+        internal::CaptureStdout();
+
+        compile("repeated_shared_block");
+
+        std::string output = internal::GetCapturedStdout();
+        Log(Debug::Error) << output;
+        EXPECT_THAT(output, HasSubstr("repeated 'shared' block"));
+    }
+}
\ No newline at end of file
diff --git a/apps/openmw_test_suite/lua/testing_util.hpp b/apps/openmw_test_suite/lua/testing_util.hpp
index a40314bd0dd1d16e47bb873e7bf27295c9f31535..217c8ae5d5ee5d57dcae2d244d3fe9ee5e11ebbe 100644
--- a/apps/openmw_test_suite/lua/testing_util.hpp
+++ b/apps/openmw_test_suite/lua/testing_util.hpp
@@ -26,6 +26,11 @@ namespace
             return std::make_unique<std::stringstream>(mContent, std::ios_base::in);
         }
 
+        std::string getPath() override
+        {
+            return "TestFile";
+        }
+
     private:
         const std::string mContent;
     };
diff --git a/apps/openmw_test_suite/settings/shadermanager.cpp b/apps/openmw_test_suite/settings/shadermanager.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..8f8e09e134f821e5cc4d33ba5c57fe1d716cfef3
--- /dev/null
+++ b/apps/openmw_test_suite/settings/shadermanager.cpp
@@ -0,0 +1,66 @@
+#include <components/settings/shadermanager.hpp>
+
+#include <fstream>
+
+#include <gtest/gtest.h>
+
+namespace
+{
+    using namespace testing;
+    using namespace Settings;
+
+    struct ShaderSettingsTest : Test
+    {
+        template <typename F>
+        void withSettingsFile( const std::string& content, F&& f)
+        {
+            const auto path = std::string(UnitTest::GetInstance()->current_test_info()->name()) + ".yaml";
+
+            {
+                std::ofstream stream;
+                stream.open(path);
+                stream << content;
+                stream.close();
+            }
+
+            f(path);
+        }
+    };
+
+    TEST_F(ShaderSettingsTest, fail_to_fetch_then_set_and_succeed)
+    {
+        const std::string content =
+R"YAML(
+config:
+    shader:
+        vec3_uniform: [1.0, 2.0]
+)YAML";
+
+        withSettingsFile(content, [this] (const auto& path) {
+            EXPECT_TRUE(ShaderManager::get().load(path));
+            EXPECT_FALSE(ShaderManager::get().getValue<osg::Vec3f>("shader", "vec3_uniform").has_value());
+            EXPECT_TRUE(ShaderManager::get().setValue<osg::Vec3f>("shader", "vec3_uniform", osg::Vec3f(1, 2, 3)));
+            EXPECT_TRUE(ShaderManager::get().getValue<osg::Vec3f>("shader", "vec3_uniform").has_value());
+            EXPECT_EQ(ShaderManager::get().getValue<osg::Vec3f>("shader", "vec3_uniform").value(), osg::Vec3f(1, 2, 3));
+            EXPECT_TRUE(ShaderManager::get().save());
+        });
+    }
+
+    TEST_F(ShaderSettingsTest, fail_to_load_file_then_fail_to_set_and_get)
+    {
+        const std::string content =
+R"YAML(
+config:
+    shader:
+        uniform: 12.0
+ >Defeated by a sideways carrot
+)YAML";
+
+        withSettingsFile(content, [this] (const auto& path) {
+            EXPECT_FALSE(ShaderManager::get().load(path));
+            EXPECT_FALSE(ShaderManager::get().setValue("shader", "uniform", 12.0));
+            EXPECT_FALSE(ShaderManager::get().getValue<float>("shader", "uniform").has_value());
+            EXPECT_FALSE(ShaderManager::get().save());
+        });
+    }
+}
\ No newline at end of file
diff --git a/components/CMakeLists.txt b/components/CMakeLists.txt
index 5ad88523b89600d76a1b515c68558e334bc403c7..8e7f1bbfa58d9fe21e9e5a86f7fadeef652c4dff 100644
--- a/components/CMakeLists.txt
+++ b/components/CMakeLists.txt
@@ -82,6 +82,10 @@ add_component_dir (to_utf8
 
 add_component_dir(esm attr common defs esmcommon reader records util luascripts format)
 
+add_component_dir(fx pass technique lexer widgets stateupdater)
+
+add_component_dir(std140 ubo)
+
 add_component_dir (esm3
     esmreader esmwriter loadacti loadalch loadappa loadarmo loadbody loadbook loadbsgn loadcell
     loadclas loadclot loadcont loadcrea loaddial loaddoor loadench loadfact loadglob loadgmst
diff --git a/components/fx/lexer.cpp b/components/fx/lexer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..d416dd692d9511581044cdb77647b8b855751455
--- /dev/null
+++ b/components/fx/lexer.cpp
@@ -0,0 +1,301 @@
+#include "lexer.hpp"
+
+#include <string_view>
+#include <string>
+#include <variant>
+#include <optional>
+#include <cstdint>
+#include <array>
+#include <cmath>
+#include <exception>
+
+#include <components/misc/stringops.hpp>
+
+#include <components/debug/debuglog.hpp>
+
+#include "types.hpp"
+
+namespace fx
+{
+    namespace Lexer
+    {
+        Lexer::Lexer(std::string_view buffer)
+            : mHead(buffer.data())
+            , mTail(mHead + buffer.length())
+            , mAbsolutePos(0)
+            , mColumn(0)
+            , mLine(0)
+            , mBuffer(buffer)
+            , mLastToken(Eof{})
+        { }
+
+        Token Lexer::next()
+        {
+            if (mLookahead)
+            {
+                auto token = *mLookahead;
+                drop();
+                return token;
+            }
+
+            mLastToken = scanToken();
+
+            return mLastToken;
+        }
+
+        Token Lexer::peek()
+        {
+            if (!mLookahead)
+                mLookahead = scanToken();
+
+            return *mLookahead;
+        }
+
+        void Lexer::drop()
+        {
+            mLookahead = std::nullopt;
+        }
+
+        std::optional<std::string_view> Lexer::jump()
+        {
+            bool multi = false;
+            bool single = false;
+            auto start = mHead;
+            std::size_t level = 1;
+
+            mLastJumpBlock.line = mLine;
+
+            if (head() == '}')
+            {
+                mLastJumpBlock.content = {};
+                return mLastJumpBlock.content;
+            }
+
+            for (; mHead != mTail; advance())
+            {
+                if (head() == '\n')
+                {
+                    mLine++;
+                    mColumn = 0;
+                    if (single)
+                    {
+                        single = false;
+                        continue;
+                    }
+                }
+                else if (multi && head() == '*' && peekChar('/'))
+                {
+                    multi = false;
+                    advance();
+                    continue;
+                }
+                else if (multi || single)
+                {
+                    continue;
+                }
+                else if (head() == '/' && peekChar('/'))
+                {
+                    single = true;
+                    advance();
+                    continue;
+                }
+                else if (head() == '/' && peekChar('*'))
+                {
+                    multi = true;
+                    advance();
+                    continue;
+                }
+
+                if (head() == '{')
+                    level++;
+                else if (head() == '}')
+                    level--;
+
+                if (level == 0)
+                {
+                    mHead--;
+                    auto sv = std::string_view{start, static_cast<std::string_view::size_type>(mHead + 1 - start)};
+                    mLastJumpBlock.content = sv;
+                    return sv;
+                }
+            }
+
+            mLastJumpBlock = {};
+            return std::nullopt;
+        }
+
+        Lexer::Block Lexer::getLastJumpBlock() const
+        {
+            return mLastJumpBlock;
+        }
+
+        [[noreturn]] void Lexer::error(const std::string& msg)
+        {
+            throw LexerException(Misc::StringUtils::format("Line %zu Col %zu. %s", mLine + 1, mColumn, msg));
+        }
+
+        void Lexer::advance()
+        {
+            mAbsolutePos++;
+            mHead++;
+            mColumn++;
+        }
+
+        char Lexer::head()
+        {
+            return *mHead;
+        }
+
+        bool Lexer::peekChar(char c)
+        {
+            if (mHead == mTail)
+                return false;
+            return *(mHead + 1) == c;
+        }
+
+        Token Lexer::scanToken()
+        {
+            while (true)
+            {
+                if (mHead == mTail)
+                    return {Eof{}};
+
+                if (head() == '\n')
+                {
+                    mLine++;
+                    mColumn = 0;
+                }
+
+                if (!std::isspace(head()))
+                    break;
+
+                advance();
+            }
+
+            if (head() == '\"')
+                return scanStringLiteral();
+
+            if (std::isalpha(head()))
+                return scanLiteral();
+
+            if (std::isdigit(head()) || head() == '.' || head() == '-')
+                return scanNumber();
+
+            switch(head())
+            {
+                case '=':
+                    advance();
+                    return {Equal{}};
+                case '{':
+                    advance();
+                    return {Open_bracket{}};
+                case '}':
+                    advance();
+                    return {Close_bracket{}};
+                case '(':
+                    advance();
+                    return {Open_Parenthesis{}};
+                case ')':
+                    advance();
+                    return {Close_Parenthesis{}};
+                case '\"':
+                    advance();
+                    return {Quote{}};
+                case ':':
+                    advance();
+                    return {Colon{}};
+                case ';':
+                    advance();
+                    return {SemiColon{}};
+                case '|':
+                    advance();
+                    return {VBar{}};
+                case ',':
+                    advance();
+                    return {Comma{}};
+                default:
+                    error(Misc::StringUtils::format("unexpected token <%c>", head()));
+            }
+        }
+
+        Token Lexer::scanLiteral()
+        {
+            auto start = mHead;
+            advance();
+
+            while (mHead != mTail && (std::isalnum(head()) || head() == '_'))
+                advance();
+
+            std::string_view value{start, static_cast<std::string_view::size_type>(mHead - start)};
+
+            if (value == "shared") return Shared{};
+            if (value == "technique") return Technique{};
+            if (value == "main_pass") return Main_Pass{};
+            if (value == "render_target") return Render_Target{};
+            if (value == "vertex") return Vertex{};
+            if (value == "fragment") return Fragment{};
+            if (value == "compute") return Compute{};
+            if (value == "sampler_1d") return Sampler_1D{};
+            if (value == "sampler_2d") return Sampler_2D{};
+            if (value == "sampler_3d") return Sampler_3D{};
+            if (value == "uniform_bool") return Uniform_Bool{};
+            if (value == "uniform_float") return Uniform_Float{};
+            if (value == "uniform_int") return Uniform_Int{};
+            if (value == "uniform_vec2") return Uniform_Vec2{};
+            if (value == "uniform_vec3") return Uniform_Vec3{};
+            if (value == "uniform_vec4") return Uniform_Vec4{};
+            if (value == "true") return True{};
+            if (value == "false") return False{};
+            if (value == "vec2") return Vec2{};
+            if (value == "vec3") return Vec3{};
+            if (value == "vec4") return Vec4{};
+
+            return Literal{value};
+        }
+
+        Token Lexer::scanStringLiteral()
+        {
+            advance(); // consume quote
+            auto start = mHead;
+
+            bool terminated = false;
+
+            for (; mHead != mTail; advance())
+            {
+                if (head() == '\"')
+                {
+                    terminated = true;
+                    advance();
+                    break;
+                }
+            }
+
+            if (!terminated)
+                error("unterminated string");
+
+            return String{{start, static_cast<std::string_view::size_type>(mHead - start - 1)}};
+        }
+
+        Token Lexer::scanNumber()
+        {
+            double buffer;
+
+            char* endPtr;
+            buffer = std::strtod(mHead, &endPtr);
+
+            if (endPtr == nullptr)
+                error("critical error while parsing number");
+
+            const char* tmp = mHead;
+            mHead = endPtr;
+
+            for (; tmp != endPtr; ++tmp)
+            {
+                if ((*tmp == '.'))
+                    return Float{static_cast<float>(buffer)};
+            }
+
+            return Integer{static_cast<int>(buffer)};
+        }
+    }
+}
diff --git a/components/fx/lexer.hpp b/components/fx/lexer.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..e24239399c45d9e0cc275fe449769ade59fc49ac
--- /dev/null
+++ b/components/fx/lexer.hpp
@@ -0,0 +1,75 @@
+#ifndef OPENMW_COMPONENTS_FX_LEXER_H
+#define OPENMW_COMPONENTS_FX_LEXER_H
+
+#include <string_view>
+#include <string>
+#include <variant>
+#include <optional>
+#include <cstdint>
+#include <stdexcept>
+
+#include <osg/Vec2f>
+#include <osg/Vec3f>
+#include <osg/Vec4f>
+
+#include "lexer_types.hpp"
+
+namespace fx
+{
+    namespace Lexer
+    {
+        struct LexerException : std::runtime_error
+        {
+            LexerException(const std::string& message) : std::runtime_error(message) {}
+            LexerException(const char* message) : std::runtime_error(message) {}
+        };
+
+        class Lexer
+        {
+        public:
+            struct Block
+            {
+                int line;
+                std::string_view content;
+            };
+
+            Lexer(std::string_view buffer);
+            Lexer() = delete;
+
+            Token next();
+            Token peek();
+
+            // Jump ahead to next uncommented closing bracket at level zero. Assumes the head is at an opening bracket.
+            // Returns the contents of the block excluding the brackets and places cursor at closing bracket.
+            std::optional<std::string_view> jump();
+
+            Block getLastJumpBlock() const;
+
+            [[noreturn]] void error(const std::string& msg);
+
+        private:
+            void drop();
+            void advance();
+            char head();
+            bool peekChar(char c);
+
+            Token scanToken();
+            Token scanLiteral();
+            Token scanStringLiteral();
+            Token scanNumber();
+
+            const char* mHead;
+            const char* mTail;
+            std::size_t mAbsolutePos;
+            std::size_t mColumn;
+            std::size_t mLine;
+            std::string_view mBuffer;
+            Token mLastToken;
+            std::optional<Token> mLookahead;
+
+            Block mLastJumpBlock;
+        };
+    }
+}
+
+#endif
diff --git a/components/fx/lexer_types.hpp b/components/fx/lexer_types.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..0d81c483b7d3f821ee9c87aa26a145470ab7ebba
--- /dev/null
+++ b/components/fx/lexer_types.hpp
@@ -0,0 +1,56 @@
+#ifndef OPENMW_COMPONENTS_FX_LEXER_TYPES_H
+#define OPENMW_COMPONENTS_FX_LEXER_TYPES_H
+
+#include <variant>
+#include <string_view>
+
+namespace fx
+{
+    namespace Lexer
+    {
+        struct Float            { inline static constexpr std::string_view repr = "float"; float value = 0.0;};
+        struct Integer          { inline static constexpr std::string_view repr = "integer"; int value = 0;};
+        struct Boolean          { inline static constexpr std::string_view repr = "boolean"; bool value = false;};
+        struct Literal          { inline static constexpr std::string_view repr = "literal"; std::string_view value;};
+        struct String           { inline static constexpr std::string_view repr = "string"; std::string_view value;};
+        struct Shared           { inline static constexpr std::string_view repr = "shared"; };
+        struct Vertex           { inline static constexpr std::string_view repr = "vertex"; };
+        struct Fragment         { inline static constexpr std::string_view repr = "fragment"; };
+        struct Compute          { inline static constexpr std::string_view repr = "compute"; };
+        struct Technique        { inline static constexpr std::string_view repr = "technique"; };
+        struct Main_Pass        { inline static constexpr std::string_view repr = "main_pass"; };
+        struct Render_Target    { inline static constexpr std::string_view repr = "render_target"; };
+        struct Sampler_1D       { inline static constexpr std::string_view repr = "sampler_1d"; };
+        struct Sampler_2D       { inline static constexpr std::string_view repr = "sampler_2d"; };
+        struct Sampler_3D       { inline static constexpr std::string_view repr = "sampler_3d"; };
+        struct Uniform_Bool     { inline static constexpr std::string_view repr = "uniform_bool"; };
+        struct Uniform_Float    { inline static constexpr std::string_view repr = "uniform_float"; };
+        struct Uniform_Int      { inline static constexpr std::string_view repr = "uniform_int"; };
+        struct Uniform_Vec2     { inline static constexpr std::string_view repr = "uniform_vec2"; };
+        struct Uniform_Vec3     { inline static constexpr std::string_view repr = "uniform_vec3"; };
+        struct Uniform_Vec4     { inline static constexpr std::string_view repr = "uniform_vec4"; };
+        struct Eof              { inline static constexpr std::string_view repr = "eof"; };
+        struct Equal            { inline static constexpr std::string_view repr = "equal"; };
+        struct Open_bracket     { inline static constexpr std::string_view repr = "open_bracket"; };
+        struct Close_bracket    { inline static constexpr std::string_view repr = "close_bracket"; };
+        struct Open_Parenthesis { inline static constexpr std::string_view repr = "open_parenthesis"; };
+        struct Close_Parenthesis{ inline static constexpr std::string_view repr = "close_parenthesis"; };
+        struct Quote            { inline static constexpr std::string_view repr = "quote"; };
+        struct SemiColon        { inline static constexpr std::string_view repr = "semicolon"; };
+        struct Comma            { inline static constexpr std::string_view repr = "comma"; };
+        struct VBar             { inline static constexpr std::string_view repr = "vbar"; };
+        struct Colon            { inline static constexpr std::string_view repr = "colon"; };
+        struct True             { inline static constexpr std::string_view repr = "true"; };
+        struct False            { inline static constexpr std::string_view repr = "false"; };
+        struct Vec2             { inline static constexpr std::string_view repr = "vec2"; };
+        struct Vec3             { inline static constexpr std::string_view repr = "vec3"; };
+        struct Vec4             { inline static constexpr std::string_view repr = "vec4"; };
+
+        using Token = std::variant<Float, Integer, Boolean, String, Literal, Equal, Open_bracket, Close_bracket, Open_Parenthesis,
+            Close_Parenthesis, Quote, SemiColon, Comma, VBar, Colon, Shared, Technique, Render_Target, Vertex, Fragment,
+            Compute, Sampler_1D, Sampler_2D, Sampler_3D, Uniform_Bool, Uniform_Float, Uniform_Int, Uniform_Vec2, Uniform_Vec3, Uniform_Vec4,
+            True, False, Vec2, Vec3, Vec4, Main_Pass, Eof>;
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/components/fx/parse_constants.hpp b/components/fx/parse_constants.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..18d32ee53a20a67ce8fba2767e8dc238548d06e0
--- /dev/null
+++ b/components/fx/parse_constants.hpp
@@ -0,0 +1,133 @@
+#ifndef OPENMW_COMPONENTS_FX_PARSE_CONSTANTS_H
+#define OPENMW_COMPONENTS_FX_PARSE_CONSTANTS_H
+
+#include <array>
+#include <string_view>
+
+#include <osg/Texture>
+#include <osg/Image>
+#include <osg/BlendFunc>
+#include <osg/BlendEquation>
+
+#include <components/sceneutil/color.hpp>
+
+#include "technique.hpp"
+
+namespace fx
+{
+    namespace constants
+    {
+        constexpr std::array<std::pair<std::string_view, fx::FlagsType>, 6> TechniqueFlag = {{
+            {"disable_interiors"  ,  Technique::Flag_Disable_Interiors},
+            {"disable_exteriors"  ,  Technique::Flag_Disable_Exteriors},
+            {"disable_underwater" ,  Technique::Flag_Disable_Underwater},
+            {"disable_abovewater" ,  Technique::Flag_Disable_Abovewater},
+            {"disable_sunglare"   ,  Technique::Flag_Disable_SunGlare},
+            {"hidden"             ,  Technique::Flag_Hidden}
+        }};
+
+        constexpr std::array<std::pair<std::string_view, int>, 6> SourceFormat = {{
+            {"red" ,  GL_RED},
+            {"rg"  ,  GL_RG},
+            {"rgb" ,  GL_RGB},
+            {"bgr" ,  GL_BGR},
+            {"rgba",  GL_RGBA},
+            {"bgra",  GL_BGRA},
+        }};
+
+        constexpr std::array<std::pair<std::string_view, int>, 9> SourceType = {{
+            {"byte"             ,  GL_BYTE},
+            {"unsigned_byte"    ,  GL_UNSIGNED_BYTE},
+            {"short"            ,  GL_SHORT},
+            {"unsigned_short"   ,  GL_UNSIGNED_SHORT},
+            {"int"              ,  GL_INT},
+            {"unsigned_int"     ,  GL_UNSIGNED_INT},
+            {"unsigned_int_24_8",  GL_UNSIGNED_INT_24_8},
+            {"float"            ,  GL_FLOAT},
+            {"double"           ,  GL_DOUBLE},
+        }};
+
+        constexpr std::array<std::pair<std::string_view, int>, 16> InternalFormat = {{
+            {"red"               ,  GL_RED},
+            {"r16f"              ,  GL_R16F},
+            {"r32f"              ,  GL_R32F},
+            {"rg"                ,  GL_RG},
+            {"rg16f"             ,  GL_RG16F},
+            {"rg32f"             ,  GL_RG32F},
+            {"rgb"               ,  GL_RGB},
+            {"rgb16f"            ,  GL_RGB16F},
+            {"rgb32f"            ,  GL_RGB32F},
+            {"rgba"              ,  GL_RGBA},
+            {"rgba16f"           ,  GL_RGBA16F},
+            {"rgba32f"           ,  GL_RGBA32F},
+            {"depth_component16" ,  GL_DEPTH_COMPONENT16},
+            {"depth_component24" ,  GL_DEPTH_COMPONENT24},
+            {"depth_component32" ,  GL_DEPTH_COMPONENT32},
+            {"depth_component32f",  GL_DEPTH_COMPONENT32F}
+        }};
+
+        constexpr std::array<std::pair<std::string_view, osg::Texture::InternalFormatMode>, 13> Compression = {{
+            {"auto"        , osg::Texture::USE_USER_DEFINED_FORMAT},
+            {"arb"         , osg::Texture::USE_ARB_COMPRESSION},
+            {"s3tc_dxt1"   , osg::Texture::USE_S3TC_DXT1_COMPRESSION},
+            {"s3tc_dxt3"   , osg::Texture::USE_S3TC_DXT3_COMPRESSION},
+            {"s3tc_dxt5"   , osg::Texture::USE_S3TC_DXT5_COMPRESSION},
+            {"pvrtc_2bpp"  , osg::Texture::USE_PVRTC_2BPP_COMPRESSION},
+            {"pvrtc_4bpp"  , osg::Texture::USE_PVRTC_4BPP_COMPRESSION},
+            {"etc"         , osg::Texture::USE_ETC_COMPRESSION},
+            {"etc2"        , osg::Texture::USE_ETC2_COMPRESSION},
+            {"rgtc1"       , osg::Texture::USE_RGTC1_COMPRESSION},
+            {"rgtc2"       , osg::Texture::USE_RGTC2_COMPRESSION},
+            {"s3tc_dxt1c"  , osg::Texture::USE_S3TC_DXT1c_COMPRESSION},
+            {"s3tc_dxt1a"  , osg::Texture::USE_S3TC_DXT1a_COMPRESSION}
+        }};
+
+        constexpr std::array<std::pair<std::string_view, osg::Texture::WrapMode>, 6> WrapMode = {{
+            {"clamp"          , osg::Texture::CLAMP},
+            {"clamp_to_edge"  , osg::Texture::CLAMP_TO_EDGE},
+            {"clamp_to_border", osg::Texture::CLAMP_TO_BORDER},
+            {"repeat"         , osg::Texture::REPEAT},
+            {"mirror"         , osg::Texture::MIRROR}
+        }};
+
+        constexpr std::array<std::pair<std::string_view, osg::Texture::FilterMode>, 6> FilterMode = {{
+            {"linear"                , osg::Texture::LINEAR},
+            {"linear_mipmap_linear"  , osg::Texture::LINEAR_MIPMAP_LINEAR},
+            {"linear_mipmap_nearest" , osg::Texture::LINEAR_MIPMAP_NEAREST},
+            {"nearest"               , osg::Texture::NEAREST},
+            {"nearest_mipmap_linear" , osg::Texture::NEAREST_MIPMAP_LINEAR},
+            {"nearest_mipmap_nearest", osg::Texture::NEAREST_MIPMAP_NEAREST}
+        }};
+
+        constexpr std::array<std::pair<std::string_view, osg::BlendFunc::BlendFuncMode>, 15> BlendFunc = {{
+            {"dst_alpha"                , osg::BlendFunc::DST_ALPHA},
+            {"dst_color"                , osg::BlendFunc::DST_COLOR},
+            {"one"                      , osg::BlendFunc::ONE},
+            {"one_minus_dst_alpha"      , osg::BlendFunc::ONE_MINUS_DST_ALPHA},
+            {"one_minus_dst_color"      , osg::BlendFunc::ONE_MINUS_DST_COLOR},
+            {"one_minus_src_alpha"      , osg::BlendFunc::ONE_MINUS_SRC_ALPHA},
+            {"one_minus_src_color"      , osg::BlendFunc::ONE_MINUS_SRC_COLOR},
+            {"src_alpha"                , osg::BlendFunc::SRC_ALPHA},
+            {"src_alpha_saturate"       , osg::BlendFunc::SRC_ALPHA_SATURATE},
+            {"src_color"                , osg::BlendFunc::SRC_COLOR},
+            {"constant_color"           , osg::BlendFunc::CONSTANT_COLOR},
+            {"one_minus_constant_color" , osg::BlendFunc::ONE_MINUS_CONSTANT_COLOR},
+            {"constant_alpha"           , osg::BlendFunc::CONSTANT_ALPHA},
+            {"one_minus_constant_alpha" , osg::BlendFunc::ONE_MINUS_CONSTANT_ALPHA},
+            {"zero"                     , osg::BlendFunc::ZERO}
+        }};
+
+        constexpr std::array<std::pair<std::string_view, osg::BlendEquation::Equation>, 8> BlendEquation = {{
+            {"rgba_min"             , osg::BlendEquation::RGBA_MIN},
+            {"rgba_max"             , osg::BlendEquation::RGBA_MAX},
+            {"alpha_min"            , osg::BlendEquation::ALPHA_MIN},
+            {"alpha_max"            , osg::BlendEquation::ALPHA_MAX},
+            {"logic_op"             , osg::BlendEquation::LOGIC_OP},
+            {"add"                  , osg::BlendEquation::FUNC_ADD},
+            {"subtract"             , osg::BlendEquation::FUNC_SUBTRACT},
+            {"reverse_subtract"     , osg::BlendEquation::FUNC_REVERSE_SUBTRACT}
+        }};
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/components/fx/pass.cpp b/components/fx/pass.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..246221eb8448fd4b95ef8e6202080f540f6082fb
--- /dev/null
+++ b/components/fx/pass.cpp
@@ -0,0 +1,283 @@
+#include "pass.hpp"
+
+#include <unordered_set>
+#include <string>
+#include <sstream>
+
+#include <osg/Program>
+#include <osg/Shader>
+#include <osg/State>
+#include <osg/StateSet>
+#include <osg/BindImageTexture>
+#include <osg/FrameBufferObject>
+
+#include <components/misc/stringops.hpp>
+#include <components/sceneutil/util.hpp>
+#include <components/sceneutil/lightmanager.hpp>
+#include <components/sceneutil/clearcolor.hpp>
+#include <components/resource/scenemanager.hpp>
+#include <components/stereo/multiview.hpp>
+
+#include "technique.hpp"
+#include "stateupdater.hpp"
+
+namespace
+{
+    constexpr char s_DefaultVertex[] = R"GLSL(
+#if OMW_USE_BINDINGS
+    omw_In vec2 omw_Vertex;
+#endif
+omw_Out vec2 omw_TexCoord;
+
+void main()
+{
+    omw_Position = vec4(omw_Vertex.xy, 0.0, 1.0);
+    omw_TexCoord = omw_Position.xy * 0.5 + 0.5;
+})GLSL";
+
+}
+
+namespace fx
+{
+    Pass::Pass(Pass::Type type, Pass::Order order, bool ubo)
+        : mCompiled(false)
+        , mType(type)
+        , mOrder(order)
+        , mLegacyGLSL(true)
+        , mUBO(ubo)
+    {
+    }
+
+    std::string Pass::getPassHeader(Technique& technique, std::string_view preamble, bool fragOut)
+    {
+        std::string header = R"GLSL(
+#version @version @profile
+@extensions
+
+@uboStruct
+
+#define OMW_REVERSE_Z @reverseZ
+#define OMW_RADIAL_FOG @radialFog
+#define OMW_HDR @hdr
+#define OMW_NORMALS @normals
+#define OMW_USE_BINDINGS @useBindings
+#define OMW_MULTIVIEW @multiview
+#define omw_In @in
+#define omw_Out @out
+#define omw_Position @position
+#define omw_Texture1D @texture1D
+#define omw_Texture2D @texture2D
+#define omw_Texture3D @texture3D
+#define omw_Vertex @vertex
+#define omw_FragColor @fragColor
+
+@fragBinding
+
+uniform @builtinSampler omw_SamplerLastShader;
+uniform @builtinSampler omw_SamplerLastPass;
+uniform highp @builtinSampler omw_SamplerDepth;
+uniform @builtinSampler omw_SamplerNormals;
+
+uniform vec4 omw_PointLights[@pointLightCount];
+uniform int omw_PointLightsCount;
+
+int omw_GetPointLightCount()
+{
+    return omw_PointLightsCount;
+}
+
+vec3 omw_GetPointLightViewPos(int index)
+{
+    return omw_PointLights[(index * 3)].xyz;
+}
+
+vec3 omw_GetPointLightDiffuse(int index)
+{
+    return omw_PointLights[(index * 3) + 1].xyz;
+}
+
+vec3 omw_GetPointLightAttenuation(int index)
+{
+    return omw_PointLights[(index * 3) + 2].xyz;
+}
+
+float omw_GetPointLightRadius(int index)
+{
+    return omw_PointLights[(index * 3) + 2].w;
+}
+
+#if @ubo
+    layout(std140) uniform _data { _omw_data omw; };
+#else
+    uniform _omw_data omw;
+#endif
+
+    float omw_GetDepth(vec2 uv)
+    {
+#if OMW_MULTIVIEW
+        float depth = omw_Texture2D(omw_SamplerDepth, vec3(uv, gl_ViewID_OVR)).r;
+#else
+        float depth = omw_Texture2D(omw_SamplerDepth, uv).r;
+#endif
+#if OMW_REVERSE_Z
+        return 1.0 - depth;
+#else
+        return depth;
+#endif
+    }
+
+    vec4 omw_GetLastShader(vec2 uv)
+    {
+#if OMW_MULTIVIEW
+        return omw_Texture2D(omw_SamplerLastShader, vec3(uv, gl_ViewID_OVR));
+#else
+        return omw_Texture2D(omw_SamplerLastShader, uv);
+#endif
+    }
+
+    vec4 omw_GetLastPass(vec2 uv)
+    {
+#if OMW_MULTIVIEW
+        return omw_Texture2D(omw_SamplerLastPass, vec3(uv, gl_ViewID_OVR));
+#else
+        return omw_Texture2D(omw_SamplerLastPass, uv);
+#endif
+    }
+
+    vec3 omw_GetNormals(vec2 uv)
+    {
+#if OMW_MULTIVIEW
+        return omw_Texture2D(omw_SamplerNormals, vec3(uv, gl_ViewID_OVR)).rgb * 2.0 - 1.0;
+#else
+        return omw_Texture2D(omw_SamplerNormals, uv).rgb * 2.0 - 1.0;
+#endif
+    }
+
+#if OMW_HDR
+    uniform sampler2D omw_EyeAdaptation;
+#endif
+
+    float omw_GetEyeAdaptation()
+    {
+#if OMW_HDR
+        return omw_Texture2D(omw_EyeAdaptation, vec2(0.5, 0.5)).r;
+#else
+        return 1.0;
+#endif
+    }
+)GLSL";
+
+        std::stringstream extBlock;
+        for (const auto& extension : technique.getGLSLExtensions())
+            extBlock << "#ifdef " << extension << '\n' << "\t#extension " << extension << ": enable" << '\n' << "#endif" << '\n';
+
+        const std::vector<std::pair<std::string,std::string>> defines = {
+            {"@pointLightCount", std::to_string(SceneUtil::PPLightBuffer::sMaxPPLightsArraySize)},
+            {"@version", std::to_string(technique.getGLSLVersion())},
+            {"@multiview", Stereo::getMultiview() ? "1" : "0"},
+            {"@builtinSampler", Stereo::getMultiview() ? "sampler2DArray" : "sampler2D"},
+            {"@profile", technique.getGLSLProfile()},
+            {"@extensions", extBlock.str()},
+            {"@uboStruct", StateUpdater::getStructDefinition()},
+            {"@ubo", mUBO ? "1" : "0"},
+            {"@normals", technique.getNormals() ? "1" : "0"},
+            {"@reverseZ", SceneUtil::AutoDepth::isReversed() ? "1" : "0"},
+            {"@radialFog", Settings::Manager::getBool("radial fog", "Shaders") ? "1" : "0"},
+            {"@hdr", technique.getHDR() ? "1" : "0"},
+            {"@in", mLegacyGLSL ? "varying" : "in"},
+            {"@out", mLegacyGLSL ? "varying" : "out"},
+            {"@position", "gl_Position"},
+            {"@texture1D", mLegacyGLSL ? "texture1D" : "texture"},
+            {"@texture2D", mLegacyGLSL ? "texture2D" : "texture"},
+            {"@texture3D", mLegacyGLSL ? "texture3D" : "texture"},
+            {"@vertex", mLegacyGLSL ? "gl_Vertex" : "_omw_Vertex"},
+            {"@fragColor", mLegacyGLSL ? "gl_FragColor" : "_omw_FragColor"},
+            {"@useBindings", mLegacyGLSL ? "0" : "1"},
+            {"@fragBinding", mLegacyGLSL ? "" : "out vec4 omw_FragColor;"}
+        };
+
+        for (const auto& [define, value]: defines)
+            for (size_t pos = header.find(define); pos != std::string::npos; pos = header.find(define))
+                header.replace(pos, define.size(), value);
+
+        for (auto& uniform : technique.getUniformMap())
+            if (auto glsl = uniform->getGLSL())
+                header.append(glsl.value());
+
+        header.append(preamble);
+
+        return header;
+    }
+
+    void Pass::prepareStateSet(osg::StateSet* stateSet, const std::string& name) const
+    {
+        osg::ref_ptr<osg::Program> program = new osg::Program;
+        if (mType == Type::Pixel)
+        {
+            program->addShader(new osg::Shader(*mVertex));
+            program->addShader(new osg::Shader(*mFragment));
+        }
+        else if (mType == Type::Compute)
+        {
+            program->addShader(new osg::Shader(*mCompute));
+        }
+
+        if (mUBO)
+            program->addBindUniformBlock("_data", static_cast<int>(Resource::SceneManager::UBOBinding::PostProcessor));
+
+        program->setName(name);
+
+        if (!mLegacyGLSL)
+        {
+            program->addBindFragDataLocation("_omw_FragColor", 0);
+            program->addBindAttribLocation("_omw_Vertex", 0);
+        }
+
+        stateSet->setAttribute(program);
+
+        if (mBlendSource && mBlendDest)
+            stateSet->setAttribute(new osg::BlendFunc(mBlendSource.value(), mBlendDest.value()));
+
+        if (mBlendEq)
+            stateSet->setAttribute(new osg::BlendEquation(mBlendEq.value()));
+
+        if (mClearColor)
+            stateSet->setAttribute(new SceneUtil::ClearColor(mClearColor.value(), GL_COLOR_BUFFER_BIT));
+    }
+
+    void Pass::dirty()
+    {
+        mVertex = nullptr;
+        mFragment = nullptr;
+        mCompute = nullptr;
+        mCompiled = false;
+    }
+
+    void Pass::compile(Technique& technique, std::string_view preamble)
+    {
+        if (mCompiled)
+            return;
+
+        mLegacyGLSL = technique.getGLSLVersion() != 330;
+
+        if (mType == Type::Pixel)
+        {
+            if (!mVertex)
+                mVertex = new osg::Shader(osg::Shader::VERTEX, s_DefaultVertex);
+
+            mVertex->setShaderSource(getPassHeader(technique, preamble).append(mVertex->getShaderSource()));
+            mFragment->setShaderSource(getPassHeader(technique, preamble, true).append(mFragment->getShaderSource()));
+
+            mVertex->setName(mName);
+            mFragment->setName(mName);
+        }
+        else if (mType == Type::Compute)
+        {
+            mCompute->setShaderSource(getPassHeader(technique, preamble).append(mCompute->getShaderSource()));
+            mCompute->setName(mName);
+        }
+
+        mCompiled = true;
+    }
+
+}
diff --git a/components/fx/pass.hpp b/components/fx/pass.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..bd13c3f99baab7676d0a4f545b4ec00846c1e7d1
--- /dev/null
+++ b/components/fx/pass.hpp
@@ -0,0 +1,79 @@
+#ifndef OPENMW_COMPONENTS_FX_PASS_H
+#define OPENMW_COMPONENTS_FX_PASS_H
+
+#include <array>
+#include <string>
+#include <sstream>
+#include <cstdint>
+#include <unordered_set>
+#include <optional>
+
+#include <osg/Timer>
+#include <osg/Program>
+#include <osg/Shader>
+#include <osg/State>
+#include <osg/Texture2D>
+#include <osg/BlendEquation>
+#include <osg/BlendFunc>
+
+namespace fx
+{
+    class Technique;
+
+    class Pass
+    {
+    public:
+
+        enum class Order
+        {
+            Forward,
+            Post
+        };
+
+        enum class Type
+        {
+            None,
+            Pixel,
+            Compute
+        };
+
+        friend class Technique;
+
+        Pass(Type type=Type::Pixel, Order order=Order::Post, bool ubo = false);
+
+        void compile(Technique& technique, std::string_view preamble);
+
+        std::string_view getTarget() const { return mTarget; }
+
+        void prepareStateSet(osg::StateSet* stateSet, const std::string& name) const;
+
+        std::string getName() const { return mName; }
+
+        void dirty();
+
+    private:
+        std::string getPassHeader(Technique& technique, std::string_view preamble, bool fragOut = false);
+
+        bool mCompiled;
+
+        osg::ref_ptr<osg::Shader> mVertex;
+        osg::ref_ptr<osg::Shader> mFragment;
+        osg::ref_ptr<osg::Shader> mCompute;
+
+        Type mType;
+        Order mOrder;
+        std::string mName;
+        bool mLegacyGLSL;
+        bool mUBO;
+        bool mSupportsNormals;
+
+        std::string_view mTarget;
+        std::optional<osg::Vec4f> mClearColor;
+
+        std::optional<osg::BlendFunc::BlendFuncMode> mBlendSource;
+        std::optional<osg::BlendFunc::BlendFuncMode> mBlendDest;
+        std::optional<osg::BlendEquation::Equation> mBlendEq;
+    };
+}
+
+#endif
diff --git a/components/fx/stateupdater.cpp b/components/fx/stateupdater.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..36362e07a4bfc9ae47104dda08b2ab89b6add374
--- /dev/null
+++ b/components/fx/stateupdater.cpp
@@ -0,0 +1,63 @@
+#include "stateupdater.hpp"
+
+#include <osg/BufferObject>
+#include <osg/BufferIndexBinding>
+
+#include <components/resource/scenemanager.hpp>
+#include <components/debug/debuglog.hpp>
+
+namespace fx
+{
+    StateUpdater::StateUpdater(bool useUBO) : mUseUBO(useUBO) {}
+
+    void StateUpdater::setDefaults(osg::StateSet* stateset)
+    {
+        if (mUseUBO)
+        {
+            osg::ref_ptr<osg::UniformBufferObject> ubo = new osg::UniformBufferObject;
+
+            osg::ref_ptr<osg::BufferTemplate<UniformData::BufferType>> data = new osg::BufferTemplate<UniformData::BufferType>();
+            data->setBufferObject(ubo);
+
+            osg::ref_ptr<osg::UniformBufferBinding> ubb = new osg::UniformBufferBinding(static_cast<int>(Resource::SceneManager::UBOBinding::PostProcessor), data, 0, mData.getGPUSize());
+
+            stateset->setAttributeAndModes(ubb, osg::StateAttribute::ON);
+        }
+        else
+        {
+            const auto createUniform = [&] (const auto& v) {
+                using T = std::decay_t<decltype(v)>;
+                std::string name = "omw." + std::string(T::sName);
+                stateset->addUniform(new osg::Uniform(name.c_str(), mData.get<T>()));
+            };
+
+            std::apply([&] (const auto& ... v) { (createUniform(v) , ...); }, mData.getData());
+        }
+    }
+
+    void StateUpdater::apply(osg::StateSet* stateset, osg::NodeVisitor* nv)
+    {
+        if (mUseUBO)
+        {
+            osg::UniformBufferBinding* ubb = dynamic_cast<osg::UniformBufferBinding*>(stateset->getAttribute(osg::StateAttribute::UNIFORMBUFFERBINDING, static_cast<int>(Resource::SceneManager::UBOBinding::PostProcessor)));
+
+            auto& dest = static_cast<osg::BufferTemplate<UniformData::BufferType>*>(ubb->getBufferData())->getData();
+            mData.copyTo(dest);
+
+            ubb->getBufferData()->dirty();
+        }
+        else
+        {
+            const auto setUniform = [&] (const auto& v) {
+                using T = std::decay_t<decltype(v)>;
+                std::string name = "omw." + std::string(T::sName);
+                stateset->getUniform(name)->set(mData.get<T>());
+            };
+
+            std::apply([&] (const auto& ... v) { (setUniform(v) , ...); }, mData.getData());
+        }
+
+        if (mPointLightBuffer)
+            mPointLightBuffer->applyUniforms(nv->getTraversalNumber(), stateset);
+    }
+}
\ No newline at end of file
diff --git a/components/fx/stateupdater.hpp b/components/fx/stateupdater.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..8b181729d147ab5efb096194a3c00010eeffae83
--- /dev/null
+++ b/components/fx/stateupdater.hpp
@@ -0,0 +1,200 @@
+#ifndef OPENMW_COMPONENTS_FX_STATEUPDATER_H
+#define OPENMW_COMPONENTS_FX_STATEUPDATER_H
+
+#include <osg/BufferTemplate>
+
+#include <components/sceneutil/lightmanager.hpp>
+#include <components/sceneutil/statesetupdater.hpp>
+#include <components/std140/ubo.hpp>
+
+namespace fx
+{
+    class StateUpdater : public SceneUtil::StateSetUpdater
+    {
+    public:
+        StateUpdater(bool useUBO);
+
+        void setProjectionMatrix(const osg::Matrixf& matrix)
+        {
+            mData.get<ProjectionMatrix>() = matrix;
+            mData.get<InvProjectionMatrix>() = osg::Matrixf::inverse(matrix);
+        }
+
+        void setViewMatrix(const osg::Matrixf& matrix) { mData.get<ViewMatrix>() = matrix; }
+
+        void setInvViewMatrix(const osg::Matrixf& matrix) { mData.get<InvViewMatrix>() = matrix; }
+
+        void setPrevViewMatrix(const osg::Matrixf& matrix) { mData.get<PrevViewMatrix>() = matrix;}
+
+        void setEyePos(const osg::Vec3f& pos) { mData.get<EyePos>() = osg::Vec4f(pos, 0.f); }
+
+        void setEyeVec(const osg::Vec3f& vec) { mData.get<EyeVec>() = osg::Vec4f(vec, 0.f); }
+
+        void setFogColor(const osg::Vec4f& color) { mData.get<FogColor>() = color; }
+
+        void setSunColor(const osg::Vec4f& color) { mData.get<SunColor>() = color; }
+
+        void setSunPos(const osg::Vec4f& pos, bool night)
+        {
+            mData.get<SunPos>() = pos;
+
+            if (night)
+                mData.get<SunPos>().z() *= -1.f;
+        }
+
+        void setResolution(const osg::Vec2f& size)
+        {
+            mData.get<Resolution>() = size;
+            mData.get<RcpResolution>() = {1.f / size.x(), 1.f / size.y()};
+        }
+
+        void setSunVis(float vis)
+        {
+            mData.get<SunVis>() = vis;
+        }
+
+        void setFogRange(float near, float far)
+        {
+            mData.get<FogNear>() = near;
+            mData.get<FogFar>() = far;
+        }
+
+        void setNearFar(float near, float far)
+        {
+            mData.get<Near>() = near;
+            mData.get<Far>() = far;
+        }
+
+        void setIsUnderwater(bool underwater) { mData.get<IsUnderwater>() = underwater; }
+
+        void setIsInterior(bool interior) { mData.get<IsInterior>() = interior; }
+
+        void setFov(float fov) { mData.get<Fov>() = fov; }
+
+        void setGameHour(float hour) { mData.get<GameHour>() = hour; }
+
+        void setWeatherId(int id) { mData.get<WeatherID>() = id; }
+
+        void setNextWeatherId(int id) { mData.get<NextWeatherID>() = id; }
+
+        void setWaterHeight(float height) { mData.get<WaterHeight>() = height; }
+
+        void setSimulationTime(float time) { mData.get<SimulationTime>() = time; }
+
+        void setDeltaSimulationTime(float time) { mData.get<DeltaSimulationTime>() = time; }
+
+        void setWindSpeed(float speed) { mData.get<WindSpeed>() = speed; }
+
+        void setWeatherTransition(float transition) { mData.get<WeatherTransition>() = transition; }
+
+        void bindPointLights(std::shared_ptr<SceneUtil::PPLightBuffer> buffer)
+        {
+            mPointLightBuffer = buffer;
+        }
+
+        static std::string getStructDefinition()
+        {
+            static std::string definition = UniformData::getDefinition("_omw_data");
+            return definition;
+        }
+
+        void setDefaults(osg::StateSet* stateset) override;
+
+        void apply(osg::StateSet* stateset, osg::NodeVisitor* nv) override;
+
+    private:
+        struct ProjectionMatrix : std140::Mat4 { static constexpr std::string_view sName = "projectionMatrix"; };
+
+        struct InvProjectionMatrix : std140::Mat4 { static constexpr std::string_view sName = "invProjectionMatrix"; };
+
+        struct ViewMatrix : std140::Mat4 { static constexpr std::string_view sName = "viewMatrix"; };
+
+        struct PrevViewMatrix : std140::Mat4 { static constexpr std::string_view sName = "prevViewMatrix"; };
+
+        struct InvViewMatrix : std140::Mat4 { static constexpr std::string_view sName = "invViewMatrix"; };
+
+        struct EyePos : std140::Vec4 { static constexpr std::string_view sName = "eyePos"; };
+
+        struct EyeVec : std140::Vec4 { static constexpr std::string_view sName = "eyeVec"; };
+
+        struct FogColor : std140::Vec4 { static constexpr std::string_view sName = "fogColor"; };
+
+        struct SunColor : std140::Vec4 { static constexpr std::string_view sName = "sunColor"; };
+
+        struct SunPos : std140::Vec4 { static constexpr std::string_view sName = "sunPos"; };
+
+        struct Resolution : std140::Vec2 { static constexpr std::string_view sName = "resolution"; };
+
+        struct RcpResolution : std140::Vec2 { static constexpr std::string_view sName = "rcpResolution"; };
+
+        struct FogNear : std140::Float { static constexpr std::string_view sName = "fogNear"; };
+
+        struct FogFar : std140::Float { static constexpr std::string_view sName = "fogFar"; };
+
+        struct Near : std140::Float { static constexpr std::string_view sName = "near"; };
+
+        struct Far : std140::Float { static constexpr std::string_view sName = "far"; };
+
+        struct Fov : std140::Float { static constexpr std::string_view sName = "fov"; };
+
+        struct GameHour : std140::Float { static constexpr std::string_view sName = "gameHour"; };
+
+        struct SunVis : std140::Float { static constexpr std::string_view sName = "sunVis"; };
+
+        struct WaterHeight : std140::Float { static constexpr std::string_view sName = "waterHeight"; };
+
+        struct SimulationTime : std140::Float { static constexpr std::string_view sName = "simulationTime"; };
+
+        struct DeltaSimulationTime : std140::Float { static constexpr std::string_view sName = "deltaSimulationTime"; };
+
+        struct WindSpeed : std140::Float { static constexpr std::string_view sName = "windSpeed"; };
+
+        struct WeatherTransition : std140::Float { static constexpr std::string_view sName = "weatherTransition"; };
+
+        struct WeatherID : std140::Int { static constexpr std::string_view sName = "weatherID"; };
+
+        struct NextWeatherID : std140::Int { static constexpr std::string_view sName = "nextWeatherID"; };
+
+        struct IsUnderwater : std140::Bool { static constexpr std::string_view sName = "isUnderwater"; };
+
+        struct IsInterior : std140::Bool { static constexpr std::string_view sName = "isInterior"; };
+
+        using UniformData = std140::UBO<
+            ProjectionMatrix,
+            InvProjectionMatrix,
+            ViewMatrix,
+            PrevViewMatrix,
+            InvViewMatrix,
+            EyePos,
+            EyeVec,
+            FogColor,
+            SunColor,
+            SunPos,
+            Resolution,
+            RcpResolution,
+            FogNear,
+            FogFar,
+            Near,
+            Far,
+            Fov,
+            GameHour,
+            SunVis,
+            WaterHeight,
+            SimulationTime,
+            DeltaSimulationTime,
+            WindSpeed,
+            WeatherTransition,
+            WeatherID,
+            NextWeatherID,
+            IsUnderwater,
+            IsInterior
+        >;
+
+        UniformData mData;
+        bool mUseUBO;
+
+        std::shared_ptr<SceneUtil::PPLightBuffer> mPointLightBuffer;
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/components/fx/technique.cpp b/components/fx/technique.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..c186f12c0c1cb96512b5e8adc185c88eb05d78d9
--- /dev/null
+++ b/components/fx/technique.cpp
@@ -0,0 +1,1052 @@
+#include "technique.hpp"
+
+#include <array>
+#include <string>
+
+#include <osg/Texture1D>
+#include <osg/Texture2D>
+#include <osg/Texture3D>
+#include <osg/CullStack>
+
+#include <SDL_opengl_glext.h>
+
+#include <components/vfs/manager.hpp>
+#include <components/stereo/multiview.hpp>
+#include <components/misc/stringops.hpp>
+#include <components/sceneutil/util.hpp>
+#include <components/resource/imagemanager.hpp>
+#include <components/debug/debuglog.hpp>
+
+#include "parse_constants.hpp"
+
+namespace
+{
+    struct ProxyTextureData
+    {
+        osg::Texture::WrapMode wrap_s = osg::Texture::CLAMP_TO_EDGE;
+        osg::Texture::WrapMode wrap_t = osg::Texture::CLAMP_TO_EDGE;
+        osg::Texture::WrapMode wrap_r = osg::Texture::CLAMP_TO_EDGE;
+        osg::Texture::FilterMode min_filter = osg::Texture::LINEAR_MIPMAP_LINEAR;
+        osg::Texture::FilterMode mag_filter =osg::Texture::LINEAR;
+        osg::Texture::InternalFormatMode compression = osg::Texture::USE_IMAGE_DATA_FORMAT;
+        std::optional<int> source_format;
+        std::optional<int> source_type;
+        std::optional<int> internal_format;
+    };
+}
+
+namespace fx
+{
+    Technique::Technique(const VFS::Manager& vfs, Resource::ImageManager& imageManager, const std::string& name, int width, int height, bool ubo, bool supportsNormals)
+        : mName(name)
+        , mFileName((std::filesystem::path(Technique::sSubdir) / (mName + Technique::sExt)).string())
+        , mLastModificationTime(std::filesystem::file_time_type())
+        , mWidth(width)
+        , mHeight(height)
+        , mVFS(vfs)
+        , mImageManager(imageManager)
+        , mUBO(ubo)
+        , mSupportsNormals(supportsNormals)
+    {
+        clear();
+    }
+
+    void Technique::clear()
+    {
+        mTextures.clear();
+        mStatus = Status::Uncompiled;
+        mDirty = false;
+        mValid = false;
+        mHDR = false;
+        mNormals = false;
+        mLights = false;
+        mEnabled = true;
+        mPassMap.clear();
+        mPasses.clear();
+        mPassKeys.clear();
+        mDefinedUniforms.clear();
+        mRenderTargets.clear();
+        mMainTemplate = nullptr;
+        mLastAppliedType = Pass::Type::None;
+        mFlags = 0;
+        mShared.clear();
+        mAuthor = {};
+        mDescription = {};
+        mVersion = {};
+        mGLSLExtensions.clear();
+        mGLSLVersion = mUBO ? 330 : 120;
+        mGLSLProfile.clear();
+    }
+
+    std::string Technique::getBlockWithLineDirective()
+    {
+        auto block = mLexer->getLastJumpBlock();
+        std::string content = std::string(block.content);
+
+        content = "\n#line " + std::to_string(block.line + 1) + "\n"  + std::string(block.content) + "\n";
+        return content;
+    }
+
+    Technique::UniformMap::iterator Technique::findUniform(const std::string& name)
+    {
+        return std::find_if(mDefinedUniforms.begin(), mDefinedUniforms.end(), [&name](const auto& uniform)
+        {
+            return uniform->mName == name;
+        });
+    }
+
+    bool Technique::compile()
+    {
+        clear();
+
+        if (!mVFS.exists(mFileName))
+        {
+            Log(Debug::Error) << "Could not load technique, file does not exist '" << mFileName << "'";
+
+            mStatus = Status::File_Not_exists;
+            return false;
+        }
+
+        try
+        {
+            std::string source(std::istreambuf_iterator<char>(*mVFS.get(getFileName())), {});
+
+            parse(std::move(source));
+
+            if (mPassKeys.empty())
+                error("no pass list found, ensure you define one in a 'technique' block");
+
+            int swaps = 0;
+
+            for (auto name : mPassKeys)
+            {
+                auto it = mPassMap.find(name);
+
+                if (it == mPassMap.end())
+                    error(Misc::StringUtils::format("pass '%s' was found in the pass list, but there was no matching 'fragment', 'vertex' or 'compute' block", std::string(name)));
+
+                if (mLastAppliedType != Pass::Type::None && mLastAppliedType != it->second->mType)
+                {
+                    swaps++;
+                    if (swaps == 2)
+                        Log(Debug::Warning) << "compute and pixel shaders are being swapped multiple times in shader chain, this can lead to serious performance drain.";
+                }
+                else
+                    mLastAppliedType = it->second->mType;
+
+                if (Stereo::getMultiview())
+                {
+                    mGLSLExtensions.insert("GL_OVR_multiview");
+                    mGLSLExtensions.insert("GL_OVR_multiview2");
+                    mGLSLExtensions.insert("GL_EXT_texture_array");
+                }
+
+                it->second->compile(*this, mShared);
+
+                if (!it->second->mTarget.empty())
+                {
+                    auto rtIt = mRenderTargets.find(it->second->mTarget);
+                    if (rtIt == mRenderTargets.end())
+                        error(Misc::StringUtils::format("target '%s' not defined", std::string(it->second->mTarget)));
+                }
+
+                mPasses.emplace_back(it->second);
+            }
+
+            if (mPasses.empty())
+                error("invalid pass list, no passes defined for technique");
+
+            mValid = true;
+        }
+        catch(const std::runtime_error& e)
+        {
+            clear();
+            mStatus = Status::Parse_Error;
+
+            mLastError = "Failed parsing technique '" + getName() + "' "  + e.what();;
+            Log(Debug::Error) << mLastError;
+        }
+
+        return mValid;
+    }
+
+    std::string Technique::getName() const
+    {
+        return mName;
+    }
+
+    std::string Technique::getFileName() const
+    {
+        return mFileName;
+    }
+
+    void Technique::setLastModificationTime(std::filesystem::file_time_type timeStamp, bool dirty)
+    {
+        if (dirty && mLastModificationTime != timeStamp)
+            mDirty = true;
+
+        mLastModificationTime = timeStamp;
+    }
+
+    [[noreturn]] void Technique::error(const std::string& msg)
+    {
+        mLexer->error(msg);
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Shared>()
+    {
+        if (!mLexer->jump())
+            error(Misc::StringUtils::format("unterminated 'shared' block, expected closing brackets"));
+
+        if (!mShared.empty())
+            error("repeated 'shared' block, only one allowed per technique file");
+
+        mShared = getBlockWithLineDirective();
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Technique>()
+    {
+        if (!mPassKeys.empty())
+            error("exactly one 'technique' block can appear per file");
+
+        while (!isNext<Lexer::Close_bracket>() && !isNext<Lexer::Eof>())
+        {
+            expect<Lexer::Literal>();
+
+            auto key = std::get<Lexer::Literal>(mToken).value;
+
+            expect<Lexer::Equal>();
+
+            if (key == "passes")
+                mPassKeys = parseLiteralList<Lexer::Comma>();
+            else if (key == "version")
+                mVersion = parseString();
+            else if (key == "description")
+                mDescription = parseString();
+            else if (key == "author")
+                mAuthor = parseString();
+            else if (key == "glsl_version")
+            {
+                int version = parseInteger();
+                if (mUBO && version > 330)
+                    mGLSLVersion = version;
+            }
+            else if (key == "flags")
+                mFlags = parseFlags();
+            else if (key == "hdr")
+                mHDR = parseBool();
+            else if (key == "pass_normals")
+                mNormals = parseBool() && mSupportsNormals;
+            else if (key == "pass_lights")
+                mLights = parseBool();
+            else if (key == "glsl_profile")
+            {
+                expect<Lexer::String>();
+                mGLSLProfile = std::string(std::get<Lexer::String>(mToken).value);
+            }
+            else if (key == "glsl_extensions")
+            {
+                for (const auto& ext : parseLiteralList<Lexer::Comma>())
+                    mGLSLExtensions.emplace(ext);
+            }
+            else
+                error(Misc::StringUtils::format("unexpected key '%s'", std::string{key}));
+
+            expect<Lexer::SemiColon>();
+        }
+
+        if (mPassKeys.empty())
+            error("pass list in 'technique' block cannot be empty.");
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Main_Pass>()
+    {
+        if (mMainTemplate)
+            error("duplicate 'main_pass' block");
+
+        if (mName != "main")
+            error("'main_pass' block can only be defined in the 'main.omwfx' technique file");
+
+        mMainTemplate = new osg::Texture2D;
+
+        mMainTemplate->setFilter(osg::Texture::MIN_FILTER, osg::Texture::LINEAR);
+        mMainTemplate->setFilter(osg::Texture::MAG_FILTER, osg::Texture::LINEAR);
+
+        while (!isNext<Lexer::Close_bracket>() && !isNext<Lexer::Eof>())
+        {
+            expect<Lexer::Literal>();
+
+            auto key = std::get<Lexer::Literal>(mToken).value;
+
+            expect<Lexer::Equal>();
+
+            if (key == "wrap_s")
+                mMainTemplate->setWrap(osg::Texture::WRAP_S, parseWrapMode());
+            else if (key == "wrap_t")
+                mMainTemplate->setWrap(osg::Texture::WRAP_T, parseWrapMode());
+            // Skip depth attachments for main scene, as some engine settings rely on specific depth formats.
+            // Allowing this to be overriden will cause confusion.
+            else if (key == "internal_format")
+                mMainTemplate->setInternalFormat(parseInternalFormat());
+            else if (key == "source_type")
+                mMainTemplate->setSourceType(parseSourceType());
+            else if (key == "source_format")
+                mMainTemplate->setSourceFormat(parseSourceFormat());
+            else
+                error(Misc::StringUtils::format("unexpected key '%s'", std::string(key)));
+
+            expect<Lexer::SemiColon>();
+        }
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Render_Target>()
+    {
+        if (mRenderTargets.count(mBlockName))
+            error(Misc::StringUtils::format("redeclaration of render target '%s'", std::string(mBlockName)));
+
+        fx::Types::RenderTarget rt;
+        rt.mTarget->setTextureSize(mWidth, mHeight);
+        rt.mTarget->setSourceFormat(GL_RGB);
+        rt.mTarget->setInternalFormat(GL_RGB);
+        rt.mTarget->setSourceType(GL_UNSIGNED_BYTE);
+
+        while (!isNext<Lexer::Close_bracket>() && !isNext<Lexer::Eof>())
+        {
+            expect<Lexer::Literal>();
+
+            auto key = std::get<Lexer::Literal>(mToken).value;
+
+            expect<Lexer::Equal>();
+
+            if (key == "min_filter")
+                rt.mTarget->setFilter(osg::Texture2D::MIN_FILTER, parseFilterMode());
+            else if (key == "mag_filter")
+                rt.mTarget->setFilter(osg::Texture2D::MAG_FILTER, parseFilterMode());
+            else if (key == "wrap_s")
+                rt.mTarget->setWrap(osg::Texture2D::WRAP_S, parseWrapMode());
+            else if (key == "wrap_t")
+                rt.mTarget->setWrap(osg::Texture2D::WRAP_T, parseWrapMode());
+            else if (key == "width_ratio")
+                rt.mSize.mWidthRatio = parseFloat();
+            else if (key == "height_ratio")
+                rt.mSize.mHeightRatio = parseFloat();
+            else if (key == "width")
+                rt.mSize.mWidth = parseInteger();
+            else if (key == "height")
+                rt.mSize.mHeight = parseInteger();
+            else if (key == "internal_format")
+                rt.mTarget->setInternalFormat(parseInternalFormat());
+            else if (key == "source_type")
+                rt.mTarget->setSourceType(parseSourceType());
+            else if (key == "source_format")
+                rt.mTarget->setSourceFormat(parseSourceFormat());
+            else if (key == "mipmaps")
+                rt.mMipMap = parseBool();
+            else
+                error(Misc::StringUtils::format("unexpected key '%s'", std::string(key)));
+
+            expect<Lexer::SemiColon>();
+        }
+
+        mRenderTargets.emplace(mBlockName, std::move(rt));
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Vertex>()
+    {
+        if (!mLexer->jump())
+            error(Misc::StringUtils::format("unterminated 'vertex' block, expected closing brackets"));
+
+        auto& pass = mPassMap[mBlockName];
+
+        if (!pass)
+            pass = std::make_shared<fx::Pass>();
+
+        pass->mName = mBlockName;
+
+        if (pass->mCompute)
+            error(Misc::StringUtils::format("'compute' block already defined. Usage is ambiguous."));
+        else if (!pass->mVertex)
+            pass->mVertex = new osg::Shader(osg::Shader::VERTEX, getBlockWithLineDirective());
+        else
+            error(Misc::StringUtils::format("duplicate vertex shader for block '%s'", std::string(mBlockName)));
+
+        pass->mType = Pass::Type::Pixel;
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Fragment>()
+    {
+        if (!mLexer->jump())
+            error(Misc::StringUtils::format("unterminated 'fragment' block, expected closing brackets"));
+
+        auto& pass = mPassMap[mBlockName];
+
+        if (!pass)
+            pass = std::make_shared<fx::Pass>();
+
+        pass->mUBO = mUBO;
+        pass->mName = mBlockName;
+
+        if (pass->mCompute)
+            error(Misc::StringUtils::format("'compute' block already defined. Usage is ambiguous."));
+        else if (!pass->mFragment)
+            pass->mFragment = new osg::Shader(osg::Shader::FRAGMENT, getBlockWithLineDirective());
+        else
+            error(Misc::StringUtils::format("duplicate vertex shader for block '%s'", std::string(mBlockName)));
+
+        pass->mType = Pass::Type::Pixel;
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Compute>()
+    {
+        if (!mLexer->jump())
+            error(Misc::StringUtils::format("unterminated 'compute' block, expected closing brackets"));
+
+        auto& pass = mPassMap[mBlockName];
+
+        if (!pass)
+            pass = std::make_shared<fx::Pass>();
+
+        pass->mName = mBlockName;
+
+        if (pass->mFragment)
+            error(Misc::StringUtils::format("'fragment' block already defined. Usage is ambiguous."));
+        else if (pass->mVertex)
+            error(Misc::StringUtils::format("'vertex' block already defined. Usage is ambiguous."));
+        else if (!pass->mFragment)
+            pass->mCompute = new osg::Shader(osg::Shader::COMPUTE, getBlockWithLineDirective());
+        else
+            error(Misc::StringUtils::format("duplicate vertex shader for block '%s'", std::string(mBlockName)));
+
+        pass->mType = Pass::Type::Compute;
+    }
+
+    template <class T>
+    void Technique::parseSampler()
+    {
+        if (findUniform(std::string(mBlockName)) != mDefinedUniforms.end())
+            error(Misc::StringUtils::format("redeclaration of uniform '%s'", std::string(mBlockName)));
+
+        ProxyTextureData proxy;
+        osg::ref_ptr<osg::Texture> sampler;
+
+        constexpr bool is1D = std::is_same_v<Lexer::Sampler_1D, T>;
+        constexpr bool is3D = std::is_same_v<Lexer::Sampler_3D, T>;
+
+        Types::SamplerType type;
+
+        while (!isNext<Lexer::Close_bracket>() && !isNext<Lexer::Eof>())
+        {
+            expect<Lexer::Literal>();
+
+            auto key = asLiteral();
+
+            expect<Lexer::Equal>();
+
+            if (!is1D && key == "min_filter")
+                proxy.min_filter = parseFilterMode();
+            else if (!is1D && key == "mag_filter")
+                proxy.mag_filter = parseFilterMode();
+            else if (key == "wrap_s")
+                proxy.wrap_s = parseWrapMode();
+            else if (key == "wrap_t")
+                proxy.wrap_t = parseWrapMode();
+            else if (is3D && key == "wrap_r")
+                proxy.wrap_r = parseWrapMode();
+            else if (key == "compression")
+                proxy.compression = parseCompression();
+            else if (key == "source_type")
+                proxy.source_type = parseSourceType();
+            else if (key == "source_format")
+                proxy.source_format = parseSourceFormat();
+            else if (key == "internal_format")
+                proxy.internal_format = parseInternalFormat();
+            else if (key == "source")
+            {
+                expect<Lexer::String>();
+                auto image = mImageManager.getImage(std::string{std::get<Lexer::String>(mToken).value}, is3D);
+                if constexpr (is1D)
+                {
+                    type = Types::SamplerType::Texture_1D;
+                    sampler = new osg::Texture1D(image);
+                }
+                else if constexpr (is3D)
+                {
+                    type = Types::SamplerType::Texture_3D;
+                    sampler = new osg::Texture3D(image);
+                }
+                else
+                {
+                    type = Types::SamplerType::Texture_2D;
+                    sampler = new osg::Texture2D(image);
+                }
+            }
+            else
+                error(Misc::StringUtils::format("unexpected key '%s'", std::string{key}));
+
+            expect<Lexer::SemiColon>();
+        }
+        if (!sampler)
+            error(Misc::StringUtils::format("%s '%s' requires a filename", std::string(T::repr), std::string{mBlockName}));
+
+        if (!is1D)
+        {
+            sampler->setFilter(osg::Texture::MIN_FILTER, proxy.min_filter);
+            sampler->setFilter(osg::Texture::MAG_FILTER, proxy.mag_filter);
+        }
+        if (is3D)
+            sampler->setWrap(osg::Texture::WRAP_R, proxy.wrap_r);
+        sampler->setWrap(osg::Texture::WRAP_S, proxy.wrap_s);
+        sampler->setWrap(osg::Texture::WRAP_T, proxy.wrap_t);
+        sampler->setInternalFormatMode(proxy.compression);
+        if (proxy.internal_format.has_value())
+            sampler->setInternalFormat(proxy.internal_format.value());
+        if (proxy.source_type.has_value())
+            sampler->setSourceType(proxy.source_type.value());
+        if (proxy.internal_format.has_value())
+            sampler->setSourceFormat(proxy.internal_format.value());
+        sampler->setName(std::string{mBlockName});
+
+        mTextures.emplace_back(sampler);
+
+        std::shared_ptr<Types::UniformBase> uniform = std::make_shared<Types::UniformBase>();
+        uniform->mSamplerType = type;
+        uniform->mName = std::string(mBlockName);
+        mDefinedUniforms.emplace_back(std::move(uniform));
+    }
+
+    template <class SrcT, class T>
+    void Technique::parseUniform()
+    {
+        if (findUniform(std::string(mBlockName)) != mDefinedUniforms.end())
+            error(Misc::StringUtils::format("redeclaration of uniform '%s'", std::string(mBlockName)));
+
+        std::shared_ptr<Types::UniformBase> uniform = std::make_shared<Types::UniformBase>();
+        Types::Uniform<SrcT> data;
+
+        while (!isNext<Lexer::Close_bracket>() && !isNext<Lexer::Eof>())
+        {
+            expect<Lexer::Literal>();
+
+            auto key = asLiteral();
+
+            expect<Lexer::Equal>("error parsing config for uniform block");
+
+            constexpr bool isVec = std::is_same_v<osg::Vec2f, SrcT> || std::is_same_v<osg::Vec3f, SrcT> || std::is_same_v<osg::Vec4f, SrcT>;
+            constexpr bool isFloat = std::is_same_v<float, SrcT>;
+            constexpr bool isInt = std::is_same_v<int, SrcT>;
+
+            std::optional<double> step;
+
+            if constexpr (isInt)
+                step = 1.0;
+
+            if (key == "default")
+            {
+                if constexpr (isVec)
+                    data.mDefault = parseVec<SrcT, T>();
+                else if constexpr (isFloat)
+                    data.mDefault = parseFloat();
+                else if constexpr (isInt)
+                    data.mDefault = parseInteger();
+                else
+                    data.mDefault = parseBool();
+            }
+            else if (key == "min")
+            {
+                if constexpr (isVec)
+                    data.mMin = parseVec<SrcT, T>();
+                else if constexpr (isFloat)
+                    data.mMin = parseFloat();
+                else if constexpr (isInt)
+                    data.mMin = parseInteger();
+                else
+                    data.mMin = parseBool();
+            }
+            else if (key == "max")
+            {
+                if constexpr (isVec)
+                    data.mMax = parseVec<SrcT, T>();
+                else if constexpr (isFloat)
+                    data.mMax = parseFloat();
+                else if constexpr (isInt)
+                    data.mMax = parseInteger();
+                else
+                    data.mMax = parseBool();
+            }
+            else if (key == "step")
+                step = parseFloat();
+            else if (key == "static")
+                uniform->mStatic = parseBool();
+            else if (key == "description")
+            {
+                expect<Lexer::String>();
+                uniform->mDescription = std::get<Lexer::String>(mToken).value;
+            }
+            else if (key == "header")
+            {
+                expect<Lexer::String>();
+                uniform->mHeader = std::get<Lexer::String>(mToken).value;
+            }
+            else
+                error(Misc::StringUtils::format("unexpected key '%s'", std::string{key}));
+
+            if (step)
+                uniform->mStep = step.value();
+
+            expect<Lexer::SemiColon>();
+        }
+
+        uniform->mName = std::string(mBlockName);
+        uniform->mData = data;
+        uniform->mTechniqueName = mName;
+
+        if (auto cached = Settings::ShaderManager::get().getValue<SrcT>(mName, uniform->mName))
+            uniform->setValue<SrcT>(cached.value());
+
+        mDefinedUniforms.emplace_back(std::move(uniform));
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Sampler_1D>()
+    {
+        parseSampler<Lexer::Sampler_1D>();
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Sampler_2D>()
+    {
+        parseSampler<Lexer::Sampler_2D>();
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Sampler_3D>()
+    {
+        parseSampler<Lexer::Sampler_3D>();
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Uniform_Bool>()
+    {
+        parseUniform<bool, bool>();
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Uniform_Float>()
+    {
+        parseUniform<float, float>();
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Uniform_Int>()
+    {
+        parseUniform<int, int>();
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Uniform_Vec2>()
+    {
+        parseUniform<osg::Vec2f, Lexer::Vec2>();
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Uniform_Vec3>()
+    {
+        parseUniform<osg::Vec3f, Lexer::Vec3>();
+    }
+
+    template<>
+    void Technique::parseBlockImp<Lexer::Uniform_Vec4>()
+    {
+        parseUniform<osg::Vec4f, Lexer::Vec4>();
+    }
+
+    template<class T>
+    void Technique::expect(const std::string& err)
+    {
+        mToken = mLexer->next();
+        if (!std::holds_alternative<T>(mToken))
+        {
+            if (err.empty())
+                error(Misc::StringUtils::format("Expected %s", std::string(T::repr)));
+            else
+                error(Misc::StringUtils::format("%s. Expected %s", err, std::string(T::repr)));
+        }
+    }
+
+    template<class T, class T2>
+    void Technique::expect(const std::string& err)
+    {
+        mToken = mLexer->next();
+        if (!std::holds_alternative<T>(mToken) && !std::holds_alternative<T2>(mToken))
+        {
+            if (err.empty())
+                error(Misc::StringUtils::format("%s. Expected %s or %s", err, std::string(T::repr), std::string(T2::repr)));
+            else
+                error(Misc::StringUtils::format("Expected %s or %s", std::string(T::repr), std::string(T2::repr)));
+        }
+    }
+
+    template <class T>
+    bool Technique::isNext()
+    {
+        return std::holds_alternative<T>(mLexer->peek());
+    }
+
+    void Technique::parse(std::string&& buffer)
+    {
+        mBuffer = std::move(buffer);
+        Misc::StringUtils::replaceAll(mBuffer, "\r\n", "\n");
+        mLexer = std::make_unique<Lexer::Lexer>(mBuffer);
+
+        for (auto t = mLexer->next(); !std::holds_alternative<Lexer::Eof>(t); t = mLexer->next())
+        {
+            std::visit([=](auto&& arg) {
+                using T = std::decay_t<decltype(arg)>;
+
+                if constexpr (std::is_same_v<Lexer::Shared, T>)
+                    parseBlock<Lexer::Shared>(false);
+                else if constexpr (std::is_same_v<Lexer::Technique, T>)
+                    parseBlock<Lexer::Technique>(false);
+                else if constexpr (std::is_same_v<Lexer::Main_Pass, T>)
+                    parseBlock<Lexer::Main_Pass>(false);
+                else if constexpr (std::is_same_v<Lexer::Render_Target, T>)
+                    parseBlock<Lexer::Render_Target>();
+                else if constexpr (std::is_same_v<Lexer::Vertex, T>)
+                    parseBlock<Lexer::Vertex>();
+                else if constexpr (std::is_same_v<Lexer::Fragment, T>)
+                    parseBlock<Lexer::Fragment>();
+                else if constexpr (std::is_same_v<Lexer::Compute, T>)
+                    parseBlock<Lexer::Compute>();
+                else if constexpr (std::is_same_v<Lexer::Sampler_1D, T>)
+                    parseBlock<Lexer::Sampler_1D>();
+                else if constexpr (std::is_same_v<Lexer::Sampler_2D, T>)
+                    parseBlock<Lexer::Sampler_2D>();
+                else if constexpr (std::is_same_v<Lexer::Sampler_3D, T>)
+                    parseBlock<Lexer::Sampler_3D>();
+                else if constexpr (std::is_same_v<Lexer::Uniform_Bool, T>)
+                    parseBlock<Lexer::Uniform_Bool>();
+                else if constexpr (std::is_same_v<Lexer::Uniform_Float, T>)
+                    parseBlock<Lexer::Uniform_Float>();
+                else if constexpr (std::is_same_v<Lexer::Uniform_Int, T>)
+                    parseBlock<Lexer::Uniform_Int>();
+                else if constexpr (std::is_same_v<Lexer::Uniform_Vec2, T>)
+                    parseBlock<Lexer::Uniform_Vec2>();
+                else if constexpr (std::is_same_v<Lexer::Uniform_Vec3, T>)
+                    parseBlock<Lexer::Uniform_Vec3>();
+                else if constexpr (std::is_same_v<Lexer::Uniform_Vec4, T>)
+                    parseBlock<Lexer::Uniform_Vec4>();
+                else
+                    error("invalid top level block");
+            }
+            , t);
+        }
+    }
+
+    template <class T>
+    void Technique::parseBlock(bool named)
+    {
+        mBlockName = T::repr;
+
+        if (named)
+        {
+            expect<Lexer::Literal>("name is required for preceeding block decleration");
+
+            mBlockName = std::get<Lexer::Literal>(mToken).value;
+
+            if (isNext<Lexer::Open_Parenthesis>())
+                parseBlockHeader();
+        }
+
+        expect<Lexer::Open_bracket>();
+
+        parseBlockImp<T>();
+
+        expect<Lexer::Close_bracket>();
+    }
+
+    template <class TDelimeter>
+    std::vector<std::string_view> Technique::parseLiteralList()
+    {
+        std::vector<std::string_view> data;
+
+        while (!isNext<Lexer::Eof>())
+        {
+            expect<Lexer::Literal>();
+
+            data.emplace_back(std::get<Lexer::Literal>(mToken).value);
+
+            if (!isNext<TDelimeter>())
+                break;
+
+            mLexer->next();
+        }
+
+        return data;
+    }
+
+    void Technique::parseBlockHeader()
+    {
+        expect<Lexer::Open_Parenthesis>();
+
+        if (isNext<Lexer::Close_Parenthesis>())
+        {
+            mLexer->next();
+            return;
+        }
+
+        auto& pass = mPassMap[mBlockName];
+
+        if (!pass)
+            pass = std::make_shared<fx::Pass>();
+
+        bool clear = true;
+        osg::Vec4f clearColor = {1,1,1,1};
+
+        while (!isNext<Lexer::Eof>())
+        {
+            expect<Lexer::Literal>("invalid key in block header");
+
+            std::string_view key = std::get<Lexer::Literal>(mToken).value;
+
+            expect<Lexer::Equal>();
+
+            if (key == "target")
+            {
+                expect<Lexer::Literal>();
+                pass->mTarget = std::get<Lexer::Literal>(mToken).value;
+            }
+            else if (key == "blend")
+            {
+                expect<Lexer::Open_Parenthesis>();
+                osg::BlendEquation::Equation blendEq = parseBlendEquation();
+                expect<Lexer::Comma>();
+                osg::BlendFunc::BlendFuncMode blendSrc = parseBlendFuncMode();
+                expect<Lexer::Comma>();
+                osg::BlendFunc::BlendFuncMode blendDest = parseBlendFuncMode();
+                expect<Lexer::Close_Parenthesis>();
+
+                pass->mBlendSource = blendSrc;
+                pass->mBlendDest = blendDest;
+                if (blendEq != osg::BlendEquation::FUNC_ADD)
+                    pass->mBlendEq = blendEq;
+            }
+            else if (key == "clear")
+                clear = parseBool();
+            else if (key == "clear_color")
+                clearColor = parseVec<osg::Vec4f, Lexer::Vec4>();
+            else
+                error(Misc::StringUtils::format("unrecognized key '%s' in block header", std::string(key)));
+
+            mToken = mLexer->next();
+
+            if (std::holds_alternative<Lexer::Comma>(mToken))
+            {
+                if (std::holds_alternative<Lexer::Close_Parenthesis>(mLexer->peek()))
+                    error(Misc::StringUtils::format("leading comma in '%s' is not allowed", std::string(mBlockName)));
+                else
+                    continue;
+            }
+
+            if (std::holds_alternative<Lexer::Close_Parenthesis>(mToken))
+                return;
+        }
+
+        if (clear)
+            pass->mClearColor = clearColor;
+
+        error("malformed block header");
+    }
+
+    std::string_view Technique::asLiteral() const
+    {
+        return std::get<Lexer::Literal>(mToken).value;
+    }
+
+    FlagsType Technique::parseFlags()
+    {
+        auto parseBit = [this] (std::string_view term) {
+            for (const auto& [identifer, bit]: constants::TechniqueFlag)
+            {
+                if (Misc::StringUtils::ciEqual(term, identifer))
+                    return bit;
+            }
+            error(Misc::StringUtils::format("unrecognized flag '%s'", std::string(term)));
+        };
+
+        FlagsType flag = 0;
+        for (const auto& bit : parseLiteralList<Lexer::Comma>())
+            flag |= parseBit(bit);
+
+        return flag;
+    }
+
+    osg::Texture::FilterMode Technique::parseFilterMode()
+    {
+        expect<Lexer::Literal>();
+
+        for (const auto& [identifer, mode]: constants::FilterMode)
+        {
+            if (asLiteral() == identifer)
+                return mode;
+        }
+
+        error(Misc::StringUtils::format("unrecognized filter mode '%s'", std::string{asLiteral()}));
+    }
+
+    osg::Texture::WrapMode Technique::parseWrapMode()
+    {
+        expect<Lexer::Literal>();
+
+        for (const auto& [identifer, mode]: constants::WrapMode)
+        {
+            if (asLiteral() == identifer)
+                return mode;
+        }
+
+        error(Misc::StringUtils::format("unrecognized wrap mode '%s'", std::string{asLiteral()}));
+    }
+
+    osg::Texture::InternalFormatMode Technique::parseCompression()
+    {
+        expect<Lexer::Literal>();
+
+        for (const auto& [identifer, mode]: constants::Compression)
+        {
+            if (asLiteral() == identifer)
+                return mode;
+        }
+
+        error(Misc::StringUtils::format("unrecognized compression '%s'", std::string{asLiteral()}));
+    }
+
+    int Technique::parseInternalFormat()
+    {
+        expect<Lexer::Literal>();
+
+        for (const auto& [identifer, mode]: constants::InternalFormat)
+        {
+            if (asLiteral() == identifer)
+                return mode;
+        }
+
+        error(Misc::StringUtils::format("unrecognized internal format '%s'", std::string{asLiteral()}));
+    }
+
+    int Technique::parseSourceType()
+    {
+        expect<Lexer::Literal>();
+
+        for (const auto& [identifer, mode]: constants::SourceType)
+        {
+            if (asLiteral() == identifer)
+                return mode;
+        }
+
+        error(Misc::StringUtils::format("unrecognized source type '%s'", std::string{asLiteral()}));
+    }
+
+    int Technique::parseSourceFormat()
+    {
+        expect<Lexer::Literal>();
+
+        for (const auto& [identifer, mode]: constants::SourceFormat)
+        {
+            if (asLiteral() == identifer)
+                return mode;
+        }
+
+        error(Misc::StringUtils::format("unrecognized source format '%s'", std::string{asLiteral()}));
+    }
+
+    osg::BlendEquation::Equation Technique::parseBlendEquation()
+    {
+        expect<Lexer::Literal>();
+
+        for (const auto& [identifer, mode]: constants::BlendEquation)
+        {
+            if (asLiteral() == identifer)
+                return mode;
+        }
+
+        error(Misc::StringUtils::format("unrecognized blend equation '%s'", std::string{asLiteral()}));
+    }
+
+    osg::BlendFunc::BlendFuncMode Technique::parseBlendFuncMode()
+    {
+        expect<Lexer::Literal>();
+
+        for (const auto& [identifer, mode]: constants::BlendFunc)
+        {
+            if (asLiteral() == identifer)
+                return mode;
+        }
+
+        error(Misc::StringUtils::format("unrecognized blend function '%s'", std::string{asLiteral()}));
+    }
+
+    bool Technique::parseBool()
+    {
+        mToken = mLexer->next();
+
+        if (std::holds_alternative<Lexer::True>(mToken))
+            return true;
+        if (std::holds_alternative<Lexer::False>(mToken))
+            return false;
+
+        error("expected 'true' or 'false' as boolean value");
+    }
+
+    std::string_view Technique::parseString()
+    {
+        expect<Lexer::String>();
+
+        return std::get<Lexer::String>(mToken).value;
+    }
+
+    float Technique::parseFloat()
+    {
+        mToken = mLexer->next();
+
+        if (std::holds_alternative<Lexer::Float>(mToken))
+            return std::get<Lexer::Float>(mToken).value;
+        if (std::holds_alternative<Lexer::Integer>(mToken))
+            return static_cast<float>(std::get<Lexer::Integer>(mToken).value);
+
+        error("expected float value");
+    }
+
+    int Technique::parseInteger()
+    {
+        expect<Lexer::Integer>();
+
+        return std::get<Lexer::Integer>(mToken).value;
+    }
+
+    template <class OSGVec, class T>
+    OSGVec Technique::parseVec()
+    {
+        expect<T>();
+        expect<Lexer::Open_Parenthesis>();
+
+        OSGVec value;
+
+        for (int i = 0; i < OSGVec::num_components; ++i)
+        {
+            value[i] = parseFloat();
+
+            if (i < OSGVec::num_components - 1)
+                expect<Lexer::Comma>();
+        }
+
+        expect<Lexer::Close_Parenthesis>("check definition of the vector");
+
+        return value;
+    }
+}
diff --git a/components/fx/technique.hpp b/components/fx/technique.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..85a28d994477b3c083a3ecd9ab1243efaf001c27
--- /dev/null
+++ b/components/fx/technique.hpp
@@ -0,0 +1,303 @@
+#ifndef OPENMW_COMPONENTS_FX_TECHNIQUE_H
+#define OPENMW_COMPONENTS_FX_TECHNIQUE_H
+
+#include <vector>
+#include <string>
+#include <variant>
+#include <memory>
+#include <unordered_map>
+#include <filesystem>
+
+#include <osg/Node>
+#include <osg/Program>
+#include <osg/Shader>
+#include <osg/Texture2D>
+#include <osg/StateSet>
+#include <osg/FrameBufferObject>
+#include <osg/Vec2f>
+#include <osg/Vec3f>
+#include <osg/Vec4f>
+#include <osg/BlendFunc>
+#include <osg/BlendEquation>
+
+#include "pass.hpp"
+#include "lexer.hpp"
+#include "types.hpp"
+
+namespace Resource
+{
+    class ImageManager;
+}
+
+namespace VFS
+{
+    class Manager;
+}
+
+namespace fx
+{
+    using FlagsType = size_t;
+
+    struct DispatchNode
+    {
+        DispatchNode() = default;
+
+        DispatchNode(const DispatchNode& other, const osg::CopyOp& copyOp = osg::CopyOp::SHALLOW_COPY)
+            : mHandle(other.mHandle)
+            , mFlags(other.mFlags)
+            , mRootStateSet(other.mRootStateSet)
+        {
+            mPasses.reserve(other.mPasses.size());
+
+            for (const auto& subpass : other.mPasses)
+                mPasses.emplace_back(subpass, copyOp);
+        }
+
+        struct SubPass {
+            SubPass() = default;
+
+            osg::ref_ptr<osg::StateSet> mStateSet = new osg::StateSet;
+            osg::ref_ptr<osg::FrameBufferObject> mRenderTarget;
+            osg::ref_ptr<osg::Texture2D> mRenderTexture;
+
+            SubPass(const SubPass& other, const osg::CopyOp& copyOp = osg::CopyOp::SHALLOW_COPY)
+                : mStateSet(new osg::StateSet(*other.mStateSet, copyOp))
+            {
+                if (other.mRenderTarget)
+                    mRenderTarget = new osg::FrameBufferObject(*other.mRenderTarget, copyOp);
+                if (other.mRenderTexture)
+                    mRenderTexture = new osg::Texture2D(*other.mRenderTexture, copyOp);
+            }
+        };
+
+        // not safe to read/write in draw thread
+        std::shared_ptr<fx::Technique> mHandle = nullptr;
+
+        FlagsType mFlags = 0;
+
+        std::vector<SubPass> mPasses;
+
+        osg::ref_ptr<osg::StateSet> mRootStateSet = new osg::StateSet;
+    };
+
+    using DispatchArray = std::vector<DispatchNode>;
+
+    class Technique
+    {
+    public:
+        using PassList = std::vector<std::shared_ptr<Pass>>;
+        using TexList = std::vector<osg::ref_ptr<osg::Texture>>;
+
+        using UniformMap = std::vector<std::shared_ptr<Types::UniformBase>>;
+        using RenderTargetMap = std::unordered_map<std::string_view, Types::RenderTarget>;
+
+        inline static std::string sExt = ".omwfx";
+        inline static std::string sSubdir = "shaders";
+
+        enum class Status
+        {
+            Success,
+            Uncompiled,
+            File_Not_exists,
+            Parse_Error
+        };
+
+        static constexpr FlagsType Flag_Disable_Interiors = (1 << 0);
+        static constexpr FlagsType Flag_Disable_Exteriors = (1 << 1);
+        static constexpr FlagsType Flag_Disable_Underwater = (1 << 2);
+        static constexpr FlagsType Flag_Disable_Abovewater = (1 << 3);
+        static constexpr FlagsType Flag_Disable_SunGlare = (1 << 4);
+        static constexpr FlagsType Flag_Hidden = (1 << 5);
+
+        Technique(const VFS::Manager& vfs, Resource::ImageManager& imageManager, const std::string& name, int width, int height, bool ubo, bool supportsNormals);
+
+        bool compile();
+
+        std::string getName() const;
+
+        std::string getFileName() const;
+
+        void setLastModificationTime(std::filesystem::file_time_type timeStamp, bool dirty = true);
+
+        bool isDirty() const { return mDirty; }
+
+        void setDirty(bool dirty) { mDirty = dirty; }
+
+        bool isValid() const { return mValid; }
+
+        bool getHDR() const { return mHDR; }
+
+        bool getNormals() const { return mNormals && mSupportsNormals; }
+
+        bool getLights() const { return mLights; }
+
+        const PassList& getPasses() { return mPasses; }
+
+        const TexList& getTextures() const { return mTextures; }
+
+        Status getStatus() const { return mStatus; }
+
+        std::string_view getAuthor() const { return mAuthor; }
+
+        std::string_view getDescription() const { return mDescription; }
+
+        std::string_view getVersion() const { return mVersion; }
+
+        int getGLSLVersion() const { return mGLSLVersion; }
+
+        std::string getGLSLProfile() const { return mGLSLProfile; }
+
+        const std::unordered_set<std::string>& getGLSLExtensions() const { return mGLSLExtensions; }
+
+        osg::ref_ptr<osg::Texture2D> getMainTemplate() const { return mMainTemplate; }
+
+        FlagsType getFlags() const { return mFlags; }
+
+        bool getHidden() const { return mFlags & Flag_Hidden; }
+
+        UniformMap& getUniformMap() { return mDefinedUniforms; }
+
+        RenderTargetMap& getRenderTargetsMap() { return mRenderTargets; }
+
+        std::string getLastError() const { return mLastError; }
+
+        UniformMap::iterator findUniform(const std::string& name);
+
+    private:
+        [[noreturn]] void error(const std::string& msg);
+
+        void clear();
+
+        std::string_view asLiteral() const;
+
+        template<class T>
+        void expect(const std::string& err="");
+
+        template<class T, class T2>
+        void expect(const std::string& err="");
+
+        template <class T>
+        bool isNext();
+
+        void parse(std::string&& buffer);
+
+        template <class SrcT, class T>
+        void parseUniform();
+
+        template <class T>
+        void parseSampler();
+
+        template <class T>
+        void parseBlock(bool named=true);
+
+        template <class T>
+        void parseBlockImp() {}
+
+        void parseBlockHeader();
+
+        bool parseBool();
+
+        std::string_view parseString();
+
+        float parseFloat();
+
+        int parseInteger();
+
+        int parseInternalFormat();
+
+        int parseSourceType();
+
+        int parseSourceFormat();
+
+        osg::BlendEquation::Equation parseBlendEquation();
+
+        osg::BlendFunc::BlendFuncMode parseBlendFuncMode();
+
+        osg::Texture::WrapMode parseWrapMode();
+
+        osg::Texture::InternalFormatMode parseCompression();
+
+        FlagsType parseFlags();
+
+        osg::Texture::FilterMode parseFilterMode();
+
+        template <class TDelimeter>
+        std::vector<std::string_view> parseLiteralList();
+
+        template <class OSGVec, class T>
+        OSGVec parseVec();
+
+        std::string getBlockWithLineDirective();
+
+        std::unique_ptr<Lexer::Lexer> mLexer;
+        Lexer::Token mToken;
+
+        std::string mShared;
+        std::string mName;
+        std::string mFileName;
+        std::string_view mBlockName;
+        std::string_view mAuthor;
+        std::string_view mDescription;
+        std::string_view mVersion;
+
+        std::unordered_set<std::string> mGLSLExtensions;
+        int mGLSLVersion;
+        std::string mGLSLProfile;
+
+        FlagsType mFlags;
+
+        Status mStatus;
+
+        bool mEnabled;
+
+        std::filesystem::file_time_type mLastModificationTime;
+        bool mDirty;
+        bool mValid;
+        bool mHDR;
+        bool mNormals;
+        bool mLights;
+        int mWidth;
+        int mHeight;
+
+        osg::ref_ptr<osg::Texture2D> mMainTemplate;
+        RenderTargetMap mRenderTargets;
+
+        TexList mTextures;
+        PassList mPasses;
+
+        std::unordered_map<std::string_view, std::shared_ptr<Pass>> mPassMap;
+        std::vector<std::string_view> mPassKeys;
+
+        Pass::Type mLastAppliedType;
+
+        UniformMap mDefinedUniforms;
+
+        const VFS::Manager& mVFS;
+        Resource::ImageManager& mImageManager;
+        bool mUBO;
+        bool mSupportsNormals;
+
+        std::string mBuffer;
+
+        std::string mLastError;
+    };
+
+    template<> void Technique::parseBlockImp<Lexer::Shared>();
+    template<> void Technique::parseBlockImp<Lexer::Technique>();
+    template<> void Technique::parseBlockImp<Lexer::Main_Pass>();
+    template<> void Technique::parseBlockImp<Lexer::Render_Target>();
+    template<> void Technique::parseBlockImp<Lexer::Vertex>();
+    template<> void Technique::parseBlockImp<Lexer::Fragment>();
+    template<> void Technique::parseBlockImp<Lexer::Compute>();
+    template<> void Technique::parseBlockImp<Lexer::Sampler_1D>();
+    template<> void Technique::parseBlockImp<Lexer::Sampler_2D>();
+    template<> void Technique::parseBlockImp<Lexer::Sampler_3D>();
+    template<> void Technique::parseBlockImp<Lexer::Uniform_Bool>();
+    template<> void Technique::parseBlockImp<Lexer::Uniform_Float>();
+    template<> void Technique::parseBlockImp<Lexer::Uniform_Int>();
+    template<> void Technique::parseBlockImp<Lexer::Uniform_Vec2>();
+    template<> void Technique::parseBlockImp<Lexer::Uniform_Vec3>();
+    template<> void Technique::parseBlockImp<Lexer::Uniform_Vec4>();
+}
+
+#endif
diff --git a/components/fx/types.hpp b/components/fx/types.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..f12810197fd3a5fc651f942c2312a235739c26db
--- /dev/null
+++ b/components/fx/types.hpp
@@ -0,0 +1,259 @@
+#ifndef OPENMW_COMPONENTS_FX_TYPES_H
+#define OPENMW_COMPONENTS_FX_TYPES_H
+
+#include <optional>
+
+#include <osg/Camera>
+#include <osg/Uniform>
+#include <osg/Texture2D>
+#include <osg/FrameBufferObject>
+#include <osg/BlendFunc>
+#include <osg/BlendEquation>
+
+#include <MyGUI_Widget.h>
+
+#include <components/sceneutil/depth.hpp>
+#include <components/settings/shadermanager.hpp>
+#include <components/misc/stringops.hpp>
+#include <components/debug/debuglog.hpp>
+
+#include "pass.hpp"
+
+namespace fx
+{
+    namespace Types
+    {
+        struct SizeProxy
+        {
+            std::optional<float> mWidthRatio;
+            std::optional<float> mHeightRatio;
+            std::optional<int> mWidth;
+            std::optional<int> mHeight;
+
+            std::tuple<int,int> get(int width, int height) const
+            {
+                int scaledWidth = width;
+                int scaledHeight = height;
+
+                if (mWidthRatio)
+                    scaledWidth = width * mWidthRatio.value();
+                else if (mWidth)
+                    scaledWidth = mWidth.value();
+
+                if (mHeightRatio > 0.f)
+                    scaledHeight = height * mHeightRatio.value();
+                else if (mHeight)
+                    scaledHeight = mHeight.value();
+
+                return std::make_tuple(scaledWidth, scaledHeight);
+            }
+        };
+
+        struct RenderTarget
+        {
+            osg::ref_ptr<osg::Texture2D> mTarget = new osg::Texture2D;
+            SizeProxy mSize;
+            bool mMipMap = false;
+        };
+
+        template <class T>
+        struct Uniform
+        {
+            std::optional<T> mValue;
+            T mDefault;
+            T mMin = std::numeric_limits<T>::lowest();
+            T mMax = std::numeric_limits<T>::max();
+
+            using value_type = T;
+
+            T getValue() const
+            {
+                return mValue.value_or(mDefault);
+            }
+        };
+
+        using Uniform_t = std::variant<
+            Uniform<osg::Vec2f>,
+            Uniform<osg::Vec3f>,
+            Uniform<osg::Vec4f>,
+            Uniform<bool>,
+            Uniform<float>,
+            Uniform<int>
+        >;
+
+        enum SamplerType
+        {
+            Texture_1D,
+            Texture_2D,
+            Texture_3D
+        };
+
+        struct UniformBase
+        {
+            std::string mName;
+            std::string mHeader;
+            std::string mTechniqueName;
+            std::string mDescription;
+
+            bool mStatic = true;
+            std::optional<SamplerType> mSamplerType = std::nullopt;
+            double mStep;
+
+            Uniform_t mData;
+
+            template <class T>
+            T getValue() const
+            {
+                auto value = Settings::ShaderManager::get().getValue<T>(mTechniqueName, mName);
+
+                return value.value_or(std::get<Uniform<T>>(mData).getValue());
+            }
+
+            template <class T>
+            T getMin() const
+            {
+                return std::get<Uniform<T>>(mData).mMin;
+            }
+
+            template <class T>
+            T getMax() const
+            {
+                return std::get<Uniform<T>>(mData).mMax;
+            }
+
+            template <class T>
+            T getDefault() const
+            {
+                return std::get<Uniform<T>>(mData).mDefault;
+            }
+
+            template <class T>
+            void setValue(const T& value)
+            {
+                std::visit([&, value](auto&& arg){
+                    using U = typename std::decay_t<decltype(arg)>::value_type;
+
+                    if constexpr (std::is_same_v<T, U>)
+                    {
+                        arg.mValue = value;
+
+                        if (mStatic)
+                            Settings::ShaderManager::get().setValue<T>(mTechniqueName, mName, value);
+                    }
+                    else
+                    {
+                        Log(Debug::Warning) << "Attempting to set uniform '" << mName << "' with wrong type";
+                    }
+                }, mData);
+            }
+
+            void setUniform(osg::Uniform* uniform)
+            {
+                auto type = getType();
+                if (!type || type.value() != uniform->getType())
+                    return;
+
+                std::visit([&](auto&& arg)
+                {
+                    const auto value = arg.getValue();
+                    uniform->set(value);
+                }, mData);
+            }
+
+            std::optional<osg::Uniform::Type> getType() const
+            {
+                return std::visit([](auto&& arg) -> std::optional<osg::Uniform::Type> {
+                    using T = typename std::decay_t<decltype(arg)>::value_type;
+
+                    if constexpr (std::is_same_v<T, osg::Vec2f>)
+                        return osg::Uniform::FLOAT_VEC2;
+                    else if constexpr (std::is_same_v<T, osg::Vec3f>)
+                        return osg::Uniform::FLOAT_VEC3;
+                    else if constexpr (std::is_same_v<T, osg::Vec4f>)
+                        return osg::Uniform::FLOAT_VEC4;
+                    else if constexpr (std::is_same_v<T, float>)
+                        return osg::Uniform::FLOAT;
+                    else if constexpr (std::is_same_v<T, int>)
+                        return osg::Uniform::INT;
+                    else if constexpr (std::is_same_v<T, bool>)
+                        return osg::Uniform::BOOL;
+
+                    return std::nullopt;
+                }, mData);
+            }
+
+            std::optional<std::string> getGLSL()
+            {
+                if (mSamplerType)
+                {
+                    switch (mSamplerType.value())
+                    {
+                        case Texture_1D:
+                            return Misc::StringUtils::format("uniform sampler1D %s;", mName);
+                        case Texture_2D:
+                            return Misc::StringUtils::format("uniform sampler2D %s;", mName);
+                        case Texture_3D:
+                            return Misc::StringUtils::format("uniform sampler3D %s;", mName);
+                    }
+                }
+
+                bool useUniform = (Settings::ShaderManager::get().getMode() == Settings::ShaderManager::Mode::Debug || mStatic == false);
+
+                return std::visit([&](auto&& arg) -> std::optional<std::string> {
+                    using T = typename std::decay_t<decltype(arg)>::value_type;
+
+                    auto value = arg.getValue();
+
+                    if constexpr (std::is_same_v<T, osg::Vec2f>)
+                    {
+                        if (useUniform)
+                            return Misc::StringUtils::format("uniform vec2 %s;", mName);
+
+                        return Misc::StringUtils::format("const vec2 %s=vec2(%f,%f);", mName, value[0], value[1]);
+                    }
+                    else if constexpr (std::is_same_v<T, osg::Vec3f>)
+                    {
+                        if (useUniform)
+                            return Misc::StringUtils::format("uniform vec3 %s;", mName);
+
+                        return Misc::StringUtils::format("const vec3 %s=vec3(%f,%f,%f);", mName, value[0], value[1], value[2]);
+                    }
+                    else if constexpr (std::is_same_v<T, osg::Vec4f>)
+                    {
+                        if (useUniform)
+                            return Misc::StringUtils::format("uniform vec4 %s;", mName);
+
+                        return Misc::StringUtils::format("const vec4 %s=vec4(%f,%f,%f,%f);", mName, value[0], value[1], value[2], value[3]);
+                    }
+                    else if constexpr (std::is_same_v<T, float>)
+                    {
+                        if (useUniform)
+                            return Misc::StringUtils::format("uniform float %s;",  mName);
+
+                        return Misc::StringUtils::format("const float %s=%f;", mName, value);
+                    }
+                    else if constexpr (std::is_same_v<T, int>)
+                    {
+                        if (useUniform)
+                            return Misc::StringUtils::format("uniform int %s;",  mName);
+
+                        return Misc::StringUtils::format("const int %s=%i;", mName, value);
+                    }
+                    else if constexpr (std::is_same_v<T, bool>)
+                    {
+                        if (useUniform)
+                            return Misc::StringUtils::format("uniform bool %s;", mName);
+
+                        return Misc::StringUtils::format("const bool %s=%s;", mName, value ? "true" : "false");
+                    }
+
+                    return std::nullopt;
+
+                }, mData);
+            }
+
+        };
+    }
+}
+
+#endif
diff --git a/components/fx/widgets.cpp b/components/fx/widgets.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..2206fd8c7ffa672567790abeaa28839b0b831639
--- /dev/null
+++ b/components/fx/widgets.cpp
@@ -0,0 +1,164 @@
+#include "widgets.hpp"
+
+#include <components/widgets/box.hpp>
+
+namespace
+{
+    template <class T, class WidgetT>
+    void createVectorWidget(const std::shared_ptr<fx::Types::UniformBase>& uniform, MyGUI::Widget* client, fx::Widgets::UniformBase* base)
+    {
+        int height = client->getHeight();
+        base->setSize(base->getSize().width, (base->getSize().height - height) + (height * T::num_components));
+        client->setSize(client->getSize().width, height * T::num_components);
+
+        for (int i = 0; i < T::num_components; ++i)
+        {
+            auto* widget = client->createWidget<WidgetT>("MW_ValueEditNumber", {0, height * i, client->getWidth(), height}, MyGUI::Align::Default);
+            widget->setData(uniform, static_cast<fx::Widgets::Index>(i));
+            base->addItem(widget);
+        }
+    }
+}
+
+namespace fx
+{
+    namespace Widgets
+    {
+        void EditBool::setValue(bool value)
+        {
+            auto uniform = mUniform.lock();
+
+            if (!uniform)
+                return;
+
+            mCheckbutton->setCaptionWithReplacing(value ? "#{sOn}" : "#{sOff}");
+
+            uniform->setValue<bool>(value);
+        }
+
+        void EditBool::setValueFromUniform()
+        {
+            auto uniform = mUniform.lock();
+
+            if (!uniform)
+                return;
+
+            setValue(uniform->template getValue<bool>());
+        }
+
+        void EditBool::toDefault()
+        {
+            auto uniform = mUniform.lock();
+
+            if (!uniform)
+                return;
+
+            setValue(uniform->getDefault<bool>());
+        }
+
+        void EditBool::initialiseOverride()
+        {
+            Base::initialiseOverride();
+
+            assignWidget(mCheckbutton, "Checkbutton");
+
+            mCheckbutton->eventMouseButtonClick += MyGUI::newDelegate(this, &EditBool::notifyMouseButtonClick);
+        }
+
+
+        void EditBool::notifyMouseButtonClick(MyGUI::Widget* sender)
+        {
+            auto uniform = mUniform.lock();
+
+            if (!uniform)
+                return;
+
+            setValue(!uniform->getValue<bool>());
+        }
+
+        void UniformBase::init(const std::shared_ptr<fx::Types::UniformBase>& uniform)
+        {
+            mLabel->setCaption(uniform->mName);
+
+            if (uniform->mDescription.empty())
+            {
+                mLabel->setUserString("ToolTipType", "");
+            }
+            else
+            {
+                mLabel->setUserString("ToolTipType", "Layout");
+                mLabel->setUserString("ToolTipLayout", "TextToolTip");
+                mLabel->setUserString("Caption_Text", uniform->mDescription);
+            }
+
+            std::visit([this, &uniform](auto&& arg) {
+                using T = typename std::decay_t<decltype(arg)>::value_type;
+
+                if constexpr (std::is_same_v<osg::Vec4f, T>)
+                {
+                    createVectorWidget<T, EditNumberFloat4>(uniform, mClient, this);
+                }
+                else if constexpr (std::is_same_v<osg::Vec3f, T>)
+                {
+                    createVectorWidget<T, EditNumberFloat3>(uniform, mClient, this);
+                }
+                else if constexpr (std::is_same_v<osg::Vec2f, T>)
+                {
+                    createVectorWidget<T, EditNumberFloat2>(uniform, mClient, this);
+                }
+                else if constexpr (std::is_same_v<T, float>)
+                {
+                    auto* widget = mClient->createWidget<EditNumberFloat>("MW_ValueEditNumber", {0, 0, mClient->getWidth(), mClient->getHeight()}, MyGUI::Align::Stretch);
+                    widget->setData(uniform);
+                    mBases.emplace_back(widget);
+                }
+                else if constexpr (std::is_same_v<T, int>)
+                {
+                    auto* widget = mClient->createWidget<EditNumberInt>("MW_ValueEditNumber", {0, 0, mClient->getWidth(), mClient->getHeight()}, MyGUI::Align::Stretch);
+                    widget->setData(uniform);
+                    mBases.emplace_back(widget);
+                }
+                else if constexpr (std::is_same_v<T, bool>)
+                {
+                    auto* widget = mClient->createWidget<EditBool>("MW_ValueEditBool", {0, 0, mClient->getWidth(), mClient->getHeight()}, MyGUI::Align::Stretch);
+                    widget->setData(uniform);
+                    mBases.emplace_back(widget);
+                }
+
+                mReset->eventMouseButtonClick += MyGUI::newDelegate(this, &UniformBase::notifyResetClicked);
+
+                for (EditBase* base : mBases)
+                    base->setValueFromUniform();
+
+            }, uniform->mData);
+        }
+
+        void UniformBase::addItem(EditBase* item)
+        {
+            mBases.emplace_back(item);
+        }
+
+        void UniformBase::toDefault()
+        {
+            for (EditBase* base : mBases)
+            {
+                if (base)
+                    base->toDefault();
+            }
+        }
+
+        void UniformBase::notifyResetClicked(MyGUI::Widget* sender)
+        {
+            toDefault();
+        }
+
+        void UniformBase::initialiseOverride()
+        {
+            Base::initialiseOverride();
+
+            assignWidget(mReset, "Reset");
+            assignWidget(mLabel, "Label");
+            assignWidget(mClient, "Client");
+        }
+    }
+}
\ No newline at end of file
diff --git a/components/fx/widgets.hpp b/components/fx/widgets.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..f15e676fb6a44a47da622968bb54fb1e54bdb4fe
--- /dev/null
+++ b/components/fx/widgets.hpp
@@ -0,0 +1,266 @@
+#ifndef OPENMW_COMPONENTS_FX_WIDGETS_H
+#define OPENMW_COMPONENTS_FX_WIDGETS_H
+
+#include <MyGUI_Gui.h>
+#include <MyGUI_Button.h>
+#include <MyGUI_ScrollView.h>
+#include <MyGUI_InputManager.h>
+
+#include <osg/Vec2f>
+#include <osg/Vec3f>
+#include <osg/Vec4f>
+
+#include <components/misc/stringops.hpp>
+
+#include "technique.hpp"
+#include "types.hpp"
+
+namespace Gui
+{
+    class AutoSizedTextBox;
+    class AutoSizedButton;
+}
+
+namespace fx
+{
+    namespace Widgets
+    {
+        enum Index
+        {
+            None = -1,
+            Zero = 0,
+            One = 1,
+            Two = 2,
+            Three = 3
+        };
+
+        class EditBase
+        {
+        public:
+            virtual ~EditBase() = default;
+
+            void setData(const std::shared_ptr<fx::Types::UniformBase>& uniform, Index index = None)
+            {
+                mUniform = uniform;
+                mIndex = index;
+            }
+
+            virtual void setValueFromUniform() = 0;
+
+            virtual void toDefault() = 0;
+
+        protected:
+            std::weak_ptr<fx::Types::UniformBase> mUniform;
+            Index mIndex;
+        };
+
+        class EditBool : public EditBase, public MyGUI::Widget
+        {
+            MYGUI_RTTI_DERIVED(EditBool)
+
+        public:
+            void setValue(bool value);
+            void setValueFromUniform() override;
+            void toDefault() override;
+
+        private:
+            void initialiseOverride() override;
+            void notifyMouseButtonClick(MyGUI::Widget* sender);
+
+            MyGUI::Button* mCheckbutton;
+        };
+
+        template <class T, class UType>
+        class EditNumber : public EditBase, public MyGUI::Widget
+        {
+            MYGUI_RTTI_DERIVED(EditNumber)
+
+        public:
+            EditNumber() : mLastPointerX(0) {}
+
+            void setValue(T value)
+            {
+                mValue = value;
+                if constexpr (std::is_floating_point_v<T>)
+                    mValueLabel->setCaption(Misc::StringUtils::format("%.3f", mValue));
+                else
+                    mValueLabel->setCaption(std::to_string(mValue));
+
+                if (auto uniform = mUniform.lock())
+                {
+                    if constexpr (std::is_fundamental_v<UType>)
+                        uniform->template setValue<UType>(mValue);
+                    else
+                    {
+                        UType uvalue = uniform->template getValue<UType>();
+                        uvalue[mIndex] = mValue;
+                        uniform->template setValue<UType>(uvalue);
+                    }
+                }
+            }
+
+            void setValueFromUniform() override
+            {
+                if (auto uniform = mUniform.lock())
+                {
+                    T value;
+
+                    if constexpr (std::is_fundamental_v<UType>)
+                        value = uniform->template getValue<UType>();
+                    else
+                        value = uniform->template getValue<UType>()[mIndex];
+
+                    setValue(value);
+                }
+            }
+
+            void toDefault() override
+            {
+                if (auto uniform = mUniform.lock())
+                {
+                    if constexpr (std::is_fundamental_v<UType>)
+                        setValue(uniform->template getDefault<UType>());
+                    else
+                        setValue(uniform->template getDefault<UType>()[mIndex]);
+                }
+            }
+
+        private:
+
+            void initialiseOverride() override
+            {
+                Base::initialiseOverride();
+
+                assignWidget(mDragger, "Dragger");
+                assignWidget(mValueLabel, "Value");
+                assignWidget(mButtonIncrease, "ButtonIncrease");
+                assignWidget(mButtonDecrease, "ButtonDecrease");
+
+                mButtonIncrease->eventMouseButtonClick += MyGUI::newDelegate(this, &EditNumber::notifyButtonClicked);
+                mButtonDecrease->eventMouseButtonClick += MyGUI::newDelegate(this, &EditNumber::notifyButtonClicked);
+
+                mDragger->eventMouseButtonPressed += MyGUI::newDelegate(this, &EditNumber::notifyMouseButtonPressed);
+                mDragger->eventMouseDrag += MyGUI::newDelegate(this, &EditNumber::notifyMouseButtonDragged);
+                mDragger->eventMouseWheel += MyGUI::newDelegate(this, &EditNumber::notifyMouseWheel);
+            }
+
+            void notifyMouseWheel(MyGUI::Widget* sender, int rel)
+            {
+                auto uniform = mUniform.lock();
+
+                if (!uniform)
+                    return;
+
+                if (rel > 0)
+                    increment(uniform->mStep);
+                else
+                    increment(-uniform->mStep);
+            }
+
+            void notifyMouseButtonDragged(MyGUI::Widget* sender, int left, int top, MyGUI::MouseButton id)
+            {
+                if (id != MyGUI::MouseButton::Left)
+                    return;
+
+                auto uniform = mUniform.lock();
+
+                if (!uniform)
+                    return;
+
+                int delta = left - mLastPointerX;
+
+                // allow finer tuning when shift is pressed
+                constexpr double scaling = 20.0;
+                T step = MyGUI::InputManager::getInstance().isShiftPressed() ? uniform->mStep / scaling : uniform->mStep;
+
+                if (step == 0)
+                {
+                    if constexpr (std::is_integral_v<T>)
+                        step = 1;
+                    else
+                        step = uniform->mStep;
+                }
+
+                if (delta > 0)
+                    increment(step);
+                else if (delta < 0)
+                    increment(-step);
+
+                mLastPointerX = left;
+            }
+
+            void notifyMouseButtonPressed(MyGUI::Widget* sender, int left, int top, MyGUI::MouseButton id)
+            {
+                if (id != MyGUI::MouseButton::Left)
+                    return;
+
+                mLastPointerX = left;
+            }
+
+            void increment(T step)
+            {
+                auto uniform = mUniform.lock();
+
+                if (!uniform)
+                    return;
+
+                if constexpr (std::is_fundamental_v<UType>)
+                    setValue(std::clamp<T>(uniform->template getValue<UType>() + step, uniform->template getMin<UType>(), uniform->template getMax<T>()));
+                else
+                    setValue(std::clamp<T>(uniform->template getValue<UType>()[mIndex] + step, uniform->template getMin<UType>()[mIndex], uniform->template getMax<UType>()[mIndex]));
+            }
+
+            void notifyButtonClicked(MyGUI::Widget* sender)
+            {
+                auto uniform = mUniform.lock();
+
+                if (!uniform)
+                    return;
+
+                if (sender == mButtonDecrease)
+                    increment(-uniform->mStep);
+                else if (sender == mButtonIncrease)
+                    increment(uniform->mStep);
+            }
+
+            MyGUI::Button* mButtonDecrease;
+            MyGUI::Button* mButtonIncrease;
+            MyGUI::Widget* mDragger;
+            MyGUI::TextBox* mValueLabel;
+            T mValue;
+
+            int mLastPointerX;
+        };
+
+        class EditNumberFloat4 : public EditNumber<float, osg::Vec4f> { MYGUI_RTTI_DERIVED(EditNumberFloat4) };
+        class EditNumberFloat3 : public EditNumber<float, osg::Vec3f> { MYGUI_RTTI_DERIVED(EditNumberFloat3) };
+        class EditNumberFloat2 : public EditNumber<float, osg::Vec2f> { MYGUI_RTTI_DERIVED(EditNumberFloat2) };
+        class EditNumberFloat : public EditNumber<float, float> { MYGUI_RTTI_DERIVED(EditNumberFloat) };
+        class EditNumberInt : public EditNumber<int, int> { MYGUI_RTTI_DERIVED(EditNumberInt) };
+
+        class UniformBase final : public MyGUI::Widget
+        {
+            MYGUI_RTTI_DERIVED(UniformBase)
+
+        public:
+            void init(const std::shared_ptr<fx::Types::UniformBase>& uniform);
+
+            void toDefault();
+
+            void addItem(EditBase* item);
+
+        private:
+
+            void notifyResetClicked(MyGUI::Widget* sender);
+
+            void initialiseOverride() override;
+
+            Gui::AutoSizedButton* mReset;
+            Gui::AutoSizedTextBox* mLabel;
+            MyGUI::Widget* mClient;
+            std::vector<EditBase*> mBases;
+        };
+    }
+}
+
+#endif
diff --git a/components/misc/constants.hpp b/components/misc/constants.hpp
index 01d783a4fc287444ab72c1506546e657a73e694a..2f4d4f8a18a631bcb38abb404534a9f7a27960ef 100644
--- a/components/misc/constants.hpp
+++ b/components/misc/constants.hpp
@@ -39,6 +39,9 @@ const float TorsoHeight = 0.75f;
 static constexpr float sStepSizeUp = 34.0f;
 static constexpr float sMaxSlope = 46.0f;
 
+// Identifier for main scene camera
+const std::string SceneCamera = "SceneCam";
+
 }
 
 #endif
diff --git a/components/resource/imagemanager.cpp b/components/resource/imagemanager.cpp
index a544b7b621a8c3e0dc92bdfcc399f259a313150b..ef90353a73a477cdde5fe4b751e82a9cf1f79584 100644
--- a/components/resource/imagemanager.cpp
+++ b/components/resource/imagemanager.cpp
@@ -49,6 +49,7 @@ namespace Resource
         : ResourceManager(vfs)
         , mWarningImage(createWarningImage())
         , mOptions(new osgDB::Options("dds_flip dds_dxt1_detect_rgba ignoreTga2Fields"))
+        , mOptionsNoFlip(new osgDB::Options("dds_dxt1_detect_rgba ignoreTga2Fields"))
     {
     }
 
@@ -82,7 +83,7 @@ namespace Resource
         return true;
     }
 
-    osg::ref_ptr<osg::Image> ImageManager::getImage(const std::string &filename)
+    osg::ref_ptr<osg::Image> ImageManager::getImage(const std::string &filename, bool disableFlip)
     {
         const std::string normalized = mVFS->normalizeFilename(filename);
 
@@ -135,7 +136,7 @@ namespace Resource
                 stream->seekg(0);
             }
 
-            osgDB::ReaderWriter::ReadResult result = reader->readImage(*stream, mOptions);
+            osgDB::ReaderWriter::ReadResult result = reader->readImage(*stream, disableFlip ? mOptionsNoFlip : mOptions);
             if (!result.success())
             {
                 Log(Debug::Error) << "Error loading " << filename << ": " << result.message() << " code " << result.status();
diff --git a/components/resource/imagemanager.hpp b/components/resource/imagemanager.hpp
index 64954af54b058e7f1a7f3e526509961adf4eaec3..85ea69795ae7363abd84e39bbfa9f5f53887eac4 100644
--- a/components/resource/imagemanager.hpp
+++ b/components/resource/imagemanager.hpp
@@ -28,7 +28,7 @@ namespace Resource
 
         /// Create or retrieve an Image
         /// Returns the dummy image if the given image is not found.
-        osg::ref_ptr<osg::Image> getImage(const std::string& filename);
+        osg::ref_ptr<osg::Image> getImage(const std::string& filename, bool disableFlip = false);
 
         osg::Image* getWarningImage();
 
@@ -37,6 +37,7 @@ namespace Resource
     private:
         osg::ref_ptr<osg::Image> mWarningImage;
         osg::ref_ptr<osgDB::Options> mOptions;
+        osg::ref_ptr<osgDB::Options> mOptionsNoFlip;
 
         ImageManager(const ImageManager&);
         void operator = (const ImageManager&);
diff --git a/components/resource/scenemanager.cpp b/components/resource/scenemanager.cpp
index 8ddc3fd102b8bb978f39b64497ca7d22a164910c..a2779109ac3b338c6b11223c5f251865beba2a36 100644
--- a/components/resource/scenemanager.cpp
+++ b/components/resource/scenemanager.cpp
@@ -318,7 +318,7 @@ namespace Resource
         , mApplyLightingToEnvMaps(false)
         , mLightingMethod(SceneUtil::LightingMethod::FFP)
         , mConvertAlphaTestToAlphaToCoverage(false)
-        , mDepthFormat(0)
+        , mSupportsNormalsRT(false)
         , mSharedStateManager(new SharedStateManager)
         , mImageManager(imageManager)
         , mNifFileManager(nifFileManager)
@@ -348,7 +348,7 @@ namespace Resource
         if (forceShadersForNode)
             shaderVisitor->setForceShaders(true);
         if (disableSoftParticles)
-            shaderVisitor->setOpaqueDepthTex(nullptr);
+            shaderVisitor->setOpaqueDepthTex(nullptr, nullptr);
         node->accept(*shaderVisitor);
     }
 
@@ -368,16 +368,6 @@ namespace Resource
         return mClampLighting;
     }
 
-    void SceneManager::setDepthFormat(GLenum format)
-    {
-        mDepthFormat = format;
-    }
-
-    GLenum SceneManager::getDepthFormat() const
-    {
-        return mDepthFormat;
-    }
-
     void SceneManager::setAutoUseNormalMaps(bool use)
     {
         mAutoUseNormalMaps = use;
@@ -440,9 +430,9 @@ namespace Resource
         mConvertAlphaTestToAlphaToCoverage = convert;
     }
 
-    void SceneManager::setOpaqueDepthTex(osg::ref_ptr<osg::Texture2D> texture)
+    void SceneManager::setOpaqueDepthTex(osg::ref_ptr<osg::Texture2D> texturePing, osg::ref_ptr<osg::Texture2D> texturePong)
     {
-        mOpaqueDepthTex = texture;
+        mOpaqueDepthTex = { texturePing, texturePong };
     }
 
     SceneManager::~SceneManager()
@@ -930,7 +920,8 @@ namespace Resource
         shaderVisitor->setSpecularMapPattern(mSpecularMapPattern);
         shaderVisitor->setApplyLightingToEnvMaps(mApplyLightingToEnvMaps);
         shaderVisitor->setConvertAlphaTestToAlphaToCoverage(mConvertAlphaTestToAlphaToCoverage);
-        shaderVisitor->setOpaqueDepthTex(mOpaqueDepthTex);
+        shaderVisitor->setOpaqueDepthTex(mOpaqueDepthTex[0], mOpaqueDepthTex[1]);
+        shaderVisitor->setSupportsNormalsRT(mSupportsNormalsRT);
         return shaderVisitor;
     }
 }
diff --git a/components/resource/scenemanager.hpp b/components/resource/scenemanager.hpp
index b3a42bac457fd5ed4986c5e73837affcbd10648b..ba5c75f7ea98a5180f7cf939cd4a6ddf8f686440 100644
--- a/components/resource/scenemanager.hpp
+++ b/components/resource/scenemanager.hpp
@@ -91,9 +91,6 @@ namespace Resource
         void setClampLighting(bool clamp);
         bool getClampLighting() const;
 
-        void setDepthFormat(GLenum format);
-        GLenum getDepthFormat() const;
-
         /// @see ShaderVisitor::setAutoUseNormalMaps
         void setAutoUseNormalMaps(bool use);
 
@@ -112,12 +109,13 @@ namespace Resource
         void setSupportedLightingMethods(const SceneUtil::LightManager::SupportedMethods& supported);
         bool isSupportedLightingMethod(SceneUtil::LightingMethod method) const;
 
-        void setOpaqueDepthTex(osg::ref_ptr<osg::Texture2D> texture);
+        void setOpaqueDepthTex(osg::ref_ptr<osg::Texture2D> texturePing, osg::ref_ptr<osg::Texture2D> texturePong);
 
         enum class UBOBinding
         {
             // If we add more UBO's, we should probably assign their bindings dynamically according to the current count of UBO's in the programTemplate
-            LightBuffer
+            LightBuffer,
+            PostProcessor
         };
         void setLightingMethod(SceneUtil::LightingMethod method);
         SceneUtil::LightingMethod getLightingMethod() const;
@@ -195,6 +193,9 @@ namespace Resource
 
         void reportStats(unsigned int frameNumber, osg::Stats* stats) const override;
 
+        void setSupportsNormalsRT(bool supports) { mSupportsNormalsRT = supports; }
+        bool getSupportsNormalsRT() const { return mSupportsNormalsRT; }
+
     private:
 
         Shader::ShaderVisitor* createShaderVisitor(const std::string& shaderPrefix = "objects");
@@ -211,8 +212,8 @@ namespace Resource
         SceneUtil::LightingMethod mLightingMethod;
         SceneUtil::LightManager::SupportedMethods mSupportedLightingMethods;
         bool mConvertAlphaTestToAlphaToCoverage;
-        GLenum mDepthFormat;
-        osg::ref_ptr<osg::Texture2D> mOpaqueDepthTex;
+        bool mSupportsNormalsRT;
+        std::array<osg::ref_ptr<osg::Texture2D>, 2> mOpaqueDepthTex;
 
         osg::ref_ptr<Resource::SharedStateManager> mSharedStateManager;
         mutable std::mutex mSharedStateMutex;
diff --git a/components/sceneutil/clearcolor.hpp b/components/sceneutil/clearcolor.hpp
new file mode 100755
index 0000000000000000000000000000000000000000..e6e6468ecc04dbbf55d98c9f027a1dc7f9a7b7b6
--- /dev/null
+++ b/components/sceneutil/clearcolor.hpp
@@ -0,0 +1,42 @@
+#ifndef OPENMW_COMPONENTS_SCENEUTIL_CLEARCOLOR_H
+#define OPENMW_COMPONENTS_SCENEUTIL_CLEARCOLOR_H
+
+#include <osg/StateAttribute>
+#include <osg/Vec4f>
+
+namespace SceneUtil
+{
+    class ClearColor : public osg::StateAttribute
+    {
+    public:
+        ClearColor() : mMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) {}
+        ClearColor(const osg::Vec4f& color, GLbitfield mask) : mColor(color), mMask(mask) {}
+
+        ClearColor(const ClearColor& copy,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY)
+            : osg::StateAttribute(copy,copyop), mColor(copy.mColor), mMask(copy.mMask) {}
+
+        META_StateAttribute(fx, ClearColor, static_cast<osg::StateAttribute::Type>(100))
+
+        int compare(const StateAttribute& sa) const override
+        {
+            COMPARE_StateAttribute_Types(ClearColor, sa);
+
+            COMPARE_StateAttribute_Parameter(mColor);
+            COMPARE_StateAttribute_Parameter(mMask);
+
+            return 0;
+        }
+
+        void apply(osg::State& state) const override
+        {
+            glClearColor(mColor[0], mColor[1], mColor[2], mColor[3]);
+            glClear(mMask);
+        }
+
+    private:
+        osg::Vec4f mColor;
+        GLbitfield mMask;
+    };
+}
+
+#endif
diff --git a/components/sceneutil/depth.cpp b/components/sceneutil/depth.cpp
index c52bdf2ed2cb73eb7ce76fcefc38eda52be38bb4..f51c97338907b6b8bfc002349bdee84865673347 100644
--- a/components/sceneutil/depth.cpp
+++ b/components/sceneutil/depth.cpp
@@ -44,18 +44,6 @@ namespace SceneUtil
         );
     }
 
-    bool isFloatingPointDepthFormat(GLenum format)
-    {
-        constexpr std::array<GLenum, 4> formats = {
-            GL_DEPTH_COMPONENT32F,
-            GL_DEPTH_COMPONENT32F_NV,
-            GL_DEPTH32F_STENCIL8,
-            GL_DEPTH32F_STENCIL8_NV,
-        };
-
-        return std::find(formats.cbegin(), formats.cend(), format) != formats.cend();
-    }
-
     bool isDepthFormat(GLenum format)
     {
         constexpr std::array<GLenum, 8> formats = {
diff --git a/components/sceneutil/depth.hpp b/components/sceneutil/depth.hpp
index 67cf5bdb453b82f65e3ea338922abf63c6371cea..f7b1875206e68ed95cd7619ced7a4bde2143fff2 100644
--- a/components/sceneutil/depth.hpp
+++ b/components/sceneutil/depth.hpp
@@ -45,9 +45,6 @@ namespace SceneUtil
     // Returns an orthographic projection matrix for use with a reversed z-buffer.
     osg::Matrix getReversedZProjectionMatrixAsOrtho(double left, double right, double bottom, double top, double near, double far);
 
-    // Returns true if the GL format is a floating point depth format.
-    bool isFloatingPointDepthFormat(GLenum format);
-
     // Returns true if the GL format is a depth format
     bool isDepthFormat(GLenum format);
 
diff --git a/components/sceneutil/lightmanager.cpp b/components/sceneutil/lightmanager.cpp
index 45738bcad8233139151954e28928a2947985047d..3092fc6f4036cf1578fb7fb89049687b163bbb33 100644
--- a/components/sceneutil/lightmanager.cpp
+++ b/components/sceneutil/lightmanager.cpp
@@ -18,6 +18,7 @@
 
 #include <components/misc/hash.hpp>
 #include <components/misc/stringops.hpp>
+#include <components/misc/constants.hpp>
 
 #include <components/debug/debuglog.hpp>
 
@@ -839,6 +840,7 @@ namespace SceneUtil
         , mPointLightFadeEnd(copy.mPointLightFadeEnd)
         , mPointLightFadeStart(copy.mPointLightFadeStart)
         , mMaxLights(copy.mMaxLights)
+        , mPPLightBuffer(copy.mPPLightBuffer)
     {
     }
 
@@ -1001,6 +1003,9 @@ namespace SceneUtil
 
     void LightManager::update(size_t frameNum)
     {
+        if (mPPLightBuffer)
+            mPPLightBuffer->clear(frameNum);
+
         getLightIndexMap(frameNum).clear();
         mLights.clear();
         mLightsInViewSpace.clear();
@@ -1132,6 +1137,17 @@ namespace SceneUtil
                 l.mLightSource = transform.mLightSource;
                 l.mViewBound = viewBound;
                 it->second.push_back(l);
+
+                if (mPPLightBuffer && it->first->getName() == Constants::SceneCamera)
+                {
+                    const auto* light = l.mLightSource->getLight(frameNum);
+                    mPPLightBuffer->setLight(frameNum, light->getPosition() * (*viewMatrix),
+                                            light->getDiffuse(),
+                                            light->getConstantAttenuation(),
+                                            light->getLinearAttenuation(),
+                                            light->getQuadraticAttenuation(),
+                                            l.mLightSource->getRadius());
+                }
             }
         }
 
@@ -1168,6 +1184,14 @@ namespace SceneUtil
         return uniform;
     }
 
+    void LightManager::setCollectPPLights(bool enabled)
+    {
+        if (enabled)
+            mPPLightBuffer = std::make_shared<PPLightBuffer>();
+        else
+            mPPLightBuffer = nullptr;
+    }
+
     LightSource::LightSource()
         : mRadius(0.f)
         , mActorFade(1.f)
diff --git a/components/sceneutil/lightmanager.hpp b/components/sceneutil/lightmanager.hpp
index 64b7e325adb69cdb78f789c26f1845fa5cf052ea..ab48e9a23a13b7f53b2b200108e1a9636b085864 100644
--- a/components/sceneutil/lightmanager.hpp
+++ b/components/sceneutil/lightmanager.hpp
@@ -26,6 +26,64 @@ namespace SceneUtil
     class LightBuffer;
     struct StateSetGenerator;
 
+    class PPLightBuffer
+    {
+    public:
+        inline static constexpr auto sMaxPPLights = 30;
+        inline static constexpr auto sMaxPPLightsArraySize = sMaxPPLights * 3;
+
+        PPLightBuffer()
+        {
+            for (size_t i = 0; i < 2; ++i)
+            {
+                mIndex[i] = 0;
+                mUniformBuffers[i] = new osg::Uniform(osg::Uniform::FLOAT_VEC4, "omw_PointLights", sMaxPPLightsArraySize);
+                mUniformCount[i] = new osg::Uniform("omw_PointLightsCount", static_cast<int>(0));
+            }
+        }
+
+        void applyUniforms(size_t frame, osg::StateSet* stateset)
+        {
+            size_t frameId = frame % 2;
+
+            if (!stateset->getUniform("omw_PointLights"))
+                stateset->addUniform(mUniformBuffers[frameId]);
+            if (!stateset->getUniform("omw_PointLightsCount"))
+                stateset->addUniform(mUniformCount[frameId]);
+
+            mUniformBuffers[frameId]->dirty();
+            mUniformCount[frameId]->dirty();
+        }
+
+        void clear(size_t frame)
+        {
+            mIndex[frame % 2] = 0;
+        }
+
+        void setLight(size_t frame, const osg::Vec4f& position, osg::Vec4f diffuse, float ac, float al, float aq, float radius)
+        {
+            size_t frameId = frame % 2;
+            size_t i = mIndex[frameId];
+
+            if (i >= (sMaxPPLights - 1))
+                return;
+
+            i *= 3;
+
+            mUniformBuffers[frameId]->setElement(i + 0, position);
+            mUniformBuffers[frameId]->setElement(i + 1, diffuse);
+            mUniformBuffers[frameId]->setElement(i + 2, osg::Vec4f(ac, al, aq, radius));
+
+            mIndex[frameId]++;
+            mUniformCount[frameId]->set(static_cast<int>(mIndex[frameId]));
+        }
+
+    private:
+        std::array<size_t, 2> mIndex;
+        std::array<osg::ref_ptr<osg::Uniform>, 2> mUniformBuffers;
+        std::array<osg::ref_ptr<osg::Uniform>, 2> mUniformCount;
+    };
+
     enum class LightingMethod
     {
         FFP,
@@ -227,6 +285,11 @@ namespace SceneUtil
 
         osg::ref_ptr<osg::Uniform> generateLightBufferUniform(const osg::Matrixf& sun);
 
+        // Whether to collect main scene camera points lights into a buffer to be later sent to postprocessing shaders
+        void setCollectPPLights(bool enabled);
+
+        std::shared_ptr<PPLightBuffer> getPPLightsBuffer() { return mPPLightBuffer; }
+
     private:
         void initFFP(int targetLights);
         void initPerObjectUniform(int targetLights);
@@ -285,6 +348,8 @@ namespace SceneUtil
         static constexpr auto mFFPMaxLights = 8;
 
         static const std::unordered_map<std::string, LightingMethod> mLightingMethodSettingMap;
+
+        std::shared_ptr<PPLightBuffer> mPPLightBuffer;
     };
 
     /// To receive lighting, objects must be decorated by a LightListCallback. Light list callbacks must be added via
diff --git a/components/sceneutil/rtt.cpp b/components/sceneutil/rtt.cpp
index 099425330a44ed9002282e336175e194320e472a..4ab1b4c92ad4a453fa67453db76db3695e76e018 100644
--- a/components/sceneutil/rtt.cpp
+++ b/components/sceneutil/rtt.cpp
@@ -33,7 +33,7 @@ namespace SceneUtil
         , mSamples(samples)
         , mGenerateMipmaps(generateMipmaps)
         , mColorBufferInternalFormat(Color::colorInternalFormat())
-        , mDepthBufferInternalFormat(AutoDepth::depthInternalFormat())
+        , mDepthBufferInternalFormat(SceneUtil::AutoDepth::depthInternalFormat())
         , mRenderOrderNum(renderOrderNum)
         , mStereoAwareness(stereoAwareness)
     {
diff --git a/components/sceneutil/util.cpp b/components/sceneutil/util.cpp
index b70a0e248112428c118c9740b202104a84748e83..52b7be1798d4afac4543f2ca404920d51008b78a 100644
--- a/components/sceneutil/util.cpp
+++ b/components/sceneutil/util.cpp
@@ -152,42 +152,6 @@ void GlowUpdater::setDuration(float duration)
     mDuration = duration;
 }
 
-// Allows camera to render to a color and floating point depth texture with a multisampled framebuffer.
-class AttachMultisampledDepthColorCallback : public SceneUtil::NodeCallback<AttachMultisampledDepthColorCallback, osg::Node*, osgUtil::CullVisitor*>
-{
-public:
-    AttachMultisampledDepthColorCallback(osg::Texture2D* colorTex, osg::Texture2D* depthTex, int samples, int colorSamples)
-    {
-        int width = colorTex->getTextureWidth();
-        int height = colorTex->getTextureHeight();
-
-        osg::ref_ptr<osg::RenderBuffer> rbColor = new osg::RenderBuffer(width, height, colorTex->getInternalFormat(), samples, colorSamples);
-        osg::ref_ptr<osg::RenderBuffer> rbDepth = new osg::RenderBuffer(width, height, depthTex->getInternalFormat(), samples, colorSamples);
-
-        mMsaaFbo = new osg::FrameBufferObject;
-        mMsaaFbo->setAttachment(osg::Camera::COLOR_BUFFER0, osg::FrameBufferAttachment(rbColor));
-        mMsaaFbo->setAttachment(osg::Camera::DEPTH_BUFFER, osg::FrameBufferAttachment(rbDepth));
-
-        mFbo = new osg::FrameBufferObject;
-        mFbo->setAttachment(osg::Camera::COLOR_BUFFER0, osg::FrameBufferAttachment(colorTex));
-        mFbo->setAttachment(osg::Camera::DEPTH_BUFFER, osg::FrameBufferAttachment(depthTex));
-    }
-
-    void operator()(osg::Node* node, osgUtil::CullVisitor* cv)
-    {
-        osgUtil::RenderStage* renderStage = cv->getCurrentRenderStage();
-
-        renderStage->setMultisampleResolveFramebufferObject(mFbo);
-        renderStage->setFrameBufferObject(mMsaaFbo);
-
-        traverse(node, cv);
-    }
-
-private:
-    osg::ref_ptr<osg::FrameBufferObject> mFbo;
-    osg::ref_ptr<osg::FrameBufferObject> mMsaaFbo;
-};
-
 osg::Vec4f colourFromRGB(unsigned int clr)
 {
     osg::Vec4f colour(((clr >> 0) & 0xFF) / 255.0f,
diff --git a/components/serialization/osgyaml.hpp b/components/serialization/osgyaml.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..866d1db2fef940cdce40dd67ea954c27e90ba73e
--- /dev/null
+++ b/components/serialization/osgyaml.hpp
@@ -0,0 +1,64 @@
+#ifndef OPENMW_COMPONENTS_SERIALIZATION_OSGYAML_H
+#define OPENMW_COMPONENTS_SERIALIZATION_OSGYAML_H
+
+#include <yaml-cpp/yaml.h>
+
+#include <osg/Vec2f>
+#include <osg/Vec3f>
+#include <osg/Vec4f>
+
+namespace Serialization
+{
+    template <class OSGVec>
+    YAML::Node encodeOSGVec(const OSGVec& rhs)
+    {
+        YAML::Node node;
+        for (int i = 0; i < OSGVec::num_components; ++i)
+            node.push_back(rhs[i]);
+
+        return node;
+    }
+
+    template <class OSGVec>
+    bool decodeOSGVec(const YAML::Node& node, OSGVec& rhs)
+    {
+        if (!node.IsSequence() || node.size() != OSGVec::num_components)
+            return false;
+
+        for (int i = 0; i < OSGVec::num_components; ++i)
+            rhs[i] = node[i].as<typename OSGVec::value_type>();
+
+        return true;
+    }
+}
+
+namespace YAML
+{
+
+    template<>
+    struct convert<osg::Vec2f>
+    {
+        static Node encode(const osg::Vec2f& rhs) { return Serialization::encodeOSGVec(rhs); }
+
+        static bool decode(const Node& node, osg::Vec2f& rhs) { return Serialization::decodeOSGVec(node, rhs); }
+    };
+
+    template<>
+    struct convert<osg::Vec3f>
+    {
+        static Node encode(const osg::Vec3f& rhs) { return Serialization::encodeOSGVec(rhs); }
+
+        static bool decode(const Node& node, osg::Vec3f& rhs) { return Serialization::decodeOSGVec(node, rhs); }
+    };
+
+    template<>
+    struct convert<osg::Vec4f>
+    {
+        static Node encode(const osg::Vec4f& rhs) { return Serialization::encodeOSGVec(rhs); }
+
+        static bool decode(const Node& node, osg::Vec4f& rhs) { return Serialization::decodeOSGVec(node, rhs); }
+    };
+
+}
+
+#endif
\ No newline at end of file
diff --git a/components/settings/shadermanager.hpp b/components/settings/shadermanager.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..322d6169b30974e11ba18ab97383958d6af5a789
--- /dev/null
+++ b/components/settings/shadermanager.hpp
@@ -0,0 +1,174 @@
+#ifndef OPENMW_COMPONENTS_SETTINGS_SHADERMANAGER_H
+#define OPENMW_COMPONENTS_SETTINGS_SHADERMANAGER_H
+
+#include <unordered_map>
+#include <filesystem>
+#include <optional>
+#include <fstream>
+
+#include <yaml-cpp/yaml.h>
+
+#include <osg/Vec2f>
+#include <osg/Vec3f>
+#include <osg/Vec4f>
+
+#include <components/serialization/osgyaml.hpp>
+#include <components/debug/debuglog.hpp>
+
+namespace Settings
+{
+    /*
+     * Manages the shader.yaml file which is auto-generated and lives next to settings.cfg.
+     * This YAML file is simply a mapping of technique name to a list of uniforms and their values.
+     * Currently only vec2f, vec3f, vec4f, int, and float uniforms are supported.
+     *
+     * config:
+     *   TECHNIQUE:
+     *    MY_FLOAT: 10.34
+     *    MY_VEC2: [0.23, 0.34]
+     *   TECHNIQUE2:
+     *    MY_VEC3: [0.22, 0.33, 0.20]
+    */
+    class ShaderManager
+    {
+    public:
+
+        enum class Mode
+        {
+            Normal,
+            Debug
+        };
+
+        ShaderManager() = default;
+        ShaderManager(ShaderManager const&) = delete;
+        void operator=(ShaderManager const&) = delete;
+
+        static ShaderManager& get()
+        {
+            static ShaderManager instance;
+            return instance;
+        }
+
+        Mode getMode()
+        {
+            return mMode;
+        }
+
+        void setMode(Mode mode)
+        {
+            mMode = mode;
+        }
+
+        const YAML::Node& getRoot()
+        {
+            return mData;
+        }
+
+        template <class T>
+        bool setValue(const std::string& tname, const std::string& uname, const T& value)
+        {
+            if (mData.IsNull())
+            {
+                Log(Debug::Warning) << "Failed setting " << tname << ", " << uname << " : shader settings failed to load";
+                return false;
+            }
+
+            mData["config"][tname][uname] = value;
+            return true;
+        }
+
+        template <class T>
+        std::optional<T> getValue(const std::string& tname, const std::string& uname)
+        {
+            if (mData.IsNull())
+            {
+                Log(Debug::Warning) << "Failed getting " << tname << ", " << uname << " : shader settings failed to load";
+                return std::nullopt;
+            }
+
+            try
+            {
+                auto value = mData["config"][tname][uname];
+
+                if (!value)
+                    return std::nullopt;
+
+                return value.as<T>();
+            }
+            catch(const YAML::BadConversion& e)
+            {
+                Log(Debug::Warning) << "Failed retrieving " << tname << ", " << uname << " : mismatched types in config file.";
+            }
+
+            return std::nullopt;
+        }
+
+        bool load(const std::string& path)
+        {
+            mData = YAML::Null;
+            mPath = std::filesystem::path(path);
+
+            Log(Debug::Info) << "Loading shader settings file: " << mPath;
+
+            if (!std::filesystem::exists(mPath))
+            {
+                std::ofstream fout(mPath);
+                if (!fout)
+                {
+                    Log(Debug::Error) << "Failed creating shader settings file: " << mPath;
+                    return false;
+                }
+            }
+
+            try
+            {
+                mData = YAML::LoadFile(mPath.string());
+                mData.SetStyle(YAML::EmitterStyle::Block);
+
+                if (!mData["config"])
+                    mData["config"] = YAML::Node();
+
+                return true;
+            }
+            catch(const YAML::Exception& e)
+            {
+                Log(Debug::Error) << "Shader settings failed to load, " <<  e.msg;
+            }
+
+            return false;
+        }
+
+        bool save()
+        {
+            if (mData.IsNull())
+            {
+                Log(Debug::Error) << "Shader settings failed to load, settings will not be saved: " << mPath;
+                return false;
+            }
+
+            Log(Debug::Info) << "Saving shader settings file: " << mPath;
+
+            YAML::Emitter out;
+            out.SetMapFormat(YAML::Block);
+            out << mData;
+
+            std::ofstream fout(mPath.string());
+            fout << out.c_str();
+
+            if (!fout)
+            {
+                Log(Debug::Error) << "Failed saving shader settings file: " << mPath;
+                return false;
+            }
+
+            return true;
+        }
+
+    private:
+        std::filesystem::path mPath;
+        YAML::Node mData;
+        Mode mMode = Mode::Normal;
+    };
+}
+
+#endif
diff --git a/components/shader/shadervisitor.cpp b/components/shader/shadervisitor.cpp
index 8923fec6667e486614209b6bb9dda3827dfe65f7..4ef0d7a0ea69b974120e4fad727511240760157f 100644
--- a/components/shader/shadervisitor.cpp
+++ b/components/shader/shadervisitor.cpp
@@ -11,6 +11,7 @@
 #include <osg/Multisample>
 #include <osg/Texture>
 #include <osg/ValueObject>
+#include <osg/Capability>
 
 #include <osgParticle/ParticleSystem>
 
@@ -28,6 +29,50 @@
 #include "removedalphafunc.hpp"
 #include "shadermanager.hpp"
 
+namespace
+{
+    class OpaqueDepthAttribute : public osg::StateAttribute
+    {
+    public:
+        OpaqueDepthAttribute() = default;
+
+        OpaqueDepthAttribute(const OpaqueDepthAttribute& copy, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY)
+            : osg::StateAttribute(copy, copyop), mTextures(copy.mTextures), mUnit(copy.mUnit) {}
+
+        void setTexturesAndUnit(const std::array<osg::ref_ptr<osg::Texture2D>, 2>& textures, int unit)
+        {
+            mTextures = textures;
+            mUnit = unit;
+        }
+
+        META_StateAttribute(Shader, OpaqueDepthAttribute, osg::StateAttribute::TEXTURE)
+
+        int compare(const StateAttribute& sa) const override
+        {
+            COMPARE_StateAttribute_Types(OpaqueDepthAttribute, sa);
+
+            COMPARE_StateAttribute_Parameter(mTextures);
+
+            return 0;
+        }
+
+        void apply(osg::State& state) const override
+        {
+            auto index = state.getFrameStamp()->getFrameNumber() % 2;
+
+            if (!mTextures[index])
+                return;
+
+            state.setActiveTextureUnit(mUnit);
+            state.applyTextureAttribute(mUnit, mTextures[index]);
+        }
+
+    private:
+        mutable std::array<osg::ref_ptr<osg::Texture2D>, 2> mTextures;
+        int mUnit;
+    };
+}
+
 namespace Shader
 {
     /**
@@ -165,6 +210,7 @@ namespace Shader
         , mAutoUseSpecularMaps(false)
         , mApplyLightingToEnvMaps(false)
         , mConvertAlphaTestToAlphaToCoverage(false)
+        , mSupportsNormalsRT(false)
         , mShaderManager(shaderManager)
         , mImageManager(imageManager)
         , mDefaultShaderPrefix(defaultShaderPrefix)
@@ -611,6 +657,14 @@ namespace Shader
             defineMap["endLight"] = "0";
         }
 
+        if (reqs.mAlphaBlend && mSupportsNormalsRT)
+        {
+            if (reqs.mSoftParticles)
+                defineMap["disableNormals"] = "1";
+            else
+                writableStateSet->setAttribute(new osg::Disablei(GL_BLEND, 1));
+        }
+
         if (writableStateSet->getMode(GL_ALPHA_TEST) != osg::StateAttribute::INHERIT && !previousAddedState->hasMode(GL_ALPHA_TEST))
             removedState->setMode(GL_ALPHA_TEST, writableStateSet->getMode(GL_ALPHA_TEST));
         // This disables the deprecated fixed-function alpha test
@@ -629,7 +683,7 @@ namespace Shader
             updateRemovedState(*writableUserData, removedState);
         }
 
-        if (reqs.mSoftParticles)
+        if (reqs.mSoftParticles && mOpaqueDepthTex.front())
         {
             osg::ref_ptr<osg::Depth> depth = new SceneUtil::AutoDepth;
             depth->setWriteMask(false);
@@ -639,14 +693,18 @@ namespace Shader
             writableStateSet->addUniform(new osg::Uniform("particleSize", reqs.mSoftParticleSize));
             addedState->addUniform("particleSize");
 
-            writableStateSet->addUniform(new osg::Uniform("opaqueDepthTex", 2));
+            constexpr int unit = 2;
+
+            writableStateSet->addUniform(new osg::Uniform("opaqueDepthTex", unit));
             addedState->addUniform("opaqueDepthTex");
 
-            writableStateSet->setTextureAttributeAndModes(2, mOpaqueDepthTex, osg::StateAttribute::ON);
-            addedState->setTextureAttributeAndModes(2, mOpaqueDepthTex);
+            osg::ref_ptr<OpaqueDepthAttribute> opaqueDepthAttr = new OpaqueDepthAttribute;
+            opaqueDepthAttr->setTexturesAndUnit(mOpaqueDepthTex, unit);
+            writableStateSet->setAttributeAndModes(opaqueDepthAttr, osg::StateAttribute::ON|osg::StateAttribute::OVERRIDE);
+            addedState->setAttributeAndModes(opaqueDepthAttr);
         }
 
-        defineMap["softParticles"] = reqs.mSoftParticles ? "1" : "0";
+        defineMap["softParticles"] = reqs.mSoftParticles && mOpaqueDepthTex.front() ? "1" : "0";
 
         Stereo::Manager::instance().shaderStereoDefines(defineMap);
 
@@ -840,7 +898,7 @@ namespace Shader
         {
             pushRequirements(drawable);
 
-            if (partsys && mOpaqueDepthTex)
+            if (partsys)
             {
                 mRequirements.back().mSoftParticles = true;
                 mRequirements.back().mSoftParticleSize = partsys->getDefaultParticleTemplate().getSizeRange().maximum;
@@ -915,9 +973,9 @@ namespace Shader
         mConvertAlphaTestToAlphaToCoverage = convert;
     }
 
-    void ShaderVisitor::setOpaqueDepthTex(osg::ref_ptr<osg::Texture2D> texture)
+    void ShaderVisitor::setOpaqueDepthTex(osg::ref_ptr<osg::Texture2D> texturePing, osg::ref_ptr<osg::Texture2D> texturePong)
     {
-        mOpaqueDepthTex = texture;
+        mOpaqueDepthTex = { texturePing, texturePong };
     }
 
     ReinstateRemovedStateVisitor::ReinstateRemovedStateVisitor(bool allowedToModifyStateSets)
diff --git a/components/shader/shadervisitor.hpp b/components/shader/shadervisitor.hpp
index 72dec05b5ed3a496f5f360f978c7c6e59d2e70d4..cd1ca421d9efedc9e9e61b5e1fd75172d254ada2 100644
--- a/components/shader/shadervisitor.hpp
+++ b/components/shader/shadervisitor.hpp
@@ -1,6 +1,8 @@
 #ifndef OPENMW_COMPONENTS_SHADERVISITOR_H
 #define OPENMW_COMPONENTS_SHADERVISITOR_H
 
+#include <array>
+
 #include <osg/NodeVisitor>
 #include <osg/Program>
 #include <osg/Texture2D>
@@ -46,7 +48,9 @@ namespace Shader
 
         void setConvertAlphaTestToAlphaToCoverage(bool convert);
 
-        void setOpaqueDepthTex(osg::ref_ptr<osg::Texture2D> texture);
+        void setOpaqueDepthTex(osg::ref_ptr<osg::Texture2D> texturePing, osg::ref_ptr<osg::Texture2D> texturePong);
+
+        void setSupportsNormalsRT(bool supports) { mSupportsNormalsRT = supports; }
 
         void apply(osg::Node& node) override;
 
@@ -73,6 +77,8 @@ namespace Shader
 
         bool mConvertAlphaTestToAlphaToCoverage;
 
+        bool mSupportsNormalsRT;
+
         ShaderManager& mShaderManager;
         Resource::ImageManager& mImageManager;
 
@@ -87,7 +93,7 @@ namespace Shader
             bool mShaderRequired;
 
             int mColorMode;
-            
+
             bool mMaterialOverridden;
             bool mAlphaTestOverridden;
             bool mAlphaBlendOverridden;
@@ -116,7 +122,7 @@ namespace Shader
         bool adjustGeometry(osg::Geometry& sourceGeometry, const ShaderRequirements& reqs);
 
         osg::ref_ptr<const osg::Program> mProgramTemplate;
-        osg::ref_ptr<osg::Texture2D> mOpaqueDepthTex;
+        std::array<osg::ref_ptr<osg::Texture2D>, 2> mOpaqueDepthTex;
     };
 
     class ReinstateRemovedStateVisitor : public osg::NodeVisitor
diff --git a/components/std140/ubo.hpp b/components/std140/ubo.hpp
new file mode 100644
index 0000000000000000000000000000000000000000..6154cd32ac4aed8c8cd832a5ab751aa302d55f78
--- /dev/null
+++ b/components/std140/ubo.hpp
@@ -0,0 +1,162 @@
+#ifndef COMPONENTS_STD140_UBO_H
+#define COMPONENTS_STD140_UBO_H
+
+#include <osg/Vec2f>
+#include <osg/Vec4f>
+#include <osg/Matrixf>
+
+#include <cstdint>
+#include <tuple>
+#include <cstring>
+#include <string>
+#include <string_view>
+
+namespace std140
+{
+    struct Mat4
+    {
+        using Value = osg::Matrixf;
+        Value mValue;
+        static constexpr size_t sAlign = sizeof(Value);
+        static constexpr std::string_view sTypeName = "mat4";
+    };
+
+    struct Vec4
+    {
+        using Value = osg::Vec4f;
+        Value mValue;
+        static constexpr size_t sAlign = sizeof(Value);
+        static constexpr std::string_view sTypeName = "vec4";
+    };
+
+    struct Vec3
+    {
+        using Value = osg::Vec3f;
+        Value mValue;
+        static constexpr std::size_t sAlign = 4 * sizeof(osg::Vec3f::value_type);
+        static constexpr std::string_view sTypeName = "vec3";
+    };
+
+    struct Vec2
+    {
+        using Value = osg::Vec2f;
+        Value mValue;
+        static constexpr std::size_t sAlign = sizeof(Value);
+        static constexpr std::string_view sTypeName = "vec2";
+    };
+
+    struct Float
+    {
+        using Value = float;
+        Value mValue;
+        static constexpr std::size_t sAlign = sizeof(Value);
+        static constexpr std::string_view sTypeName = "float";
+    };
+
+    struct Int
+    {
+        using Value = std::int32_t;
+        Value mValue;
+        static constexpr std::size_t sAlign = sizeof(Value);
+        static constexpr std::string_view sTypeName = "int";
+    };
+
+    struct UInt
+    {
+        using Value = std::uint32_t;
+        Value mValue;
+        static constexpr std::size_t sAlign = sizeof(Value);
+        static constexpr std::string_view sTypeName = "uint";
+    };
+
+    struct Bool
+    {
+        using Value = std::int32_t;
+        Value mValue;
+        static constexpr std::size_t sAlign = sizeof(Value);
+        static constexpr std::string_view sTypeName = "bool";
+    };
+
+    template <class... CArgs>
+    class UBO
+    {
+    private:
+
+        template<typename T, typename... Args>
+        struct contains : std::bool_constant<(std::is_base_of_v<Args, T> || ...)> { };
+
+        static_assert((contains<CArgs, Mat4, Vec4, Vec3, Vec2, Float, Int, UInt, Bool>() && ...));
+
+        static constexpr size_t roundUpRemainder(size_t x, size_t multiple)
+        {
+            size_t remainder = x % multiple;
+            if (remainder == 0)
+                return 0;
+            return multiple - remainder;
+        }
+
+        template <class T>
+        static constexpr std::size_t getOffset()
+        {
+            bool found = false;
+            std::size_t size = 0;
+            ((
+                found = found || std::is_same_v<T, CArgs>,
+                size += (found ? 0 : sizeof(typename CArgs::Value) + roundUpRemainder(size, CArgs::sAlign))
+            ) , ...);
+            return size + roundUpRemainder(size, T::sAlign);
+        }
+
+    public:
+
+        static constexpr size_t getGPUSize()
+        {
+            std::size_t size = 0;
+            ((size += (sizeof(typename CArgs::Value) + roundUpRemainder(size, CArgs::sAlign))), ...);
+            return size;
+        }
+
+        static std::string getDefinition(const std::string& name)
+        {
+            std::string structDefinition = "struct " + name + " {\n";
+            ((structDefinition += ("    " + std::string(CArgs::sTypeName) + " " + std::string(CArgs::sName) + ";\n")), ...);
+            return structDefinition + "};";
+        }
+
+        using BufferType = std::array<char, getGPUSize()>;
+        using TupleType = std::tuple<CArgs...>;
+
+        template <class T>
+        typename T::Value& get()
+        {
+            return std::get<T>(mData).mValue;
+        }
+
+        template <class T>
+        const typename T::Value& get() const
+        {
+            return std::get<T>(mData).mValue;
+        }
+
+        void copyTo(BufferType& buffer) const
+        {
+            const auto copy = [&] (const auto& v) {
+                static_assert(std::is_standard_layout_v<std::decay_t<decltype(v.mValue)>>);
+                constexpr std::size_t offset = getOffset<std::decay_t<decltype(v)>>();
+                std::memcpy(buffer.data() + offset, &v.mValue, sizeof(v.mValue));
+            };
+
+            std::apply([&] (const auto& ... v) { (copy(v) , ...); }, mData);
+        }
+
+        const auto& getData() const
+        {
+            return mData;
+        }
+
+    private:
+        std::tuple<CArgs...> mData;
+    };
+}
+
+#endif
diff --git a/components/stereo/multiview.cpp b/components/stereo/multiview.cpp
index 56c1ada34938fb4e21d44d03d3ab3a74ff6a5245..de48bf6d17a83cf7f0e9eba3c79d565ad4701be1 100644
--- a/components/stereo/multiview.cpp
+++ b/components/stereo/multiview.cpp
@@ -3,7 +3,6 @@
 #include <osg/FrameBufferObject>
 #include <osg/GLExtensions>
 #include <osg/Texture2D>
-#include <osg/Texture2DMultisample>
 #include <osg/Texture2DArray>
 #include <osgUtil/RenderStage>
 #include <osgUtil/CullVisitor>
@@ -322,10 +321,7 @@ namespace Stereo
             for (unsigned i = 0; i < 2; i++)
             {
                 if (mSamples > 1)
-                {
-                    mMsaaColorTexture[i] = createTextureMsaa(sourceFormat, sourceType, internalFormat);
-                    mLayerMsaaFbo[i]->setAttachment(osg::Camera::COLOR_BUFFER, osg::FrameBufferAttachment(mMsaaColorTexture[i]));
-                }
+                    mLayerMsaaFbo[i]->setAttachment(osg::Camera::COLOR_BUFFER, osg::FrameBufferAttachment(new osg::RenderBuffer(mWidth, mHeight, internalFormat, mSamples)));
                 mColorTexture[i] = createTexture(sourceFormat, sourceType, internalFormat);
                 mLayerFbo[i]->setAttachment(osg::Camera::COLOR_BUFFER, osg::FrameBufferAttachment(mColorTexture[i]));
             }
@@ -351,10 +347,7 @@ namespace Stereo
             for (unsigned i = 0; i < 2; i++)
             {
                 if (mSamples > 1)
-                {
-                    mMsaaDepthTexture[i] = createTextureMsaa(sourceFormat, sourceType, internalFormat);
-                    mLayerMsaaFbo[i]->setAttachment(osg::Camera::PACKED_DEPTH_STENCIL_BUFFER, osg::FrameBufferAttachment(mMsaaDepthTexture[i]));
-                }
+                    mLayerMsaaFbo[i]->setAttachment(osg::Camera::PACKED_DEPTH_STENCIL_BUFFER, osg::FrameBufferAttachment(new osg::RenderBuffer(mWidth, mHeight, internalFormat, mSamples)));
                 mDepthTexture[i] = createTexture(sourceFormat, sourceType, internalFormat);
                 mLayerFbo[i]->setAttachment(osg::Camera::PACKED_DEPTH_STENCIL_BUFFER, osg::FrameBufferAttachment(mDepthTexture[i]));
             }
@@ -381,6 +374,11 @@ namespace Stereo
         return mMultiviewColorTexture;
     }
 
+    osg::Texture2DArray* MultiviewFramebuffer::multiviewDepthBuffer()
+    {
+        return mMultiviewDepthTexture;
+    }
+
     osg::Texture2D* MultiviewFramebuffer::layerColorBuffer(int i)
     {
         return mColorTexture[i];
@@ -451,22 +449,6 @@ namespace Stereo
         return texture;
     }
 
-    osg::Texture2DMultisample* MultiviewFramebuffer::createTextureMsaa(GLint sourceFormat, GLint sourceType, GLint internalFormat)
-    {
-        osg::Texture2DMultisample* texture = new osg::Texture2DMultisample;
-        texture->setTextureSize(mWidth, mHeight);
-        texture->setNumSamples(mSamples);
-        texture->setSourceFormat(sourceFormat);
-        texture->setSourceType(sourceType);
-        texture->setInternalFormat(internalFormat);
-        texture->setFilter(osg::Texture::MIN_FILTER, osg::Texture::LINEAR);
-        texture->setFilter(osg::Texture::MAG_FILTER, osg::Texture::LINEAR);
-        texture->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP_TO_EDGE);
-        texture->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_EDGE);
-        texture->setWrap(osg::Texture::WRAP_R, osg::Texture::CLAMP_TO_EDGE);
-        return texture;
-    }
-
     osg::Texture2DArray* MultiviewFramebuffer::createTextureArray(GLint sourceFormat, GLint sourceType, GLint internalFormat)
     {
         osg::Texture2DArray* textureArray = new osg::Texture2DArray;
diff --git a/components/stereo/multiview.hpp b/components/stereo/multiview.hpp
index 298d042ffca2cd4acf193d07d4929f929d24012f..cfdc721d1aadfe3d7d3fb1ac0ce224f6ba2fd200 100644
--- a/components/stereo/multiview.hpp
+++ b/components/stereo/multiview.hpp
@@ -13,7 +13,6 @@ namespace osg
     class FrameBufferObject;
     class Texture;
     class Texture2D;
-    class Texture2DMultisample;
     class Texture2DArray;
 }
 
@@ -50,6 +49,7 @@ namespace Stereo
         osg::FrameBufferObject* layerFbo(int i);
         osg::FrameBufferObject* layerMsaaFbo(int i);
         osg::Texture2DArray* multiviewColorBuffer();
+        osg::Texture2DArray* multiviewDepthBuffer();
         osg::Texture2D* layerColorBuffer(int i);
         osg::Texture2D* layerDepthBuffer(int i);
 
@@ -62,7 +62,6 @@ namespace Stereo
 
     private:
         osg::Texture2D* createTexture(GLint sourceFormat, GLint sourceType, GLint internalFormat);
-        osg::Texture2DMultisample* createTextureMsaa(GLint sourceFormat, GLint sourceType, GLint internalFormat);
         osg::Texture2DArray* createTextureArray(GLint sourceFormat, GLint sourceType, GLint internalFormat);
 
         int mWidth;
@@ -76,9 +75,7 @@ namespace Stereo
         osg::ref_ptr<osg::Texture2DArray> mMultiviewColorTexture;
         osg::ref_ptr<osg::Texture2DArray> mMultiviewDepthTexture;
         std::array<osg::ref_ptr<osg::Texture2D>, 2> mColorTexture;
-        std::array<osg::ref_ptr<osg::Texture2DMultisample>, 2> mMsaaColorTexture;
         std::array<osg::ref_ptr<osg::Texture2D>, 2> mDepthTexture;
-        std::array<osg::ref_ptr<osg::Texture2DMultisample>, 2> mMsaaDepthTexture;
     };
 }
 
diff --git a/components/stereo/stereomanager.hpp b/components/stereo/stereomanager.hpp
index 49ae685e6b8abc370838c7ba5ac51609d0debdbc..41c05b8785fb9373616e5a40dd7e7938db36bfb9 100644
--- a/components/stereo/stereomanager.hpp
+++ b/components/stereo/stereomanager.hpp
@@ -17,7 +17,6 @@ namespace osg
 {
     class FrameBufferObject;
     class Texture2D;
-    class Texture2DMultisample;
     class Texture2DArray;
 }
 
diff --git a/components/terrain/chunkmanager.cpp b/components/terrain/chunkmanager.cpp
index d57b73768f058428fe5c1f1797cf6a6af9a91f9b..badca42977f42d050bb11ceb3f995e8822eb04b5 100644
--- a/components/terrain/chunkmanager.cpp
+++ b/components/terrain/chunkmanager.cpp
@@ -180,7 +180,7 @@ std::vector<osg::ref_ptr<osg::StateSet> > ChunkManager::createPasses(float chunk
 
     float blendmapScale = mStorage->getBlendmapScale(chunkSize);
 
-    return ::Terrain::createPasses(useShaders, &mSceneManager->getShaderManager(), layers, blendmapTextures, blendmapScale, blendmapScale);
+    return ::Terrain::createPasses(useShaders, mSceneManager, layers, blendmapTextures, blendmapScale, blendmapScale);
 }
 
 osg::ref_ptr<osg::Node> ChunkManager::createChunk(float chunkSize, const osg::Vec2f &chunkCenter, unsigned char lod, unsigned int lodFlags, bool compile, TerrainDrawable* templateGeometry)
@@ -268,7 +268,7 @@ osg::ref_ptr<osg::Node> ChunkManager::createChunk(float chunkSize, const osg::Ve
             layer.mDiffuseMap = compositeMap->mTexture;
             layer.mParallax = false;
             layer.mSpecular = false;
-            geometry->setPasses(::Terrain::createPasses(mSceneManager->getForceShaders() || !mSceneManager->getClampLighting(), &mSceneManager->getShaderManager(), std::vector<TextureLayer>(1, layer), std::vector<osg::ref_ptr<osg::Texture2D> >(), 1.f, 1.f));
+            geometry->setPasses(::Terrain::createPasses(mSceneManager->getForceShaders() || !mSceneManager->getClampLighting(), mSceneManager, std::vector<TextureLayer>(1, layer), std::vector<osg::ref_ptr<osg::Texture2D> >(), 1.f, 1.f));
         }
         else
         {
diff --git a/components/terrain/material.cpp b/components/terrain/material.cpp
index 8e892a08c86c4c575674a87b510d22546e0994ec..1c6770e6bcab636828fbf8d8eff24bf062544b3a 100644
--- a/components/terrain/material.cpp
+++ b/components/terrain/material.cpp
@@ -6,8 +6,10 @@
 #include <osg/Texture2D>
 #include <osg/TexMat>
 #include <osg/BlendFunc>
+#include <osg/Capability>
 
 #include <components/stereo/stereomanager.hpp>
+#include <components/resource/scenemanager.hpp>
 #include <components/shader/shadermanager.hpp>
 #include <components/sceneutil/depth.hpp>
 
@@ -194,9 +196,10 @@ namespace
 
 namespace Terrain
 {
-    std::vector<osg::ref_ptr<osg::StateSet> > createPasses(bool useShaders, Shader::ShaderManager* shaderManager, const std::vector<TextureLayer> &layers,
+    std::vector<osg::ref_ptr<osg::StateSet> > createPasses(bool useShaders, Resource::SceneManager* sceneManager, const std::vector<TextureLayer> &layers,
                                                            const std::vector<osg::ref_ptr<osg::Texture2D> > &blendmaps, int blendmapScale, float layerTileSize)
     {
+        auto& shaderManager = sceneManager->getShaderManager();
         std::vector<osg::ref_ptr<osg::StateSet> > passes;
 
         unsigned int blendmapIndex = 0;
@@ -209,6 +212,8 @@ namespace Terrain
             if (!blendmaps.empty())
             {
                 stateset->setMode(GL_BLEND, osg::StateAttribute::ON);
+                if (sceneManager->getSupportsNormalsRT())
+                    stateset->setAttribute(new osg::Disablei(GL_BLEND, 1));
                 stateset->setRenderBinDetails(firstLayer ? 0 : 1, "RenderBin");
                 if (!firstLayer)
                 {
@@ -251,18 +256,18 @@ namespace Terrain
                 defineMap["blendMap"] = (!blendmaps.empty()) ? "1" : "0";
                 defineMap["specularMap"] = it->mSpecular ? "1" : "0";
                 defineMap["parallax"] = (it->mNormalMap && it->mParallax) ? "1" : "0";
-
+                defineMap["writeNormals"] = (it == layers.end() - 1) ? "1" : "0";
                 Stereo::Manager::instance().shaderStereoDefines(defineMap);
 
-                osg::ref_ptr<osg::Shader> vertexShader = shaderManager->getShader("terrain_vertex.glsl", defineMap, osg::Shader::VERTEX);
-                osg::ref_ptr<osg::Shader> fragmentShader = shaderManager->getShader("terrain_fragment.glsl", defineMap, osg::Shader::FRAGMENT);
+                osg::ref_ptr<osg::Shader> vertexShader = shaderManager.getShader("terrain_vertex.glsl", defineMap, osg::Shader::VERTEX);
+                osg::ref_ptr<osg::Shader> fragmentShader = shaderManager.getShader("terrain_fragment.glsl", defineMap, osg::Shader::FRAGMENT);
                 if (!vertexShader || !fragmentShader)
                 {
                     // Try again without shader. Error already logged by above
-                    return createPasses(false, shaderManager, layers, blendmaps, blendmapScale, layerTileSize);
+                    return createPasses(false, sceneManager, layers, blendmaps, blendmapScale, layerTileSize);
                 }
 
-                stateset->setAttributeAndModes(shaderManager->getProgram(vertexShader, fragmentShader));
+                stateset->setAttributeAndModes(shaderManager.getProgram(vertexShader, fragmentShader));
                 stateset->addUniform(UniformCollection::value().mColorMode);
             }
             else
diff --git a/components/terrain/material.hpp b/components/terrain/material.hpp
index 5f78af6a0627913ce69b63f956a24fa72e37a4b3..d5ef40a29e7f73e2572f77588a4432a9ae4b3638 100644
--- a/components/terrain/material.hpp
+++ b/components/terrain/material.hpp
@@ -10,9 +10,9 @@ namespace osg
     class Texture2D;
 }
 
-namespace Shader
+namespace Resource
 {
-    class ShaderManager;
+    class SceneManager;
 }
 
 namespace Terrain
@@ -26,7 +26,7 @@ namespace Terrain
         bool mSpecular;
     };
 
-    std::vector<osg::ref_ptr<osg::StateSet> > createPasses(bool useShaders, Shader::ShaderManager* shaderManager,
+    std::vector<osg::ref_ptr<osg::StateSet> > createPasses(bool useShaders, Resource::SceneManager* sceneManager,
                                                            const std::vector<TextureLayer>& layers,
                                                            const std::vector<osg::ref_ptr<osg::Texture2D> >& blendmaps, int blendmapScale, float layerTileSize);
 
diff --git a/components/vfs/archive.hpp b/components/vfs/archive.hpp
index 971ac15b39777726e0f97c6b53aaa531f6354fe6..faefe30dfea75fcdea321e530a49f9e3dc1ae5fa 100644
--- a/components/vfs/archive.hpp
+++ b/components/vfs/archive.hpp
@@ -14,6 +14,8 @@ namespace VFS
         virtual ~File() {}
 
         virtual Files::IStreamPtr open() = 0;
+
+        virtual std::string getPath() = 0;
     };
 
     class Archive
diff --git a/components/vfs/bsaarchive.hpp b/components/vfs/bsaarchive.hpp
index 1bf9cf43818bc9e9f678758ab127bd09fbb1af25..a52104efd7c53ba1ba05248a640cf245d3a61074 100644
--- a/components/vfs/bsaarchive.hpp
+++ b/components/vfs/bsaarchive.hpp
@@ -15,6 +15,8 @@ namespace VFS
 
         Files::IStreamPtr open() override;
 
+        std::string getPath() override { return mInfo->name(); }
+
         const Bsa::BSAFile::FileStruct* mInfo;
         Bsa::BSAFile* mFile;
     };
@@ -26,6 +28,8 @@ namespace VFS
 
         Files::IStreamPtr open() override;
 
+        std::string getPath() override { return mInfo->name(); }
+
         const Bsa::BSAFile::FileStruct* mInfo;
         Bsa::CompressedBSAFile* mCompressedFile;
     };
diff --git a/components/vfs/filesystemarchive.hpp b/components/vfs/filesystemarchive.hpp
index 70463d32f222ff83435c26d2cb5408d54c3271f4..fa9b50edc54662de4ff89b01fe39a2d9e7a5079f 100644
--- a/components/vfs/filesystemarchive.hpp
+++ b/components/vfs/filesystemarchive.hpp
@@ -13,6 +13,8 @@ namespace VFS
 
         Files::IStreamPtr open() override;
 
+        std::string getPath() override { return mPath; }
+
     private:
         std::string mPath;
 
diff --git a/components/vfs/manager.cpp b/components/vfs/manager.cpp
index faebc782aa03ee9e366179075e2be4d3c56c4a31..8a43eda5ee04573f872a49e0b164be66342d5a4d 100644
--- a/components/vfs/manager.cpp
+++ b/components/vfs/manager.cpp
@@ -105,6 +105,17 @@ namespace VFS
         return {};
     }
 
+    std::string Manager::getAbsoluteFileName(const std::string& name) const
+    {
+        std::string normalized = name;
+        normalize_path(normalized, mStrict);
+
+        std::map<std::string, File*>::const_iterator found = mIndex.find(normalized);
+        if (found == mIndex.end())
+            throw std::runtime_error("Resource '" + normalized + "' not found");
+        return found->second->getPath();
+    }
+
     namespace
     {
         bool startsWith(std::string_view text, std::string_view start)
diff --git a/components/vfs/manager.hpp b/components/vfs/manager.hpp
index 8568e8e7846d780e72b2a89dc170c1a72a00c200..98acfb79554e991a9736cf5b492cc4b0b4dcc0ae 100644
--- a/components/vfs/manager.hpp
+++ b/components/vfs/manager.hpp
@@ -90,6 +90,11 @@ namespace VFS
         /// @note May be called from any thread once the index has been built.
         RecursiveDirectoryRange getRecursiveDirectoryIterator(const std::string& path) const;
 
+        /// Retrieve the absolute path to the file
+        /// @note Throws an exception if the file can not be found.
+        /// @note May be called from any thread once the index has been built.
+        std::string getAbsoluteFileName(const std::string& name) const;
+
     private:
         bool mStrict;
 
diff --git a/docs/source/reference/index.rst b/docs/source/reference/index.rst
index aa6ff1d96f385e1742e43df4bd9d72dc1be09785..9aa409f7849d0c50a27a19a981539795cfc13118 100644
--- a/docs/source/reference/index.rst
+++ b/docs/source/reference/index.rst
@@ -7,4 +7,5 @@ Reference Material
 
 	modding/index
 	lua-scripting/index
+	postprocessing/index
 	documentationHowTo
diff --git a/docs/source/reference/lua-scripting/api.rst b/docs/source/reference/lua-scripting/api.rst
index 0c850d3676a76058ff37b932f15d236dd359b01e..c3b77a15eedf0b0632ef505f2fa47505f0f6d5dc 100644
--- a/docs/source/reference/lua-scripting/api.rst
+++ b/docs/source/reference/lua-scripting/api.rst
@@ -20,6 +20,7 @@ Lua API reference
     openmw_input
     openmw_ui
     openmw_camera
+    openmw_postprocessing
     openmw_aux_calendar
     openmw_aux_util
     openmw_aux_time
@@ -46,35 +47,37 @@ It can not be overloaded even if there is a lua file with the same name.
 The list of available packages is different for global and for local scripts.
 Player scripts are local scripts that are attached to a player.
 
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-| Package                                                 | Can be used        | Description                                                   |
-+=========================================================+====================+===============================================================+
-|:ref:`openmw.interfaces <Script interfaces>`             | everywhere         | | Public interfaces of other scripts.                         |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.util <Package openmw.util>`                 | everywhere         | | Defines utility functions and classes like 3D vectors,      |
-|                                                         |                    | | that don't depend on the game world.                        |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.storage <Package openmw.storage>`           | everywhere         | | Storage API. In particular can be used to store data        |
-|                                                         |                    | | between game sessions.                                      |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.core <Package openmw.core>`                 | everywhere         | | Functions that are common for both global and local scripts |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.types <Package openmw.types>`               | everywhere         | | Functions for specific types of game objects.               |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.async <Package openmw.async>`               | everywhere         | | Timers (implemented) and coroutine utils (not implemented)  |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.world <Package openmw.world>`               | by global scripts  | | Read-write access to the game world.                        |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.self <Package openmw.self>`                 | by local scripts   | | Full access to the object the script is attached to.        |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.nearby <Package openmw.nearby>`             | by local scripts   | | Read-only access to the nearest area of the game world.     |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.input <Package openmw.input>`               | by player scripts  | | User input.                                                 |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.ui <Package openmw.ui>`                     | by player scripts  | | Controls :ref:`user interface <User interface reference>`.  |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.camera <Package openmw.camera>`             | by player scripts  | | Controls camera.                                            |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+| Package                                                    | Can be used        | Description                                                   |
++============================================================+====================+===============================================================+
+|:ref:`openmw.interfaces <Script interfaces>`                | everywhere         | | Public interfaces of other scripts.                         |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.util <Package openmw.util>`                    | everywhere         | | Defines utility functions and classes like 3D vectors,      |
+|                                                            |                    | | that don't depend on the game world.                        |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.storage <Package openmw.storage>`              | everywhere         | | Storage API. In particular can be used to store data        |
+|                                                            |                    | | between game sessions.                                      |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.core <Package openmw.core>`                    | everywhere         | | Functions that are common for both global and local scripts |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.types <Package openmw.types>`                  | everywhere         | | Functions for specific types of game objects.               |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.async <Package openmw.async>`                  | everywhere         | | Timers (implemented) and coroutine utils (not implemented)  |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.world <Package openmw.world>`                  | by global scripts  | | Read-write access to the game world.                        |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.self <Package openmw.self>`                    | by local scripts   | | Full access to the object the script is attached to.        |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.nearby <Package openmw.nearby>`                | by local scripts   | | Read-only access to the nearest area of the game world.     |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.input <Package openmw.input>`                  | by player scripts  | | User input.                                                 |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.ui <Package openmw.ui>`                        | by player scripts  | | Controls :ref:`user interface <User interface reference>`.  |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.camera <Package openmw.camera>`                | by player scripts  | | Controls camera.                                            |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.postprocessing <Package openmw.postprocessing>`| by player scripts  | | Controls post-process shaders.                              |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
 
 **openmw_aux**
 
diff --git a/docs/source/reference/lua-scripting/openmw_postprocessing.rst b/docs/source/reference/lua-scripting/openmw_postprocessing.rst
new file mode 100644
index 0000000000000000000000000000000000000000..ec2f025049717eff8bc5f607a9827dbe0a8ca902
--- /dev/null
+++ b/docs/source/reference/lua-scripting/openmw_postprocessing.rst
@@ -0,0 +1,5 @@
+Package openmw.postprocessing
+=============================
+
+.. raw:: html
+   :file: generated_html/openmw_postprocessing.html
diff --git a/docs/source/reference/lua-scripting/overview.rst b/docs/source/reference/lua-scripting/overview.rst
index a075d9228e3efda20d7895e478524a6eecf79b7a..74fed7195c09ff302fb41a79aabbce211f49f71d 100644
--- a/docs/source/reference/lua-scripting/overview.rst
+++ b/docs/source/reference/lua-scripting/overview.rst
@@ -340,35 +340,37 @@ It can not be overloaded even if there is a lua file with the same name.
 The list of available packages is different for global and for local scripts.
 Player scripts are local scripts that are attached to a player.
 
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-| Package                                                 | Can be used        | Description                                                   |
-+=========================================================+====================+===============================================================+
-|:ref:`openmw.interfaces <Script interfaces>`             | everywhere         | | Public interfaces of other scripts.                         |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.util <Package openmw.util>`                 | everywhere         | | Defines utility functions and classes like 3D vectors,      |
-|                                                         |                    | | that don't depend on the game world.                        |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.storage <Package openmw.storage>`           | everywhere         | | Storage API. In particular can be used to store data        |
-|                                                         |                    | | between game sessions.                                      |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.core <Package openmw.core>`                 | everywhere         | | Functions that are common for both global and local scripts |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.types <Package openmw.types>`               | everywhere         | | Functions for specific types of game objects.               |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.async <Package openmw.async>`               | everywhere         | | Timers (implemented) and coroutine utils (not implemented)  |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.world <Package openmw.world>`               | by global scripts  | | Read-write access to the game world.                        |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.self <Package openmw.self>`                 | by local scripts   | | Full access to the object the script is attached to.        |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.nearby <Package openmw.nearby>`             | by local scripts   | | Read-only access to the nearest area of the game world.     |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.input <Package openmw.input>`               | by player scripts  | | User input                                                  |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.ui <Package openmw.ui>`                     | by player scripts  | | Controls :ref:`user interface <User interface reference>`   |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
-|:ref:`openmw.camera <Package openmw.camera>`             | by player scripts  | | Controls camera                                             |
-+---------------------------------------------------------+--------------------+---------------------------------------------------------------+
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+| Package                                                    | Can be used        | Description                                                   |
++============================================================+====================+===============================================================+
+|:ref:`openmw.interfaces <Script interfaces>`                | everywhere         | | Public interfaces of other scripts.                         |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.util <Package openmw.util>`                    | everywhere         | | Defines utility functions and classes like 3D vectors,      |
+|                                                            |                    | | that don't depend on the game world.                        |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.storage <Package openmw.storage>`              | everywhere         | | Storage API. In particular can be used to store data        |
+|                                                            |                    | | between game sessions.                                      |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.core <Package openmw.core>`                    | everywhere         | | Functions that are common for both global and local scripts |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.types <Package openmw.types>`                  | everywhere         | | Functions for specific types of game objects.               |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.async <Package openmw.async>`                  | everywhere         | | Timers (implemented) and coroutine utils (not implemented)  |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.world <Package openmw.world>`                  | by global scripts  | | Read-write access to the game world.                        |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.self <Package openmw.self>`                    | by local scripts   | | Full access to the object the script is attached to.        |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.nearby <Package openmw.nearby>`                | by local scripts   | | Read-only access to the nearest area of the game world.     |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.input <Package openmw.input>`                  | by player scripts  | | User input                                                  |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.ui <Package openmw.ui>`                        | by player scripts  | | Controls :ref:`user interface <User interface reference>`   |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.camera <Package openmw.camera>`                | by player scripts  | | Controls camera                                             |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
+|:ref:`openmw.postprocessing <Package openmw.postprocessing>`| by player scripts  | | Controls postprocess shaders                                |
++------------------------------------------------------------+--------------------+---------------------------------------------------------------+
 
 openmw_aux
 ----------
diff --git a/docs/source/reference/modding/settings/index.rst b/docs/source/reference/modding/settings/index.rst
index b1cfad44ff6c86d386983a76c46e46780d5ae703..326182cd3ce710a419d5ed453d2c6b7f89b4d710 100644
--- a/docs/source/reference/modding/settings/index.rst
+++ b/docs/source/reference/modding/settings/index.rst
@@ -71,3 +71,4 @@ The ranges included with each setting are the physically possible ranges, not re
 	navigator
 	physics
 	models
+	postprocessing
diff --git a/docs/source/reference/modding/settings/postprocessing.rst b/docs/source/reference/modding/settings/postprocessing.rst
new file mode 100644
index 0000000000000000000000000000000000000000..49b7ab78131e36ee2a4fe95c9a1ff6009e08e9f7
--- /dev/null
+++ b/docs/source/reference/modding/settings/postprocessing.rst
@@ -0,0 +1,65 @@
+Post Processing Settings
+########################
+
+enabled
+-------
+
+:Type:		boolean
+:Range:		True/False
+:Default:	False
+
+Enable or disable post processing.
+This enables use of post processing shaders, which must be installed.
+
+chain
+-----
+
+:Type:		string list
+
+Controls which post process effects are active and their order.
+It is recommended to configure the settings and order of shaders through the in game HUD. By default this is available with the F2 key.
+Note, an empty chain will not disable post processing.
+
+This setting has no effect if :ref:`enabled` is set to false.
+
+live reload
+-----------
+
+:Type:		boolean
+:Range:		True/False
+:Default:	False
+
+Automatically reloads a shader if the file has been changed. This is useful for debugging and writing shaders yourself.
+
+.. warning::
+    This should be disabled for normal gameplay
+
+hdr exposure time
+-----------------
+
+:Type:      float
+:Range:     0.0 to 1.0
+:Default:   0.05
+
+Use for eye adaptation to control speed at which average scene luminance can change from one frame to the next.
+Average scene luminance is used in some shader effects for features such as dynamic eye adaptation.
+Smaller values will cause slower changes in scene luminance. This is most impactful when the brightness
+drastically changes quickly, like when entering a dark cave or exiting an interior and looking into a bright sun.
+
+This settings has no effect when HDR is disabled or :ref:`enabled` is set to false.
+
+transparent postpass
+--------------------
+
+:Type:      boolean
+:Range:     True/False
+:Default:   True
+
+Re-renders transparent objects with alpha-clipping forced with a fixed threshold. This is particularly important with vanilla content, where blended
+objects usually have depth writes disabled and massive margins between the geometry and texture alpha.
+
+
+.. warning::
+    This can be quite costly with vanilla assets. For best performance it is recommended to use a mod replacer which
+    uses alpha tested foliage and disable this setting. Morrowind Optimizaton Patch is a great option. 
+    If you are not using any shaders which utilize the depth buffer this setting should be disabled.
diff --git a/docs/source/reference/modding/settings/windows.rst b/docs/source/reference/modding/settings/windows.rst
index d745c765d9e7ee2de217f927ed835d8b228a4bcb..6426802ab9dcaf87a64694899f619d2065f1be4e 100644
--- a/docs/source/reference/modding/settings/windows.rst
+++ b/docs/source/reference/modding/settings/windows.rst
@@ -256,7 +256,21 @@ settings
 	w = 0.33
 
 	h = 0.66
+
 The settings window.
 Activated by clicking Options in the main menu.
 
+postprocessor
+-------------
+
+:Default:
+	x = 0.01
+
+	y = 0.02
+
+	w = 0.44
+
+	h = 0.95
 
+The postprocessor window used to configure shaders.
+Activated by pressing the F2 key.
diff --git a/docs/source/reference/postprocessing/index.rst b/docs/source/reference/postprocessing/index.rst
new file mode 100644
index 0000000000000000000000000000000000000000..061d76f37dd033fcfcadea8b14e73e9c2f9d5178
--- /dev/null
+++ b/docs/source/reference/postprocessing/index.rst
@@ -0,0 +1,12 @@
+######################
+OpenMW Post Processing
+######################
+
+.. toctree::
+    :caption: Table of Contents
+    :includehidden:
+    :maxdepth: 2
+
+    overview
+    omwfx
+    lua
\ No newline at end of file
diff --git a/docs/source/reference/postprocessing/lua.rst b/docs/source/reference/postprocessing/lua.rst
new file mode 100644
index 0000000000000000000000000000000000000000..cdc6dd93d0c5bfa64ca9b4d082a1dfd0293e1de0
--- /dev/null
+++ b/docs/source/reference/postprocessing/lua.rst
@@ -0,0 +1,137 @@
+####################
+Connecting With Lua
+####################
+
+Overview
+########
+
+Every shader can be controlled through the Lua scripting system. While shaders can be disabled and enabled,
+shader uniforms can also be controlled. For details reference the API documentation, found :doc:`here<../lua-scripting/openmw_postprocessing>`.
+
+Toggling Shaders With a Keybind
+###############################
+
+In this example, we use the desaturation shader created in the previous section and bind the ``x`` key to toggle it on and off.
+It is assumed the shader has the filename ``desaturate.omwfx`` in this example.
+
+.. code-block:: none
+
+    uniform_float uDesaturationFactor {
+        default = 0.5;
+        min = 0.0;
+        max = 1.0;
+        step = 0.05;
+        description = "Desaturation factor. A value of 1.0 is full grayscale.";
+    }
+
+    fragment desaturate {
+        omw_In vec2 omw_TexCoord;
+
+        void main()
+        {
+            // fetch scene texture from last shader
+            vec4 scene = omw_GetLastShader(omw_TexCoord);
+
+            // desaturate RGB component
+            const vec3 luminance = vec3(0.299, 0.587, 0.144);
+            float gray = dot(luminance, scene.rgb);
+
+            omw_FragColor = vec4(mix(scene.rgb, vec3(gray), uDesaturationFactor), scene.a);
+        }
+    }
+
+    technique {
+        description = "Desaturates scene";
+        passes = desaturate;
+        version = "1.0";
+        author = "Fargoth";
+        passes = desaturate;
+    }
+
+
+Next, a script that is attached to the player is needed. The shader is loaded first, then toggled on and off in response to key presses.
+Below is a working example to illustrate this.
+
+.. code-block:: Lua
+
+    local input = require('openmw.input')
+    local postprocessing = require('openmw.postprocessing')
+
+    local shader = postprocessing.load('desaturate')
+
+    return {
+        engineHandlers = {
+            onKeyPress = function(key)
+                if key.code == input.KEY.X then
+                    if shader:isEnabled() then
+                        shader:disable()
+                    else
+                        shader:enable()
+                    end
+                end
+            end
+        }
+    }
+
+Hiding Shader From the HUD
+##########################
+
+If the HUD is opened (default with ``F2``) you will notice it lists all available shaders. If you want your shader to be completely
+hidden in this HUD, this can done by adding the ``hidden`` flag to the main technique block.
+
+.. code-block:: none
+
+    technique {
+        description = "Desaturates scene";
+        passes = desaturate;
+        version = "1.0";
+        author = "Fargoth";
+        passes = desaturate;
+        flags = hidden;
+    }
+
+This flag is usually used when the shader is associated with something special, like special weather, spell, or alcohol effects.
+
+Controlling Uniforms
+####################
+
+By default, any uniform you defined will not be exposed to Lua, you must set the ``static`` flag to ``false`` in every uniform block for which you want exposed.
+For example, to set the ``uDesaturationFactor`` uniform from a Lua script, we must define it as follows.
+
+.. code-block:: none
+
+    uniform_float uDesaturationFactor {
+        default = 0.5;
+        min = 0.0;
+        max = 1.0;
+        step = 0.05;
+        description = "Desaturation factor. A value of 1.0 is full grayscale.";
+        static = false;
+    }
+
+In some player Lua script, this uniform can then be freely set. When a uniform is set to ``static`` it will no longer show up in the HUD.
+Here, instead of disabling and enabling the shader we set the factor to ``0`` or ``1``, respectively.
+
+.. code-block:: Lua
+
+    local input = require('openmw.input')
+    local postprocessing = require('openmw.postprocessing')
+
+    local shader = postprocessing.load('desaturate')
+    local factor = 0
+
+    return {
+        engineHandlers = {
+            onKeyPress = function(key)
+                if key.code == input.KEY.X then
+                    if factor == 0 then
+                        factor = 1
+                    else
+                        factor = 0
+                    end
+
+                    shader:setFloat('uDesaturationFactor', factor)
+                end
+            end
+        }
+    }
\ No newline at end of file
diff --git a/docs/source/reference/postprocessing/omwfx.rst b/docs/source/reference/postprocessing/omwfx.rst
new file mode 100644
index 0000000000000000000000000000000000000000..eab70ba9d550f961a87a3e5f3d0162c2596d6757
--- /dev/null
+++ b/docs/source/reference/postprocessing/omwfx.rst
@@ -0,0 +1,866 @@
+#########################
+OMWFX Language Reference
+#########################
+
+Overview
+########
+
+Shaders are written in a OpenMW specific ``*.omwfx`` format. This is a light
+wrapper around GLSL, so a basic understanding of GLSL should be acquired before
+attempting to write any shaders. Every shader must be contained within a single
+``*.omwfx`` file, ``#include`` directives are currently unsupported.
+
+By default, all shaders only guarantee support of GLSL 120 features. To target a
+newer GLSL version, you must specify it in the `technique`_ block properties. If
+the specified version is not supported on the target machine, the shader will
+not load.
+
+Reserved Keywords
+#################
+
+GLSL doesn't support namespaces, instead reserved prefixes are used. Do not
+attempt to name anything starting with ``_`` or ``omw``, this will cause
+name clashes.
+
+
+Builtin Samplers
+################
+
++------------------+---------------------------+---------------------------------------------+
+| GLSL Type        | Name                      | Description                                 |
++==================+===========================+=============================================+
+| sampler2D[Array] |``omw_SamplerLastShader``  | Color output of the last shader             |
++------------------+---------------------------+---------------------------------------------+
+| sampler2D[Array] |``omw_SamplerLastPass``    | Color output of the last pass               |
++------------------+---------------------------+---------------------------------------------+
+| sampler2D[Array] |``omw_SamplerDepth``       | Non-linear normalized depth                 |
++------------------+---------------------------+---------------------------------------------+
+| sampler2D[Array] |``omw_SamplerNormals``     | Normalized world-space normals [0, 1]       |
++------------------+---------------------------+---------------------------------------------+
+
+These are included in a common header in every pass, they do not need to be re-defined.
+It is recommended to use the accessor functions to retrieve the sampler value.
+OpenMW supports multiview rendering, so these samplers will either be a
+``sampler2D`` or ``sampler2DArray``. If you want more control over how you
+sample textures, use the ``OMW_MULTIVIEW`` macro to determine the appropriate functions to use.
+
+
+Builtin Uniforms
+################
+
++-------------+------------------------------+--------------------------------------------------+
+| GLSL Type   | Name                         | Description                                      |
++=============+==============================+==================================================+
+| mat4        | ``omw.projectionMatrix``     | The camera's projection matrix                   |
++-------------+------------------------------+--------------------------------------------------+
+| mat4        | ``omw.invProjectionMatrix``  | The inverse of the camera's projection matrix    |
++-------------+------------------------------+--------------------------------------------------+
+| mat4        | ``omw.viewMatrix``           | The camera's view matrix                         |
++-------------+------------------------------+--------------------------------------------------+
+| mat4        | ``omw.prevViewMatrix``       | The camera's previous frame view matrix          |
++-------------+------------------------------+--------------------------------------------------+
+| mat4        | ``omw.invViewMatrix``        | The inverse of the camera's view matrix          |
++-------------+------------------------------+--------------------------------------------------+
+| vec4        | ``omw.eyePos``               | The camera's eye position                        |
++-------------+------------------------------+--------------------------------------------------+
+| vec4        | ``omw.eyeVec``               | The normalized camera's eye vector               |
++-------------+------------------------------+--------------------------------------------------+
+| vec4        | ``omw.fogColor``             | The RGBA color of fog                            |
++-------------+------------------------------+--------------------------------------------------+
+| vec4        | ``omw.sunColor``             | The RGBA color of sun                            |
++-------------+------------------------------+--------------------------------------------------+
+| vec4        | ``omw.sunPos``               | The normalized sun direction                     |
+|             |                              |                                                  |
+|             |                              | When the sun is set `omw.sunpos.z` is negated    |
++-------------+------------------------------+--------------------------------------------------+
+| vec2        | ``omw.resolution``           | The render target's resolution                   |
++-------------+------------------------------+--------------------------------------------------+
+| vec2        | ``omw.rcpResolution``        | Reciprocal of the render target resolution       |
++-------------+------------------------------+--------------------------------------------------+
+| vec2        | ``omw.fogNear``              | The units at which the fog begins to render      |
++-------------+------------------------------+--------------------------------------------------+
+| float       | ``omw.fogFar``               | The units at which the fog ends                  |
++-------------+------------------------------+--------------------------------------------------+
+| float       | ``omw.near``                 | The camera's near clip                           |
++-------------+------------------------------+--------------------------------------------------+
+| float       | ``omw.far``                  | The camera's far clip                            |
++-------------+------------------------------+--------------------------------------------------+
+| float       | ``omw.gameHour``             | The game hour in range [0,24)                    |
++-------------+------------------------------+--------------------------------------------------+
+| float       | ``omw.sunVis``               | The sun's visibility between [0, 1]              |
+|             |                              |                                                  |
+|             |                              | Influenced by types of weather                   |
+|             |                              |                                                  |
+|             |                              | Closer to zero during overcast weathers          |
++-------------+------------------------------+--------------------------------------------------+
+| float       | ``omw.waterHeight``          | The water height of current cell                 |
+|             |                              |                                                  |
+|             |                              | Exterior water level is always zero              |
++-------------+------------------------------+--------------------------------------------------+
+| float       | ``omw.simulationTime``       | The time in milliseconds since simulation began  |
++-------------+------------------------------+--------------------------------------------------+
+| float       | ``omw.deltaSimulationTime``  | The change in `omw.simulationTime`               |
++-------------+------------------------------+--------------------------------------------------+
+| float       | ``omw.windSpeed``            | The current wind speed                           |
++-------------+------------------------------+--------------------------------------------------+
+| float       | ``omw.weatherTransition``    | The transition factor between weathers [0, 1]    |
++-------------+------------------------------+--------------------------------------------------+
+| int         | ``omw.weatherID``            | The current weather ID                           |
++-------------+------------------------------+--------------------------------------------------+
+| int         | ``omw.nextWeatherID``        | The next weather ID                              |
++-------------+------------------------------+--------------------------------------------------+
+| bool        | ``omw.isUnderwater``         | True if player is submerged underwater           |
++-------------+------------------------------+--------------------------------------------------+
+| bool        | ``omw.isInterior``           | True if player is in an interior                 |
+|             |                              |                                                  |
+|             |                              | False for interiors that behave like exteriors   |
++-------------+------------------------------+--------------------------------------------------+
+
+
+Builtin Macros
+##############
+
++------------------+----------------+---------------------------------------------------------------------------+
+| Macro            | Definition     | Description                                                               |
++==================+================+===========================================================================+
+|``OMW_REVERSE_Z`` | ``0`` or ``1`` | Whether a reversed depth buffer is in use.                                |
+|                  |                |                                                                           |
+|                  |                | ``0``  Depth sampler will be in range [1, 0]                              |
+|                  |                |                                                                           |
+|                  |                | ``1``  Depth sampler will be in range [0, 1]                              |
++------------------+----------------+---------------------------------------------------------------------------+
+|``OMW_RADIAL_FOG``| ``0`` or ``1`` | Whether radial fog is in use.                                             |
+|                  |                |                                                                           |
+|                  |                | ``0``  Fog is linear                                                      |
+|                  |                |                                                                           |
+|                  |                | ``1``  Fog is radial                                                      |
++------------------+----------------+---------------------------------------------------------------------------+
+| ``OMW_HDR``      | ``0`` or ``1`` | Whether average scene luminance is computed every frame.                  |
+|                  |                |                                                                           |
+|                  |                | ``0``  Average scene luminance is not computed                            |
+|                  |                |                                                                           |
+|                  |                | ``1``  Average scene luminance is computed                                |
++------------------+----------------+---------------------------------------------------------------------------+
+|  ``OMW_NORMALS`` | ``0`` or ``1`` | Whether normals are available as a sampler in the technique.              |
+|                  |                |                                                                           |
+|                  |                | ``0``  Normals are not available                                          |
+|                  |                |                                                                           |
+|                  |                | ``1``  Normals are available.                                             |
++------------------+----------------+---------------------------------------------------------------------------+
+| ``OMW_MULTIVIEW``| ``0`` or ``1`` | Whether multiview rendering is in use.                                    |
+|                  |                |                                                                           |
+|                  |                | ``0``  Multiview not in use                                               |
+|                  |                |                                                                           |
+|                  |                | ``1``  Multiview in use.                                                  |
++------------------+----------------+---------------------------------------------------------------------------+
+
+
+Builtin Functions
+#################
+
+The following functions can be accessed in any fragment or vertex shader.
+
++----------------------------------------+-------------------------------------------------------------------------------+
+| Function                               | Description                                                                   |
++========================================+===============================================================================+
+| ``float omw_GetDepth(vec2)``           |  Returns the depth value from a sampler given a uv coordinate.                |
+|                                        |                                                                               |
+|                                        |  Reverses sampled value when ``OMW_REVERSE_Z`` is set.                        |
++----------------------------------------+-------------------------------------------------------------------------------+
+| ``float omw_GetEyeAdaptation()``       |  Returns the average scene luminance in range [0, 1].                         |
+|                                        |                                                                               |
+|                                        |  If HDR is not in use, this returns `1.0`                                     |
+|                                        |                                                                               |
+|                                        |  Scene luminance is always calculated on original scene texture.              |
++----------------------------------------+-------------------------------------------------------------------------------+
+| ``vec4 omw_GetDepth(vec2 uv)``         | Returns non-linear normalized depth                                           |
++----------------------------------------+-------------------------------------------------------------------------------+
+| ``vec4 omw_GetLastShader(vec2 uv)``    | Returns RGBA color output of the last shader                                  |
++----------------------------------------+-------------------------------------------------------------------------------+
+| ``vec4 omw_GetLastPass(vec2 uv)``      | Returns RGBA color output of the last pass                                    |
++----------------------------------------+-------------------------------------------------------------------------------+
+| ``vec3 omw_GetNormals(vec2 uv)``       | Returns normalized worldspace normals [-1, 1]                                 |
+|                                        |                                                                               |
+|                                        | The values in sampler are in [0, 1] but are transformed to [-1, 1]            |
++----------------------------------------+-----------------------+-------------------------------------------------------+
+
+
+Special Attributes
+##################
+
+To maintain maximum compatability with future releases, OpenMW defines specific keywords, attributes, and functions for you to use. These should be used instead of their
+GLSL equivalent. Refer to the table below to view these mappings.
+
++-------------------+---------------------------------------------------------+
+| .omwfx            | Description                                             |
++===================+=========================================================+
+| omw_In            |  use in place of ``in`` and ``varying``                 |
++-------------------+---------------------------------------------------------+
+| omw_Out           |  use in place of ``out`` and ```varying``               |
++-------------------+---------------------------------------------------------+
+| omw_Position      |  use in place of ``gl_Position``                        |
++-------------------+---------------------------------------------------------+
+| omw_Vertex        |  use in place of ``gl_Vertex``                          |
++-------------------+---------------------------------------------------------+
+| omw_Fragment      |  use in place of ``gl_FragData[*]`` and ``gl_FragColor``|
++-------------------+---------------------------------------------------------+
+| omw_Texture1D()   |  use in place of ``texture1D()`` or ``texture()``       |
++-------------------+---------------------------------------------------------+
+| omw_Texture2D()   |  use in place of ``texture2D()`` or ``texture()``       |
++-------------------+---------------------------------------------------------+
+| omw_Texture3D()   |  use in place of ``texture3D()`` or ``texture()``       |
++-------------------+---------------------------------------------------------+
+
+Blocks
+######
+
+``fragment``
+*************
+
+Declare your passes with ``fragment`` followed by a unique name. We will define the order of these passes later on.
+Each ``fragment`` block must contain valid GLSL. Below is a simple example of defining two passes.
+
+.. code-block:: none
+
+    fragment pass {
+        void main()
+        {
+            omw_FragColor = vec4(1.0);
+        }
+    }
+
+    fragment otherPass {
+
+        omw_In vec2 omw_TexCoord;
+
+        void main()
+        {
+            omw_FragColor = omw_GetLastPass(omw_TexCoord);
+        }
+    }
+
+``vertex``
+***********
+
+For every ``fragment`` block you declare, OpenMW generates a default vertex shader if you do not define one. This is used to draw the fullscreen triangle used in postprocessing.
+This means you rarely need to use a custom vertex shader. Using a vertex shader can sometimes be useful when you need to do lots of complicated calculations that don't rely on pixel location.
+The vertex shader only invocates on the `3` vertices of the fullscreen triangle.
+Below is an example of passing a value through a custom vertex shader to the fragment shader.
+
+.. code-block:: none
+
+    vertex pass {
+        #if OMW_USE_BINDINGS
+            omw_In vec2 omw_Vertex;
+        #endif
+
+        uniform sampler2D noiseSampler;
+
+        omw_Out vec2 omw_TexCoord;
+
+        // custom output from vertex shader
+        omw_Out float noise;
+
+        void main()
+        {
+            omw_Position = vec4(omw_Vertex.xy, 0.0, 1.0);
+            omw_TexCoord = omw_Position.xy * 0.5 + 0.5;
+
+            noise = sqrt(omw_Texture2D(noiseSampler, vec2(0.5, 0.5)).r);
+        }
+    }
+
+    fragment pass {
+        omw_Out vec2 omw_TexCoord;
+
+        // our custom output from the vertex shader is available
+        omw_Out float noise;
+
+        void main()
+        {
+            omw_FragColor = vec4(1.0);
+        }
+    }
+
+
+``technique``
+*************
+
+Exactly one ``technique`` block is required for every shader file. In this we define important traits like author, description, requirements, and flags.
+
+
++------------------+--------------------+---------------------------------------------------+
+| Property         | Type               | Description                                       |
++==================+====================+===================================================+
+| passes           | literal list       | ``,`` separated list of pass names                |
++------------------+--------------------+---------------------------------------------------+
+| version          | string             | Shader version that shows in HUD                  |
++------------------+--------------------+---------------------------------------------------+
+| description      | string             | Shader description that shows in HUD              |
++------------------+--------------------+---------------------------------------------------+
+| author           | string             | Shader authors that shows in HUD                  |
++------------------+--------------------+---------------------------------------------------+
+| glsl_Version     | integer            | GLSL version                                      |
++------------------+--------------------+---------------------------------------------------+
+| glsl_profile     | string             | GLSL profile, like ``compatability``              |
++------------------+--------------------+---------------------------------------------------+
+| glsl_extensions  | literal list       | ``,`` separated list of required GLSL extensions  |
++------------------+--------------------+---------------------------------------------------+
+| hdr              | boolean            | Whether HDR eye adaptation is required.           |
++------------------+--------------------+---------------------------------------------------+
+| pass_normals     | boolean            | Pass normals from the forward passes.             |
+|                  |                    |                                                   |
+|                  |                    | If unsupported, `OMW_NORMALS` will be set to `0`  |
++------------------+--------------------+---------------------------------------------------+
+| flags            | `SHADER_FLAG`_     | ``,`` separated list of shader flags              |
++------------------+--------------------+---------------------------------------------------+
+
+In the code snippet below, a shader is defined that requires GLSL `330`, HDR capatiblities, and is only enabled underwater in exteriors.
+
+.. code-block:: none
+
+    fragment dummy {
+        void main()
+        {
+            omw_FragColor = vec4(0.0);
+        }
+    }
+
+    technique {
+        passes = dummy;
+        glsl_version = 330;
+        hdr = true;
+        flags = disable_interiors | disable_abovewater;
+    }
+
+
+``sampler_*``
+*************
+
+Any texture in the VFS can be loaded by a shader. All passes within the technique will have access to this texture as a sampler.
+OpenMW currently supports ``1D``, ``2D``, and ``3D`` texture samplers, cubemaps can not yet be loaded.
+
++-------------+
+| Block       |
++=============+
+| sampler_1d  |
++-------------+
+| sampler_2d  |
++-------------+
+| sampler_3d  |
++-------------+
+
+.. warning::
+    OpenMW vertically flips all DDS textures when loading them, with the exception of ``3D`` textures.
+
+
+The properites for a ``sampler_*`` block are as following.
+The only required property for a texture is its ``source``.
+
++-----------------------+-----------------------+
+| Property              | Type                  |
++=======================+=======================+
+|``source``             |  string               |
++-----------------------+-----------------------+
+|``min_filter``         | `FILTER_MODE`_        |
++-----------------------+-----------------------+
+|``mag_filter``         | `FILTER_MODE`_        |
++-----------------------+-----------------------+
+|``wrap_s``             | `WRAP_MODE`_          |
++-----------------------+-----------------------+
+|``wrap_t``             | `WRAP_MODE`_          |
++-----------------------+-----------------------+
+|``wrap_r``             | `WRAP_MODE`_          |
++-----------------------+-----------------------+
+|``compression``        | `COMPRESSION_MODE`_   |
++-----------------------+-----------------------+
+|``source_format``      | `SOURCE_FORMAT`_      |
++-----------------------+-----------------------+
+|``source_type``        | `SOURCE_TYPE`_        |
++-----------------------+-----------------------+
+|``internal_format``    | `INTERNAL_FORMAT`_    |
++-----------------------+-----------------------+
+
+In the code snippet below, a simple noise texture is loaded with nearest filtering.
+
+.. code-block:: none
+
+    sampler_2d noise {
+        source = "textures/noise.png";
+        mag_filter = nearest;
+        min_filter = nearest;
+    }
+
+To use the sampler, define the appropriately named `sampler2D` in any of your passes.
+
+.. code-block:: none
+
+    fragment pass {
+        omw_In vec2 omw_TexCoord;
+
+        uniform sampler2D noise;
+
+        void main()
+        {
+            // ...
+            vec4 noise = omw_Texture2D(noise, omw_TexCoord);
+        }
+    }
+
+``uniform_*``
+**************
+
+It is possible to define settings for your shaders that can be adjusted by either users or a Lua script.
+
+
++-----------------+----------+----------+----------+---------+----------+--------------+---------+
+| Block           | default  | min      | max      | static  | step     | description  | header  |
++=================+==========+==========+==========+=========+==========+==============+=========+
+|``uniform_bool`` | boolean  | x        | x        | boolean | x        | string       | string  |
++-----------------+----------+----------+----------+---------+----------+--------------+---------+
+|``uniform_float``| float    | float    | float    | boolean | float    | string       | string  |
++-----------------+----------+----------+----------+---------+----------+--------------+---------+
+|``uniform_int``  | integer  | integer  | integer  | boolean | integer  | string       | string  |
++-----------------+----------+----------+----------+---------+----------+--------------+---------+
+|``uniform_vec2`` | vec2     | vec2     | vec2     | boolean | vec2     | string       | string  |
++-----------------+----------+----------+----------+---------+----------+--------------+---------+
+|``uniform_vec3`` | vec3     | vec3     | vec3     | boolean | vec3     | string       | string  |
++-----------------+----------+----------+----------+---------+----------+--------------+---------+
+|``uniform_vec4`` | vec4     | vec4     | vec4     | boolean | vec4     | string       | string  |
++-----------------+----------+----------+----------+---------+----------+--------------+---------+
+
+The ``description`` field is used to display a toolip when viewed in the in-game HUD. The ``header`` field
+field can be used to organize uniforms into groups in the HUD.
+
+If you would like a uniform to be adjustable with Lua API you `must` set ``static = false;``. Doing this
+will also remove the uniform from the players HUD.
+
+Below is an example of declaring a ``vec3`` uniform.
+
+.. code-block:: none
+
+    uniform_vec3 uColor {
+        default = vec3(0,1,1);
+        min = vec3(0,0,0);
+        max = vec3(1,1,1);
+        step = vec3(0.1, 0.1, 0.1);
+        description = "Color uniform";
+        static = true;
+        header = "Colors";
+    }
+
+To use the uniform you can reference it in any pass, it should **not** be declared with the ``uniform`` keyword.
+
+.. code-block:: none
+
+    fragment pass {
+        void main()
+        {
+            // ...
+            vec3 color = uColor;
+        }
+    }
+
+
+``render_target``
+*****************
+
+Normally when defining passes, OpenMW will take care of setting up all of the render targets. Sometimes, this behavior
+is not wanted and you want a custom render target.
+
+
++------------------+---------------------+-----------------------------------------------------------------------------+
+| Property         | Type                | Description                                                                 |
++==================+=====================+=============================================================================+
+| min_filter       | `FILTER_MODE`_      | x                                                                           |
++------------------+---------------------+-----------------------------------------------------------------------------+
+| mag_filter       | `FILTER_MODE`_      | x                                                                           |
++------------------+---------------------+-----------------------------------------------------------------------------+
+| wrap_s           | `WRAP_MODE`_        | x                                                                           |
++------------------+---------------------+-----------------------------------------------------------------------------+
+| wrap_t           | `WRAP_MODE`_        | x                                                                           |
++------------------+---------------------+-----------------------------------------------------------------------------+
+| internal_format  | `INTERNAL_FORMAT`_  | x                                                                           |
++------------------+---------------------+-----------------------------------------------------------------------------+
+| source_type      | `SOURCE_TYPE`_      | x                                                                           |
++------------------+---------------------+-----------------------------------------------------------------------------+
+| source_format    | `SOURCE_FORMAT`_    | x                                                                           |
++------------------+---------------------+-----------------------------------------------------------------------------+
+| width_ratio      | float               | Automatic width as a percentage of screen width                             |
++------------------+---------------------+-----------------------------------------------------------------------------+
+| height_ratio     | float               | Automatic width as a percentage of screen height                            |
++------------------+---------------------+-----------------------------------------------------------------------------+
+| width            | float               | Width in pixels                                                             |
++------------------+---------------------+-----------------------------------------------------------------------------+
+| height           | float               | Height in pixels                                                            |
++------------------+---------------------+-----------------------------------------------------------------------------+
+| mipmaps          | boolean             | Whether mipmaps should be generated every frame                             |
++------------------+---------------------+-----------------------------------------------------------------------------+
+
+
+To use the render target you must assign passes to it, along with any optional clear modes or custom blend modes.
+
+In the code snippet below a rendertarget is used to draw the red cannel of a scene at half resolution.
+
+.. code-block:: none
+
+    render_target RT_Downsample {
+        width_ratio = 0.5;
+        height_ratio = 0.5;
+        internal_format = r16f;
+        source_type = float;
+        source_format = red;
+    }
+
+    fragment downsample2x(target=RT_Downsample) {
+
+        omw_In vec2 omw_TexCoord;
+
+        void main()
+        {
+            omw_FragColor.r = omw_GetLastShader(omw_TexCoord).r;
+        }
+    }
+
+Now, if we ever run the `downsample2x` pass it will write to the target buffer instead of the default
+one assigned by the engine.
+
+To use the uniform you can reference it in any pass, it should **not** be declared with the ``uniform`` keyword.
+
+.. code-block:: none
+
+    fragment pass {
+        void main()
+        {
+            // ...
+            vec3 color = uColor;
+        }
+    }
+
+Simple Example
+##############
+
+Let us go through a simple example in which we apply a simple desaturation
+filter with a user-configurable factor.
+
+Our first step is defining our user-configurable variable. In this case all we
+want is a normalized value between 0 and 1 to influence the amount of
+desaturation to apply to the scene. Here we setup a new variable of type
+``float``, define a few basic properties, and give it a tooltip description.
+
+.. code-block:: none
+
+    uniform_float uDesaturationFactor {
+        default = 0.5;
+        min = 0.0;
+        max = 1.0;
+        step = 0.05;
+        static = true;
+        description = "Desaturation factor. A value of 1.0 is full grayscale.";
+    }
+
+Now, we can setup our first pass. Remember a pass is just a pixel shader invocation.
+
+.. code-block:: none
+
+    fragment desaturate {
+        omw_In vec2 omw_TexCoord;
+
+        void main()
+        {
+            // fetch scene texture from last shader
+            vec4 scene = omw_GetLastShader(omw_TexCoord);
+
+            // desaturate RGB component
+            const vec3 luminance = vec3(0.299, 0.587, 0.144);
+            float gray = dot(luminance, scene.rgb);
+
+            omw_FragColor = vec4(mix(scene.rgb, vec3(gray), uDesaturationFactor), scene.a);
+        }
+    }
+
+Next we can define our ``technique`` block, which is in charge of glueing
+together passes, setting up metadata, and setting up various flags.
+
+.. code-block:: none
+
+    technique {
+        description = "Desaturates scene";
+        passes = desaturate;
+        version = "1.0";
+        author = "Fargoth";
+        passes = desaturate;
+    }
+
+
+Putting it all together we have this simple shader.
+
+.. code-block:: none
+
+    uniform_float uDesaturationFactor {
+        default = 0.5;
+        min = 0.0;
+        max = 1.0;
+        step = 0.05;
+        description = "Desaturation factor. A value of 1.0 is full grayscale.";
+    }
+
+    fragment desaturate {
+        omw_In vec2 omw_TexCoord;
+
+        void main()
+        {
+            // fetch scene texture from last shader
+            vec4 scene = omw_GetLastShader(omw_TexCoord);
+
+            // desaturate RGB component
+            const vec3 luminance = vec3(0.299, 0.587, 0.144);
+            float gray = dot(luminance, scene.rgb);
+
+            omw_FragColor = vec4(mix(scene.rgb, vec3(gray), uDesaturationFactor), scene.a);
+        }
+    }
+
+    technique {
+        description = "Desaturates scene";
+        passes = desaturate;
+        version = "1.0";
+        author = "Fargoth";
+        passes = desaturate;
+    }
+
+
+Types
+#####
+
+`SHADER_FLAG`
+*************
+
++--------------------+--------------------------------------------------------------------------+
+| Flag               | Description                                                              |
++====================+==========================================================================+
+| disable_interiors  | Disable in interiors.                                                    |
++--------------------+--------------------------------------------------------------------------+
+| disable_exteriors  | Disable when in exteriors or interiors which behave like exteriors.      |
++--------------------+--------------------------------------------------------------------------+
+| disable_underwater | Disable when underwater.                                                 |
++--------------------+--------------------------------------------------------------------------+
+| disable_abovewater | Disable when above water.                                                |
++--------------------+--------------------------------------------------------------------------+
+| disable_sunglare   | Disables builtin sunglare.                                               |
++--------------------+--------------------------------------------------------------------------+
+| hidden             | Shader does not show in the HUD. Useful for shaders driven by Lua API.   |
++--------------------+--------------------------------------------------------------------------+
+
+`BLEND_EQ`
+**********
+
++-------------------+---------------------------+
+| .omwfx            | OpenGL                    |
++===================+===========================+
+| rgba_min          | GL_MIN                    |
++-------------------+---------------------------+
+| rgba_max          | GL_MAX                    |
++-------------------+---------------------------+
+| alpha_min         | GL_ALPHA_MIN_SGIX         |
++-------------------+---------------------------+
+| alpha_max         | GL_ALPHA_MAX_SGIX         |
++-------------------+---------------------------+
+| logic_op          | GL_LOGIC_OP               |
++-------------------+---------------------------+
+| add               | GL_FUNC_ADD               |
++-------------------+---------------------------+
+| subtract          | GL_FUNC_SUBTRACT          |
++-------------------+---------------------------+
+| reverse_subtract  | GL_FUNC_REVERSE_SUBTRACT  |
++-------------------+---------------------------+
+
+`BLEND_FUNC`
+************
+
++---------------------------+------------------------------+
+| .omwfx                    | OpenGL                       |
++===========================+==============================+
+| dst_alpha                 | GL_DST_ALPHA                 |
++---------------------------+------------------------------+
+| dst_color                 | GL_DST_COLOR                 |
++---------------------------+------------------------------+
+| one                       | GL_ONE                       |
++---------------------------+------------------------------+
+| one_minus_dst_alpha       | GL_ONE_MINUS_DST_ALPHA       |
++---------------------------+------------------------------+
+| one_minus_dst_color       | GL_ONE_MINUS_DST_COLOR       |
++---------------------------+------------------------------+
+| one_minus_src_alpha       | GL_ONE_MINUS_SRC_ALPHA       |
++---------------------------+------------------------------+
+| one_minus_src_color       | GL_ONE_MINUS_SRC_COLOR       |
++---------------------------+------------------------------+
+| src_alpha                 | GL_SRC_ALPHA                 |
++---------------------------+------------------------------+
+| src_alpha_saturate        | GL_SRC_ALPHA_SATURATE        |
++---------------------------+------------------------------+
+| src_color                 | GL_SRC_COLOR                 |
++---------------------------+------------------------------+
+| constant_color            | GL_CONSTANT_COLOR            |
++---------------------------+------------------------------+
+| one_minus_constant_color  | GL_ONE_MINUS_CONSTANT_COLOR  |
++---------------------------+------------------------------+
+| constant_alpha            | GL_CONSTANT_ALPHA            |
++---------------------------+------------------------------+
+| one_minus_constant_alpha  | GL_ONE_MINUS_CONSTANT_ALPHA  |
++---------------------------+------------------------------+
+| zero                      | GL_ZERO                      |
++---------------------------+------------------------------+
+
+`INTERNAL_FORMAT`
+*****************
+
++--------------------+-----------------------+
+| .omwfx             | OpenGL                |
++====================+=======================+
+| red                | GL_RED                |
++--------------------+-----------------------+
+| r16f               | GL_R16F               |
++--------------------+-----------------------+
+| r32f               | GL_R32F               |
++--------------------+-----------------------+
+| rg                 | GL_RG                 |
++--------------------+-----------------------+
+| rg16f              | GL_RG16F              |
++--------------------+-----------------------+
+| rg32f              | GL_RG32F              |
++--------------------+-----------------------+
+| rgb                | GL_RGB                |
++--------------------+-----------------------+
+| rgb16f             | GL_RGB16F             |
++--------------------+-----------------------+
+| rgb32f             | GL_RGB32F             |
++--------------------+-----------------------+
+| rgba               | GL_RGBA               |
++--------------------+-----------------------+
+| rgba16f            | GL_RGBA16F            |
++--------------------+-----------------------+
+| rgba32f            | GL_RGBA32F            |
++--------------------+-----------------------+
+| depth_component16  | GL_DEPTH_COMPONENT16  |
++--------------------+-----------------------+
+| depth_component24  | GL_DEPTH_COMPONENT24  |
++--------------------+-----------------------+
+| depth_component32  | GL_DEPTH_COMPONENT32  |
++--------------------+-----------------------+
+| depth_component32f | GL_DEPTH_COMPONENT32F |
++--------------------+-----------------------+
+
+`SOURCE_TYPE`
+*************
+
++--------------------+-----------------------+
+| .omwfx             | OpenGL                |
++====================+=======================+
+| byte               | GL_BYTE               |
++--------------------+-----------------------+
+| unsigned_byte      | GL_UNSIGNED_BYTE      |
++--------------------+-----------------------+
+| short              | GL_SHORT              |
++--------------------+-----------------------+
+| unsigned_short     | GL_UNSIGNED_SHORT     |
++--------------------+-----------------------+
+| int                | GL_INT                |
++--------------------+-----------------------+
+| unsigned_int       | GL_UNSIGNED_INT       |
++--------------------+-----------------------+
+| unsigned_int_24_8  | GL_UNSIGNED_INT_24_8  |
++--------------------+-----------------------+
+| float              | GL_FLOAT              |
++--------------------+-----------------------+
+| double             | GL_DOUBLE             |
++--------------------+-----------------------+
+
+
+`SOURCE_FORMAT`
+***************
+
++---------+---------+
+| .omwfx  | OpenGL  |
++=========+=========+
+| red     | GL_RED  |
++---------+---------+
+| rg      | GL_RG   |
++---------+---------+
+| rgb     | GL_RGB  |
++---------+---------+
+| bgr     | GL_BGR  |
++---------+---------+
+| rgba    | GL_RGBA |
++---------+---------+
+| bgra    | GL_BGRA |
++---------+---------+
+
+`FILTER_MODE`
+*************
+
++-------------------------+----------------------------+
+| .omwfx                  | OpenGL                     |
++=========================+============================+
+| linear                  | GL_LINEAR                  |
++-------------------------+----------------------------+
+| linear_mipmap_linear    | GL_LINEAR_MIPMAP_LINEAR    |
++-------------------------+----------------------------+
+| linear_mipmap_nearest   | GL_LINEAR_MIPMAP_NEAREST   |
++-------------------------+----------------------------+
+| nearest                 | GL_NEAREST                 |
++-------------------------+----------------------------+
+| nearest_mipmap_linear   | GL_NEAREST_MIPMAP_LINEAR   |
++-------------------------+----------------------------+
+| nearest_mipmap_nearest  | GL_NEAREST_MIPMAP_NEAREST  |
++-------------------------+----------------------------+
+
+`WRAP_MODE`
+***********
+
++------------------+---------------------+
+| .omwfx           | OpenGL              |
++==================+=====================+
+| clamp            | GL_CLAMP            |
++------------------+---------------------+
+| clamp_to_edge    | GL_CLAMP_TO_EDGE    |
++------------------+---------------------+
+| clamp_to_border  | GL_CLAMP_TO_BORDER  |
++------------------+---------------------+
+| repeat           | GL_REPEAT           |
++------------------+---------------------+
+| mirror           | GL_MIRRORED_REPEAT  |
++------------------+---------------------+
+
+`COMPRESSION_MODE`
+******************
+
++-------------+
+| .omwfx      |
++=============+
+| auto        |
++-------------+
+| arb         |
++-------------+
+| s3tc_dxt1   |
++-------------+
+| s3tc_dxt3   |
++-------------+
+| s3tc_dxt5   |
++-------------+
+| pvrtc_2bpp  |
++-------------+
+| pvrtc_4bpp  |
++-------------+
+| etc         |
++-------------+
+| etc2        |
++-------------+
+| rgtc1       |
++-------------+
+| rgtc2       |
++-------------+
+| s3tc_dxt1c  |
++-------------+
+| s3tc_dxt1a  |
++-------------+
diff --git a/docs/source/reference/postprocessing/overview.rst b/docs/source/reference/postprocessing/overview.rst
new file mode 100644
index 0000000000000000000000000000000000000000..05d5e428c000f22aef4a6688c9871c68029e35c7
--- /dev/null
+++ b/docs/source/reference/postprocessing/overview.rst
@@ -0,0 +1,45 @@
+#####################################
+Overview of Post Processing Framework
+#####################################
+
+Overview
+========
+
+OpenMW supports a moddable post process framework for creating and
+controlling screenspace effects. This is integrated into OpenMW's Lua API, see
+`reference <../lua-scripting/openmw_shader.html>`_ for details.
+
+Basic concepts
+==============
+
+Pass
+    Describes a single shader invocation pass. Currently only pixel (also known
+    as fragment) shaders are supported.
+
+Technique/Shader
+    An ordered list of passes, techniques will encompass a single effect like
+    bloom or SSAO. Technique is interchangable with shader.
+
+Installing and Activating
+=========================
+
+Shaders are managed through the virtual file system, simply install the associated
+archive or folder as described in :ref:`mod-install<install>`. Shaders must be
+in the `Shaders` directory to be discoverable. A shader can be activated in one
+of two ways:
+
+1. Adding the shaders filename (without its extension) to the end of the
+   :ref:`chain` list in ``settings.cfg``.
+2. Using the in game post processor HUD, which can be activated with the ``F2``
+   key by default. This is the recommended method as manual editing can be error
+   prone.
+
+Hot Reloading
+==============
+
+It is possible to modify a shader without restarting OpenMW, :ref:`live reload`
+must be enabled in ``settings.cfg``. Whenever a file is modified and saved, the
+shader will automatically reload in game. This allows shaders to be written in a
+text editor you are comfortable with. The only restriction is that new shaders
+cannot be added, as the VFS will not be rebuilt and OpenMW will not be aware of
+the new file.
diff --git a/files/lua_api/CMakeLists.txt b/files/lua_api/CMakeLists.txt
index 88efc8195cdfa51e67c05b384290ac2d7355748b..d2447fa80caed35d4d89d011b4f7de2528fab394 100644
--- a/files/lua_api/CMakeLists.txt
+++ b/files/lua_api/CMakeLists.txt
@@ -13,6 +13,7 @@ set(LUA_API_FILES
     openmw/util.lua
     openmw/world.lua
     openmw/types.lua
+    openmw/postprocessing.lua
 )
 
 foreach (f ${LUA_API_FILES})
diff --git a/files/lua_api/openmw/input.lua b/files/lua_api/openmw/input.lua
index 12ea5c94b3850385dd9d410269b0fdc9c327d32a..205ab584d9d78dac72596f2591efed66880678e0 100644
--- a/files/lua_api/openmw/input.lua
+++ b/files/lua_api/openmw/input.lua
@@ -149,6 +149,7 @@
 -- @field [parent=#ACTION] #number ToggleDebug
 -- @field [parent=#ACTION] #number ZoomIn
 -- @field [parent=#ACTION] #number ZoomOut
+-- @field [parent=#ACTION] #number TogglePostProcessorHUD
 
 ---
 -- Values that can be used with isActionPressed.
diff --git a/files/lua_api/openmw/postprocessing.lua b/files/lua_api/openmw/postprocessing.lua
new file mode 100644
index 0000000000000000000000000000000000000000..36c96c2efc88407bb84a207bc340a2dcaec963f2
--- /dev/null
+++ b/files/lua_api/openmw/postprocessing.lua
@@ -0,0 +1,92 @@
+---
+-- `openmw.postprocessing` is an interface to postprocessing shaders.
+-- Can be used only by local scripts, that are attached to a player.
+-- @module shader
+-- @usage local postprocessing = require('openmw.postprocessing')
+
+
+
+---
+-- Load a shader and return its handle.
+-- @function [parent=#postprocessing] load
+-- @param #string name Name of the shader without its extension
+-- @return #Shader
+-- @usage
+-- If the shader exists and compiles, the shader will still be off by default.
+-- It must be enabled to see its effect.
+-- local vignetteShader = postprocessing.load('vignette')
+
+---
+-- Enable the shader. Has no effect if the shader is already enabled or does
+-- not exist. Will not apply until the next frame.
+-- @function [parent=#Shader] enable Enable the shader
+-- @param self
+-- @param #number position optional position to place the shader. If left out the shader will be inserted at the end of the chain.
+-- @usage
+-- -- Load shader
+-- local vignetteShader = postprocessing.load('vignette')
+-- -- Toggle shader on
+-- vignetteShader:enable()
+
+---
+-- Deactivate the shader. Has no effect if the shader is already deactivated or does not exist.
+-- Will not apply until the next frame.
+-- @function [parent=#Shader] disable Disable the shader
+-- @param self
+-- @usage
+-- local vignetteShader = shader.postprocessing('vignette')
+-- vignetteShader:disable() -- shader will be toggled off
+
+---
+-- Check if the shader is enabled.
+-- @function [parent=#Shader] isEnabled
+-- @param self
+-- @return #boolean True if shader is enabled and was compiled successfully.
+-- @usage
+-- local vignetteShader = shader.postprocessing('vignette')
+-- vignetteShader:enable() -- shader will be toggled on
+
+---
+-- Set a non static bool shader variable.
+-- @function [parent=#Shader] setBool
+-- @param self
+-- @param #string name Name of uniform
+-- @param #boolean value Value of uniform.
+
+---
+-- Set a non static integer shader variable.
+-- @function [parent=#Shader] setInt
+-- @param self
+-- @param #string name Name of uniform
+-- @param #number value Value of uniform.
+
+---
+-- Set a non static float shader variable.
+-- @function [parent=#Shader] setFloat
+-- @param self
+-- @param #string name Name of uniform
+-- @param #number value Value of uniform.
+
+---
+-- Set a non static Vector2 shader variable.
+-- @function [parent=#Shader] setVector2
+-- @param self
+-- @param #string name Name of uniform
+-- @param #Vector2 value Value of uniform.
+
+---
+-- Set a non static Vector3 shader variable.
+-- @function [parent=#Shader] setVector3
+-- @param self
+-- @param #string name Name of uniform
+-- @param #Vector3 value Value of uniform.
+
+---
+-- Set a non static Vector4 shader variable.
+-- @function [parent=#Shader] setVector4
+-- @param self
+-- @param #string name Name of uniform
+-- @param #Vector4 value Value of uniform.
+
+
+return nil
diff --git a/files/mygui/CMakeLists.txt b/files/mygui/CMakeLists.txt
index 1edfbca8065b66af9ebbe064efaaf1a1fa935cb6..924aaecada71d35abaf19aae9fdd2b4921333e1f 100644
--- a/files/mygui/CMakeLists.txt
+++ b/files/mygui/CMakeLists.txt
@@ -90,6 +90,8 @@ set(MYGUI_FILES
     openmw_edit_note.layout
     openmw_debug_window.layout
     openmw_debug_window.skin.xml
+    openmw_postprocessor_hud.layout
+    openmw_postprocessor_hud.skin.xml
     openmw_jail_screen.layout
     DejaVuLGCSansMono.ttf
     ../launcher/images/openmw.png
diff --git a/files/mygui/openmw_list.skin.xml b/files/mygui/openmw_list.skin.xml
index db2c722d7e31678283adb1e2423e0d7c2bcb697c..9a54a10683912a18c161c10773277b87c82024ff 100644
--- a/files/mygui/openmw_list.skin.xml
+++ b/files/mygui/openmw_list.skin.xml
@@ -202,6 +202,14 @@
         </BasisSkin>
     </Resource>
 
+    <!-- Vertical line -->
+
+    <Resource type="ResourceSkin" name="MW_VLine" size="10 512" texture="textures\menu_thin_border_left.dds">
+        <BasisSkin type="SubSkin" offset="0 0 2 512" align="Bottom VStretch">
+            <State name="normal" offset="0 0 2 512"/>
+        </BasisSkin>
+    </Resource>
+
     <!-- Arrows -->
 
     <Resource type="AutoSizedResourceSkin" name="MW_ArrowLeft" texture="textures\omw_menu_scroll_left.dds">
diff --git a/files/mygui/openmw_postprocessor_hud.layout b/files/mygui/openmw_postprocessor_hud.layout
new file mode 100644
index 0000000000000000000000000000000000000000..1030c83d2c7b0e2243d4d819b78c62febec1651d
--- /dev/null
+++ b/files/mygui/openmw_postprocessor_hud.layout
@@ -0,0 +1,138 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<MyGUI type="Layout">
+  <Widget type="Window" skin="MW_Window" position="0 0 500 500" layer="Debug" name="_Main" align="Stretch">
+    <Property key="Visible" value="false"/>
+    <Property key="Caption" value="Postprocess HUD"/>
+	<Property key="MinSize" value="600 600"/>
+
+    <Widget type="TabControl" skin="TabControl_NoBorder" position="8 8 468 450" align="Stretch" name="TabControl">
+        <Property key="ButtonAutoWidth" value="true"/>
+
+		<Widget type="AutoSizedTextBox" skin="NormalText" position="440 8 50 50" align="Top Right">
+			<Property key="Caption" value="[?]"/>
+			<UserString key="ToolTipType" value="Layout"/>
+			<UserString key="ToolTipLayout" value="TextToolTip"/>
+			<UserString key="Caption_Text" value="Keyboard controls:\n\n
+				Shift+Right-Arrow > Activate shader\n
+				Shift+Left-Arrow > Deactive shader\n
+				Shift+Up-Arrow > Move shader up\n
+				Shift+Down-Arrow > Move shader down\n
+				Hold Shift > Fine tune sliders\n
+				"/>
+		</Widget>
+
+        <Widget type="TabItem" skin="" position_real="0 0 1 1" name="TabConfiguration">
+			<Property key="Caption" value="Configuration"/>
+
+			<Widget type="VBox" position_real="0 0.02 1 0.98" align="Stretch" name="Layout">
+				<Property key="Padding" value="0"/>
+				<Property key="Spacing" value="8"/>
+
+				<Widget type="Widget" position ="0 0 0 400">
+					<UserString key="HStretch" value="true"/>
+					<UserString key="VStretch" value="false"/>
+
+					<Widget type="HBox" position_real="0 0 1 1" align="Stretch">
+						<UserString key="VStretch" value="true"/>
+						<UserString key="HStretch" value="true"/>
+
+						<Widget type="Widget">
+							<UserString key="VStretch" value="true"/>
+							<UserString key="HStretch" value="true"/>
+
+							<Widget type="VBox" position_real="0 0 1 1" align="Stretch">
+								<Widget type="EditBox" skin="MW_TextBoxEditWithBorder" position="0 0 0 28" name="Filter">
+									<UserString key="HStretch" value="true"/>
+									<UserString key="AcceptTab" value="true"/>
+									<Property key="TextAlign" value="Left VCenter"/>
+								</Widget>
+								<Widget type="ListWrapper" skin="MW_List" name="InactiveList">
+									<UserString key="VStretch" value="true"/>
+									<UserString key="HStretch" value="true"/>
+								</Widget>
+							</Widget>
+						</Widget>
+
+						<Widget type="VBox" position_real="0 0 1 1">
+							<Widget type="AutoSizedButton" skin="MW_Button" name="ButtonActivate">
+								<Widget type="Widget" skin="MW_ArrowRight" position="0 0 12 12" align="Center">
+									<Property key="NeedMouse" value="false"/>
+								</Widget>
+							</Widget>
+							<Widget type="AutoSizedButton" skin="MW_Button" name="ButtonDeactivate">
+								<Widget type="Widget" skin="MW_ArrowLeft" position="0 0 12 12" align="Center">
+									<Property key="NeedMouse" value="false"/>
+								</Widget>
+							</Widget>
+
+							<Widget type="Widget" skin="" position="0 0 15 25"/>
+
+							<Widget type="AutoSizedButton" skin="MW_Button" name="ButtonUp">
+								<Widget type="Widget" skin="MW_ArrowUp" position="0 0 12 12" align="Center">
+									<Property key="NeedMouse" value="false"/>
+								</Widget>
+							</Widget>
+							<Widget type="AutoSizedButton" skin="MW_Button" name="ButtonDown">
+								<Widget type="Widget" skin="MW_ArrowDown" position="0 0 12 12" align="Center">
+									<Property key="NeedMouse" value="false"/>
+								</Widget>
+							</Widget>
+
+						</Widget>
+
+						<Widget type="ListWrapper" skin="MW_List" name="ActiveList">
+							<UserString key="VStretch" value="true"/>
+							<UserString key="HStretch" value="true"/>
+						</Widget>
+
+					</Widget>
+
+				</Widget>
+
+				<Widget type="Widget" skin="MW_Box">
+					<UserString key="VStretch" value="true"/>
+					<UserString key="HStretch" value="true"/>
+
+					<Widget type="VBox" position_real="0 0 1 1" align="Stretch">
+						<Property key="Padding" value="14"/>
+						<Widget type="ScrollView" skin="MW_ScrollView" position_real="0 0 1 1" align="Stretch" name="ConfigLayout">
+							<Property key="CanvasAlign" value="Left Top"/>
+							<Property key="NeedMouse" value="true"/>
+							<Property key="VisibleVScroll" value="true"/>
+						</Widget>
+					</Widget>
+				</Widget>
+
+				<Widget type="Widget" position="0 0 230 28" align="Bottom Left">
+					<UserString key="HStretch" value="false"/>
+					<UserString key="VStretch" value="false"/>
+
+					<Widget type="HBox" position_real="0 0 1 1" align="Stretch">
+						<UserString key="HStretch" value="true"/>
+						<Property key="Spacing" value="4"/>
+
+						<Widget type="AutoSizedTextBox" skin="SandText">
+							<UserString key="HStretch" value="true"/>
+							<UserString key="VStretch" value="true"/>
+							<Property key="Caption" value="Enable Config Mode"/>
+							<Property key="TextAlign" value="Left VCenter"/>
+						</Widget>
+
+						<Widget type="AutoSizedButton" skin="MW_Button" name="ModeToggle">
+							<UserString key="VStretch" value="true"/>
+							<Property key="Caption" value="#{sOff}"/>
+						</Widget>
+					</Widget>
+
+				</Widget>
+
+				<Widget type="Widget" />
+
+			</Widget>
+
+        </Widget>
+
+    </Widget>
+
+  </Widget>
+</MyGUI>
diff --git a/files/mygui/openmw_postprocessor_hud.skin.xml b/files/mygui/openmw_postprocessor_hud.skin.xml
new file mode 100644
index 0000000000000000000000000000000000000000..bf3a470b94b5bd3113e2bc3f3f946554477e5a44
--- /dev/null
+++ b/files/mygui/openmw_postprocessor_hud.skin.xml
@@ -0,0 +1,79 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<MyGUI type="Resource" version="1.1">
+
+	<Resource type="ResourceLayout" name="MW_ValueEditNumber" version="3.2.0">
+		<Widget type="Widget" skin="" position="0 0 100 50" align="Stretch" name="Root">
+            <Widget type="HBox" skin="MW_Box" position_real="0 0 1 1" align="Stretch" name="Layout">
+                <UserString key="HStretch" value="true"/>
+                <UserString key="VStretch" value="true"/>
+                <Property key="Padding" value="4"/>
+
+                <Widget type="Button" skin="MW_ArrowLeft" position="0 0 12 12" align="VCenter Left" name="ButtonDecrease"/>
+                <Widget type="Widget" name="Dragger">
+                    <Widget type="TextBox" skin="HeaderText" align="Stretch" name="Value">
+                        <Property key="Caption" value="NA"/>
+                        <Property key="NeedMouse" value="false"/>
+                        <Property key="TextAlign" value="Center"/>
+                    </Widget>
+                    <UserString key="HStretch" value="true"/>
+                    <UserString key="VStretch" value="true"/>
+                    <Property key="Pointer" value="hresize"/>
+                </Widget>
+                <Widget type="Button" skin="MW_ArrowRight" position="0 0 12 12" align="VCenter Right" name="ButtonIncrease"/>
+            </Widget>
+		</Widget>
+	</Resource>
+
+	<Resource type="ResourceLayout" name="MW_ValueEditBool" version="3.2.0">
+		<Widget type="Widget" skin="" position="0 0 100 50" align="Stretch" name="Root">
+            <Widget type="HBox" skin="MW_Box" position_real="0 0 1 1" align="Stretch" name="Layout">
+                <UserString key="HStretch" value="true"/>
+                <UserString key="VStretch" value="true"/>
+
+                <Widget type="Button" skin="SandTextButton" align="Stretch" name="Checkbutton">
+                    <UserString key="HStretch" value="true"/>
+                    <UserString key="VStretch" value="true"/>
+                    <Property key="TextAlign" value="Center"/>
+                    <Property key="Caption" value="On"/>
+                    <Property key="Colour" value="1 0 0 1"/>
+                </Widget>
+            </Widget>
+		</Widget>
+	</Resource>
+
+    <Resource type="ResourceLayout" name="MW_UniformEdit" version="3.2.0">
+        <Widget type="Widget" position="0 0 300 22" name="Root">
+            <Widget type="HBox" position_real="0 0 1 1" align="Stretch">
+                <Property key="Padding" value="0"/>
+                <Property key="Spacing" value="8"/>
+                <Widget type="AutoSizedButton" skin="MW_Button" position="0 0 22 22" name="Reset">
+                    <UserString key="HStretch" value="false"/>
+                    <UserString key="VStretch" value="false"/>
+                    <Property key="Caption" value="r"/>
+                </Widget>
+                <Widget type="Widget" skin="BlackBG" position="0 0 225 22" name="Client">
+                    <UserString key="HStretch" value="false"/>
+                    <UserString key="VStretch" value="false"/>
+                    <Property key="Colour" value="0.2 0.2 0.2 0.05"/>
+                </Widget>
+                <Widget type="AutoSizedTextBox" skin="SandText" name="Label" align="Top Right">
+                    <UserString key="HStretch" value="true"/>
+                    <UserString key="VStretch" value="true"/>
+                <Property key="Padding" value="8"/>
+                    <Property key="TextAlign" value="Left Top"/>
+                    <Property key="NeedMouse" value="true"/>
+                </Widget>
+            </Widget>
+        </Widget>
+    </Resource>
+
+    <Resource type="ResourceSkin" name="MW_UniformGroup" size="16 16">
+        <Property key="FontName" value="Default"/>
+        <Property key="TextAlign" value="Left VCenter"/>
+        <Property key="TextColour" value="#{fontcolour=header}"/>
+        
+        <Child type="Widget" skin="IB_B" offset="0 14 16 2" align="Bottom HStretch"/>
+        <BasisSkin type="SimpleText" offset="0 0 16 14" align="Stretch"/>
+    </Resource>
+
+</MyGUI>
diff --git a/files/mygui/openmw_resources.xml b/files/mygui/openmw_resources.xml
index ff4893a9b20672a02766804bdb55bd57a43e2839..03ca91f5eb1b5ab253bbe3cbd8bf26b8f55ba59f 100644
--- a/files/mygui/openmw_resources.xml
+++ b/files/mygui/openmw_resources.xml
@@ -59,6 +59,17 @@
         </Widget>
     </Resource>
 
+    <Resource type="ResourceLayout" name="TabControl_NoBorder" version="3.2.0">
+        <Widget type="Widget" skin="" position="5 5 89 60" name="Root">
+            <UserString key="ButtonSkin" value="MW_Button_RightPadding"/>
+            <Widget type="Widget" skin="" position="0 28 89 32" align="Left Top Stretch" name="TabItem"/>
+            <Widget type="Widget" skin="" position="0 0 89 23" align="HStretch Top" name="HeaderPlace">
+                <Widget type="Widget" skin="" position="52 0 37 23" name="Controls">
+                </Widget>
+            </Widget>
+        </Widget>
+    </Resource>
+
     <Resource type="ResourceLayout" name="TabControlInner" version="3.2.0">
         <Widget type="Widget" skin="" position="0 5 89 60" name="Root">
             <UserString key="ButtonSkin" value="MW_Button_RightPadding"/>
diff --git a/files/mygui/openmw_settings_window.layout b/files/mygui/openmw_settings_window.layout
index a134d8ecb85de1b1955beb502864b47722d8fae5..cfc80b1368a2a1f14df65d48636e6501f81b42c2 100644
--- a/files/mygui/openmw_settings_window.layout
+++ b/files/mygui/openmw_settings_window.layout
@@ -269,7 +269,7 @@
                     <Property key="ButtonAutoWidth" value="true"/>
                     <Widget type="TabItem" skin="" position="0 28 352 268" align="Stretch">
                         <Property key="Caption" value="  Video  "/>
-                        <Widget type="ListBox" skin="MW_List" position="0 4 170 170" align="Left Top" name="ResolutionList"/>
+                        <Widget type="ListBox" skin="MW_List" position="0 4 170 215" align="Left Top" name="ResolutionList"/>
                         <Widget type="TextBox" skin="NormalText" position="182 4 170 18" align="Left Top">
                             <Property key="Caption" value="Window Mode:"/>
                         </Widget>
@@ -305,9 +305,24 @@
                             <Property key="Caption" value="Hint: press F3 to show \nthe current frame rate."/>
                         </Widget>
 
-                        <Widget type="TextBox" skin="NormalText" position="0 198 352 18" align="Left Top" name="FovText">
+                        <Widget type="HBox" skin="" position="182 160 300 24">
+                            <Widget type="AutoSizedButton" skin="MW_Button" position="0 0 24 24" align="Left Top" name="WindowBorderButton">
+                                <UserString key="SettingCategory" value="Post Processing"/>
+                                <UserString key="SettingName" value="enabled"/>
+                                <UserString key="SettingType" value="CheckButton"/>
+                            </Widget>
+                            <Widget type="AutoSizedTextBox" skin="SandText" position="28 4 48 16" align="Left Top">
+                                <Property key="Caption" value="Post Processing"/>
+                            </Widget>
+                        </Widget>
+
+                        <Widget type="TextBox" skin="SandText" position="182 190 300 32" align="Left Top">
+                            <Property key="Caption" value="Hint: press F2 to show \nthe config HUD."/>
+                        </Widget>
+
+                        <Widget type="TextBox" skin="NormalText" position="0 228 352 18" align="Left Top" name="FovText">
                         </Widget>
-                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 222 352 18" align="HStretch Top">
+                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 252 352 18" align="HStretch Top">
                             <Property key="Range" value="81"/>
                             <Property key="Page" value="1"/>
                             <UserString key="SettingType" value="Slider"/>
@@ -319,18 +334,18 @@
                             <UserString key="SettingLabelWidget" value="FovText"/>
                             <UserString key="SettingLabelCaption" value="Field of View (%s)"/>
                         </Widget>
-                        <Widget type="TextBox" skin="SandText" position="0 246 352 18" align="Left Top">
+                        <Widget type="TextBox" skin="SandText" position="0 276 352 18" align="Left Top">
                             <Property key="Caption" value="#{sLow}"/>
                             <Property key="TextAlign" value="Left"/>
                         </Widget>
-                        <Widget type="TextBox" skin="SandText" position="0 246 352 18" align="Right Top">
+                        <Widget type="TextBox" skin="SandText" position="0 276 352 18" align="Right Top">
                             <Property key="Caption" value="#{sHigh}"/>
                             <Property key="TextAlign" value="Right"/>
                         </Widget>
-                        <Widget type="TextBox" skin="NormalText" position="0 268 352 18" align="Left Top" name="GammaText">
+                        <Widget type="TextBox" skin="NormalText" position="0 298 352 18" align="Left Top" name="GammaText">
                             <Property key="Caption" value="#{sGamma_Correction}"/>
                         </Widget>
-                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 292 352 18" align="HStretch Top" name="GammaSlider">
+                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 322 352 18" align="HStretch Top" name="GammaSlider">
                             <Property key="Range" value="10000"/>
                             <Property key="Page" value="300"/>
                             <UserString key="SettingType" value="Slider"/>
@@ -340,11 +355,11 @@
                             <UserString key="SettingMin" value="0.1"/>
                             <UserString key="SettingMax" value="3.0"/>
                         </Widget>
-                        <Widget type="TextBox" skin="SandText" position="0 316 352 18" align="Left Top" name="GammaTextDark">
+                        <Widget type="TextBox" skin="SandText" position="0 346 352 18" align="Left Top" name="GammaTextDark">
                             <Property key="Caption" value="#{sDark_Gamma}"/>
                             <Property key="TextAlign" value="Left"/>
                         </Widget>
-                        <Widget type="TextBox" skin="SandText" position="0 316 352 18" align="Right Top" name="GammaTextLight">
+                        <Widget type="TextBox" skin="SandText" position="0 346 352 18" align="Right Top" name="GammaTextLight">
                             <Property key="Caption" value="#{sLight_Gamma}"/>
                             <Property key="TextAlign" value="Right"/>
                         </Widget>
diff --git a/files/mygui/skins.xml b/files/mygui/skins.xml
index 1811afb83fe3b8e861bbabf4cb598304361b8515..4d3d4c8774fa706021c2fde8c56b8410a9b5b0d4 100644
--- a/files/mygui/skins.xml
+++ b/files/mygui/skins.xml
@@ -20,6 +20,7 @@
         <List file="openmw_dialogue_window.skin.xml"/>
         <List file="openmw_scroll.skin.xml"/>
         <List file="openmw_debug_window.skin.xml" />
+        <List file="openmw_postprocessor_hud.skin.xml" />
     </MyGUI>
 </MyGUI>
 
diff --git a/files/settings-default.cfg b/files/settings-default.cfg
index d97f529db2a277b87f4e86a8bc7560f1cb59a769..ed392d44e40d7cf33c3fd704fdd4711fd0d5e216 100644
--- a/files/settings-default.cfg
+++ b/files/settings-default.cfg
@@ -834,6 +834,17 @@ settings maximized w = 0.97
 settings maximized h = 0.875
 settings maximized = false
 
+# Postprocessor configuration window for controlling shaders.
+postprocessor h = 0.95
+postprocessor w = 0.44
+postprocessor x = 0.01
+postprocessor y = 0.02
+postprocessor maximized x = 0.015
+postprocessor maximized y = 0.02
+postprocessor maximized w = 0.97
+postprocessor maximized h = 0.875
+postprocessor maximized = false
+
 [Navigator]
 
 # Enable navigator (true, false). When enabled background threads are started to build navmesh for world geometry.
@@ -1197,4 +1208,21 @@ right eye orientation w = 1.0
 right eye fov left = -0.78
 right eye fov right = 0.86
 right eye fov up = 0.8
-right eye fov down = -0.8
\ No newline at end of file
+right eye fov down = -0.8
+
+[Post Processing]
+
+# Enables post-processing 
+enabled = false
+
+# List of active shaders. This is more easily with the in-game shader HUD, by default accessible with the F2 key.
+chain =
+
+# Reload active shaders when modified on local filesystem. This is a DEBUG mode, and should be disabled in normal gameplay.
+live reload = false
+
+# Used for eye adaptation to control speed at which scene luminance can change from one frame to the next. No effect when HDR is not being utilized.
+hdr exposure time = 0.05
+
+# Transparent depth postpass. Re-renders transparent objects with alpha-clipping forced with a fixed threshold.
+transparent postpass = true
diff --git a/files/shaders/CMakeLists.txt b/files/shaders/CMakeLists.txt
index 97f32ad979171e2ddf3954db40b98ee69efe39b7..88fd6d45ca10f2874a1e475c9d3e9d742120dd45 100644
--- a/files/shaders/CMakeLists.txt
+++ b/files/shaders/CMakeLists.txt
@@ -38,6 +38,8 @@ set(SHADER_FILES
     nv_default_fragment.glsl
     nv_nolighting_vertex.glsl
     nv_nolighting_fragment.glsl
+    blended_depth_postpass_vertex.glsl
+    blended_depth_postpass_fragment.glsl
     gui_vertex.glsl
     gui_fragment.glsl
     debug_vertex.glsl
@@ -46,6 +48,10 @@ set(SHADER_FILES
     sky_fragment.glsl
     skypasses.glsl
     softparticles.glsl
+    hdr_fragment.glsl
+    hdr_luminance_fragment.glsl
+    fullscreen_tri_vertex.glsl
+    fullscreen_tri_fragment.glsl
 )
 
 copy_all_resource_files(${CMAKE_CURRENT_SOURCE_DIR} ${OPENMW_RESOURCES_ROOT} ${DDIRRELATIVE} "${SHADER_FILES}")
diff --git a/files/shaders/blended_depth_postpass_fragment.glsl b/files/shaders/blended_depth_postpass_fragment.glsl
new file mode 100644
index 0000000000000000000000000000000000000000..61e8b4ea7e62b5bde1078d7b7bd4f8de6288a1b4
--- /dev/null
+++ b/files/shaders/blended_depth_postpass_fragment.glsl
@@ -0,0 +1,19 @@
+#version 120
+
+uniform sampler2D diffuseMap;
+
+varying vec2 diffuseMapUV;
+varying float alphaPassthrough;
+
+void main()
+{
+    float alpha = texture2D(diffuseMap, diffuseMapUV).a * alphaPassthrough;
+
+    const float alphaRef = 0.5;
+
+    if (alpha < alphaRef)
+        discard;
+
+    // DO NOT write to color!
+    // This is a post-pass of transparent objects in charge of only updating depth buffer.
+}
diff --git a/files/shaders/blended_depth_postpass_vertex.glsl b/files/shaders/blended_depth_postpass_vertex.glsl
new file mode 100644
index 0000000000000000000000000000000000000000..471a2df16aa3f4840ac050f51df50a3e62d99f32
--- /dev/null
+++ b/files/shaders/blended_depth_postpass_vertex.glsl
@@ -0,0 +1,20 @@
+#version 120
+
+uniform mat4 projectionMatrix;
+
+varying vec2 diffuseMapUV;
+varying float alphaPassthrough;
+
+#include "vertexcolors.glsl"
+
+void main()
+{
+    gl_Position = projectionMatrix * (gl_ModelViewMatrix * gl_Vertex);
+
+    if (colorMode == 2)
+        alphaPassthrough = gl_Color.a;
+    else
+        alphaPassthrough = gl_FrontMaterial.diffuse.a;
+
+    diffuseMapUV = (gl_TextureMatrix[0] * gl_MultiTexCoord0).xy;
+}
diff --git a/files/shaders/fullscreen_tri_fragment.glsl b/files/shaders/fullscreen_tri_fragment.glsl
new file mode 100644
index 0000000000000000000000000000000000000000..b71f98365d8ad5e8c1eadb95f3de64b0623976a6
--- /dev/null
+++ b/files/shaders/fullscreen_tri_fragment.glsl
@@ -0,0 +1,10 @@
+#version 120
+
+varying vec2 uv;
+
+#include "openmw_fragment.h.glsl"
+
+void main()
+{
+    gl_FragColor = mw_samplerLastShader(uv);
+}
\ No newline at end of file
diff --git a/files/shaders/fullscreen_tri_vertex.glsl b/files/shaders/fullscreen_tri_vertex.glsl
new file mode 100644
index 0000000000000000000000000000000000000000..794e0827c4d9c967547234d2c25d2fcec8680cf1
--- /dev/null
+++ b/files/shaders/fullscreen_tri_vertex.glsl
@@ -0,0 +1,9 @@
+#version 120
+
+varying vec2 uv;
+
+void main()
+{
+    gl_Position = vec4(gl_Vertex.xy, 0.0, 1.0);
+    uv = gl_Position.xy * 0.5 + 0.5;
+}
diff --git a/files/shaders/groundcover_fragment.glsl b/files/shaders/groundcover_fragment.glsl
index cb53e7a63ea7276490cbe1d21594125f77b3c9c9..b7ff102079c233b77320ebaaf36804e0c214e6c8 100644
--- a/files/shaders/groundcover_fragment.glsl
+++ b/files/shaders/groundcover_fragment.glsl
@@ -30,27 +30,31 @@ varying float linearDepth;
 
 #if PER_PIXEL_LIGHTING
 varying vec3 passViewPos;
-varying vec3 passNormal;
 #else
 centroid varying vec3 passLighting;
 centroid varying vec3 shadowDiffuseLighting;
 #endif
 
+varying vec3 passNormal;
+
 #include "shadows_fragment.glsl"
 #include "lighting.glsl"
 #include "alpha.glsl"
 
 void main()
 {
+    vec3 worldNormal = normalize(passNormal);
+
 #if @normalMap
     vec4 normalTex = texture2D(normalMap, normalMapUV);
 
-    vec3 normalizedNormal = normalize(passNormal);
+    vec3 normalizedNormal = worldNormal;
     vec3 normalizedTangent = normalize(passTangent.xyz);
     vec3 binormal = cross(normalizedTangent, normalizedNormal) * passTangent.w;
     mat3 tbnTranspose = mat3(normalizedTangent, binormal, normalizedNormal);
 
-    vec3 viewNormal = gl_NormalMatrix * normalize(tbnTranspose * (normalTex.xyz * 2.0 - 1.0));
+    worldNormal = normalize(tbnTranspose * (normalTex.xyz * 2.0 - 1.0));
+    vec3 viewNormal = gl_NormalMatrix * worldNormal;
 #endif
 
 #if @diffuseMap
@@ -86,5 +90,9 @@ void main()
 #endif
     gl_FragData[0].xyz = mix(gl_FragData[0].xyz, gl_Fog.color.xyz, fogValue);
 
+#if !@disableNormals
+    gl_FragData[1].xyz = worldNormal * 0.5 + 0.5;
+#endif
+
     applyShadowDebugOverlay();
 }
diff --git a/files/shaders/groundcover_vertex.glsl b/files/shaders/groundcover_vertex.glsl
index fff8293b6124e5bad83e367fe0ab843a9e9eaafb..aa9dea33550a6e5b71868b68158732e57e83e49e 100644
--- a/files/shaders/groundcover_vertex.glsl
+++ b/files/shaders/groundcover_vertex.glsl
@@ -33,12 +33,13 @@ varying float linearDepth;
 
 #if PER_PIXEL_LIGHTING
 varying vec3 passViewPos;
-varying vec3 passNormal;
 #else
 centroid varying vec3 passLighting;
 centroid varying vec3 shadowDiffuseLighting;
 #endif
 
+varying vec3 passNormal;
+
 #include "shadows_vertex.glsl"
 #include "lighting.glsl"
 #include "depth.glsl"
@@ -161,9 +162,9 @@ void main(void)
     passTangent = gl_MultiTexCoord7.xyzw * rotation;
 #endif
 
+    passNormal = rotation3(rotation) * gl_Normal.xyz;
 #if PER_PIXEL_LIGHTING
     passViewPos = viewPos.xyz;
-    passNormal = rotation3(rotation) * gl_Normal.xyz;
 #else
     vec3 diffuseLight, ambientLight;
     doLighting(viewPos.xyz, viewNormal, diffuseLight, ambientLight, shadowDiffuseLighting);
diff --git a/files/shaders/hdr_fragment.glsl b/files/shaders/hdr_fragment.glsl
new file mode 100644
index 0000000000000000000000000000000000000000..5490a6873d9283173aa6ce0844e40ccbc19304ec
--- /dev/null
+++ b/files/shaders/hdr_fragment.glsl
@@ -0,0 +1,14 @@
+#version 120
+
+varying vec2 uv;
+uniform sampler2D luminanceSceneTex;
+uniform sampler2D prevLuminanceSceneTex;
+
+void main()
+{
+    float prevLum = texture2D(prevLuminanceSceneTex, vec2(0.5, 0.5)).r;
+
+    float l = texture2D(luminanceSceneTex, vec2(0.5, 0.5)).r;
+    float weightedAvgLum = exp2((l * @logLumRange) + @minLog);
+    gl_FragColor.r = prevLum + (weightedAvgLum - prevLum) * @hdrExposureTime;
+}
diff --git a/files/shaders/hdr_luminance_fragment.glsl b/files/shaders/hdr_luminance_fragment.glsl
new file mode 100644
index 0000000000000000000000000000000000000000..f78dc41dfa2007bf75e9a2d1c7a3fb3d2c78eac3
--- /dev/null
+++ b/files/shaders/hdr_luminance_fragment.glsl
@@ -0,0 +1,17 @@
+#version 120
+
+varying vec2 uv;
+uniform sampler2D sceneTex;
+
+void main()
+{
+    float lum = dot(texture2D(sceneTex, uv).rgb, vec3(0.2126, 0.7152, 0.0722));
+
+    if (lum < @epsilon)
+    {
+        gl_FragColor.r = 0.0;
+        return;
+    }
+
+    gl_FragColor.r = clamp((log2(lum) - @minLog) * @invLogLumRange, 0.0, 1.0);
+}
diff --git a/files/shaders/nv_default_fragment.glsl b/files/shaders/nv_default_fragment.glsl
index ff81a2b94d1ccc52adf780014d03ea85c3795ab6..9cb784ab98ea5209008e36c5975ac6fad3880478 100644
--- a/files/shaders/nv_default_fragment.glsl
+++ b/files/shaders/nv_default_fragment.glsl
@@ -43,6 +43,8 @@ uniform float specStrength;
 
 void main()
 {
+    vec3 worldNormal = normalize(passNormal);
+
 #if @diffuseMap
     gl_FragData[0] = texture2D(diffuseMap, diffuseMapUV);
     gl_FragData[0].a *= coveragePreservingAlphaScale(diffuseMap, diffuseMapUV);
@@ -57,14 +59,15 @@ void main()
 #if @normalMap
     vec4 normalTex = texture2D(normalMap, normalMapUV);
 
-    vec3 normalizedNormal = normalize(passNormal);
+    vec3 normalizedNormal = worldNormal;
     vec3 normalizedTangent = normalize(passTangent.xyz);
     vec3 binormal = cross(normalizedTangent, normalizedNormal) * passTangent.w;
     mat3 tbnTranspose = mat3(normalizedTangent, binormal, normalizedNormal);
 
-    vec3 viewNormal = gl_NormalMatrix * normalize(tbnTranspose * (normalTex.xyz * 2.0 - 1.0));
+    worldNormal = normalize(tbnTranspose * (normalTex.xyz * 2.0 - 1.0));
+    vec3 viewNormal = gl_NormalMatrix * worldNormal;
 #else
-    vec3 viewNormal = gl_NormalMatrix * normalize(passNormal);
+    vec3 viewNormal = gl_NormalMatrix * worldNormal;
 #endif
 
     float shadowing = unshadowedLightRatio(linearDepth);
@@ -100,5 +103,9 @@ void main()
     gl_FragData[0].a = 1.0;
 #endif
 
+#if !defined(FORCE_OPAQUE) && !@disableNormals
+    gl_FragData[1].xyz = worldNormal * 0.5 + 0.5;
+#endif
+
     applyShadowDebugOverlay();
 }
diff --git a/files/shaders/objects_fragment.glsl b/files/shaders/objects_fragment.glsl
index bf9f2072976bc7ff4716e2b840c000f9da3ebeb2..16cbf9bbbd8db85ba182b06d7008675dcddef274 100644
--- a/files/shaders/objects_fragment.glsl
+++ b/files/shaders/objects_fragment.glsl
@@ -96,19 +96,22 @@ void main()
     vec2 adjustedDiffuseUV = diffuseMapUV;
 #endif
 
+    vec3 worldNormal = normalize(passNormal);
+
 #if @normalMap
     vec4 normalTex = texture2D(normalMap, normalMapUV);
 
-    vec3 normalizedNormal = normalize(passNormal);
+    vec3 normalizedNormal = worldNormal;
     vec3 normalizedTangent = normalize(passTangent.xyz);
     vec3 binormal = cross(normalizedTangent, normalizedNormal) * passTangent.w;
     mat3 tbnTranspose = mat3(normalizedTangent, binormal, normalizedNormal);
 
-    vec3 viewNormal = gl_NormalMatrix * normalize(tbnTranspose * (normalTex.xyz * 2.0 - 1.0));
+    worldNormal = normalize(tbnTranspose * (normalTex.xyz * 2.0 - 1.0));
+    vec3 viewNormal = gl_NormalMatrix * worldNormal;
 #endif
 
 #if (!@normalMap && (@parallax || @forcePPL))
-    vec3 viewNormal = gl_NormalMatrix * normalize(passNormal);
+    vec3 viewNormal = gl_NormalMatrix * worldNormal;
 #endif
 
 #if @parallax
@@ -123,7 +126,9 @@ void main()
 #if 1
     // fetch a new normal using updated coordinates
     normalTex = texture2D(normalMap, adjustedDiffuseUV);
-    viewNormal = gl_NormalMatrix * normalize(tbnTranspose * (normalTex.xyz * 2.0 - 1.0));
+
+    worldNormal = normalize(tbnTranspose * (normalTex.xyz * 2.0 - 1.0));
+    viewNormal = gl_NormalMatrix * worldNormal;
 #endif
 
 #endif
@@ -221,7 +226,7 @@ void main()
     if (matSpec != vec3(0.0))
     {
 #if (!@normalMap && !@parallax && !@forcePPL)
-        vec3 viewNormal = gl_NormalMatrix * normalize(passNormal);
+        vec3 viewNormal = gl_NormalMatrix * worldNormal;
 #endif
         gl_FragData[0].xyz += getSpecular(normalize(viewNormal), normalize(passViewPos.xyz), shininess, matSpec) * shadowing;
     }
@@ -247,5 +252,9 @@ void main()
     gl_FragData[0].a = 1.0;
 #endif
 
+#if !defined(FORCE_OPAQUE) && !@disableNormals
+    gl_FragData[1].xyz = worldNormal * 0.5 + 0.5;
+#endif
+
     applyShadowDebugOverlay();
 }
diff --git a/files/shaders/openmw_fragment.glsl b/files/shaders/openmw_fragment.glsl
index 9de9e7afff5484c318cbf8e3d109e5813ef7c84f..151f8fdb13edd7d4089a56abcbbfb7f0c71a24d1 100644
--- a/files/shaders/openmw_fragment.glsl
+++ b/files/shaders/openmw_fragment.glsl
@@ -23,4 +23,11 @@ float mw_sampleRefractionDepthMap(vec2 uv)
     return texture2D(refractionDepthMap, uv).x;
 }
 
-#endif
\ No newline at end of file
+#endif
+
+uniform sampler2D omw_SamplerLastShader;
+
+vec4 mw_samplerLastShader(vec2 uv)
+{
+    return texture2D(omw_SamplerLastShader, uv);
+}
diff --git a/files/shaders/openmw_fragment.h.glsl b/files/shaders/openmw_fragment.h.glsl
index ae1a131b42efebef81b5cfaf1e8466fd3d53015e..c96912ead6493754d42995759f63f05143d55f14 100644
--- a/files/shaders/openmw_fragment.h.glsl
+++ b/files/shaders/openmw_fragment.h.glsl
@@ -6,4 +6,6 @@ vec4 mw_sampleReflectionMap(vec2 uv);
 #if @refraction_enabled
 vec4 mw_sampleRefractionMap(vec2 uv);
 float mw_sampleRefractionDepthMap(vec2 uv);
-#endif
\ No newline at end of file
+#endif
+
+vec4 mw_samplerLastShader(vec2 uv);
\ No newline at end of file
diff --git a/files/shaders/openmw_fragment_multiview.glsl b/files/shaders/openmw_fragment_multiview.glsl
index 1a2c0d991bfa9a5a8b16b8e45baa98e273019557..0ec9a3e12b52d80bdb0448440ba086a33a25920f 100644
--- a/files/shaders/openmw_fragment_multiview.glsl
+++ b/files/shaders/openmw_fragment_multiview.glsl
@@ -28,4 +28,11 @@ float mw_sampleRefractionDepthMap(vec2 uv)
     return texture2DArray(refractionDepthMap, vec3((uv), gl_ViewID_OVR)).x;
 }
 
-#endif
\ No newline at end of file
+#endif
+
+uniform sampler2DArray omw_SamplerLastShader;
+
+vec4 mw_samplerLastShader(vec2 uv)
+{
+    return texture2DArray(omw_SamplerLastShader, vec3((uv), gl_ViewID_OVR));
+}
\ No newline at end of file
diff --git a/files/shaders/terrain_fragment.glsl b/files/shaders/terrain_fragment.glsl
index a8106f4ad5a518b91326734b4a26457c7dccb515..7ff696e0833b244eb6c2ceccc4e8593f85e6842c 100644
--- a/files/shaders/terrain_fragment.glsl
+++ b/files/shaders/terrain_fragment.glsl
@@ -41,20 +41,24 @@ void main()
 {
     vec2 adjustedUV = (gl_TextureMatrix[0] * vec4(uv, 0.0, 1.0)).xy;
 
+    vec3 worldNormal = normalize(passNormal);
+
 #if @normalMap
     vec4 normalTex = texture2D(normalMap, adjustedUV);
 
-    vec3 normalizedNormal = normalize(passNormal);
+    vec3 normalizedNormal = worldNormal;
     vec3 tangent = vec3(1.0, 0.0, 0.0);
     vec3 binormal = normalize(cross(tangent, normalizedNormal));
     tangent = normalize(cross(normalizedNormal, binormal)); // note, now we need to re-cross to derive tangent again because it wasn't orthonormal
     mat3 tbnTranspose = mat3(tangent, binormal, normalizedNormal);
 
-    vec3 viewNormal = normalize(gl_NormalMatrix * (tbnTranspose * (normalTex.xyz * 2.0 - 1.0)));
+    worldNormal = tbnTranspose * (normalTex.xyz * 2.0 - 1.0);
+    vec3 viewNormal = normalize(gl_NormalMatrix * worldNormal);
+    normalize(worldNormal);
 #endif
 
 #if (!@normalMap && (@parallax || @forcePPL))
-    vec3 viewNormal = gl_NormalMatrix * normalize(passNormal);
+    vec3 viewNormal = gl_NormalMatrix * worldNormal;
 #endif
 
 #if @parallax
@@ -65,7 +69,10 @@ void main()
 
     // update normal using new coordinates
     normalTex = texture2D(normalMap, adjustedUV);
-    viewNormal = normalize(gl_NormalMatrix * (tbnTranspose * (normalTex.xyz * 2.0 - 1.0)));
+
+    worldNormal = tbnTranspose * (normalTex.xyz * 2.0 - 1.0);
+    viewNormal = normalize(gl_NormalMatrix * worldNormal);
+    normalize(worldNormal);
 #endif
 
     vec4 diffuseTex = texture2D(diffuseMap, adjustedUV);
@@ -104,7 +111,7 @@ void main()
     if (matSpec != vec3(0.0))
     {
 #if (!@normalMap && !@parallax && !@forcePPL)
-        vec3 viewNormal = gl_NormalMatrix * normalize(passNormal);
+        vec3 viewNormal = gl_NormalMatrix * worldNormal;
 #endif
         gl_FragData[0].xyz += getSpecular(normalize(viewNormal), normalize(passViewPos), shininess, matSpec) * shadowing;
     }
@@ -116,5 +123,9 @@ void main()
 #endif
     gl_FragData[0].xyz = mix(gl_FragData[0].xyz, gl_Fog.color.xyz, fogValue);
 
+#if !@disableNormals && @writeNormals
+    gl_FragData[1].xyz = worldNormal.xyz * 0.5 + 0.5;
+#endif
+
     applyShadowDebugOverlay();
 }
diff --git a/files/shaders/water_fragment.glsl b/files/shaders/water_fragment.glsl
index bf35ca78ca4e89b570dcdd8e689d70df23ff4928..51d30be2d4a574df0c7d18c96aec7e0b580df25e 100644
--- a/files/shaders/water_fragment.glsl
+++ b/files/shaders/water_fragment.glsl
@@ -363,5 +363,9 @@ void main(void)
 #endif
     gl_FragData[0].xyz = mix(gl_FragData[0].xyz, gl_Fog.color.xyz, fogValue);
 
+#if !@disableNormals
+    gl_FragData[1].rgb = normal * 0.5 + 0.5;
+#endif
+
     applyShadowDebugOverlay();
 }
diff --git a/files/ui/advancedpage.ui b/files/ui/advancedpage.ui
index 18f406d5b3e12b41e68340bdd9dbcc2597669842..520b089965812933bc8247cd3fbd9e1a73ddb0ce 100644
--- a/files/ui/advancedpage.ui
+++ b/files/ui/advancedpage.ui
@@ -576,6 +576,94 @@
              </layout>
             </widget>
            </item>
+           <item>
+            <widget class="QGroupBox" name="postprocessGroup">
+             <property name="title">
+              <string>Post Processing</string>
+             </property>
+             <layout class="QGridLayout" name="postprocessLayout">
+              <item row="0" column="0">
+               <widget class="QCheckBox" name="postprocessEnabledCheckBox">
+                <property name="toolTip">
+                  <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;If this setting is true, post processing will be enabled.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+                </property>
+                <property name="text">
+                 <string>Enable post processing</string>
+                </property>
+               </widget>
+              </item>
+              <item row="1" column="0">
+                <layout class="QVBoxLayout">
+                  <property name="leftMargin">
+                    <number>20</number>
+                  </property>
+                  <item>
+                    <widget class="QCheckBox" name="postprocessLiveReloadCheckBox">
+                      <property name="enabled">
+                        <bool>false</bool>
+                      </property>
+                      <property name="toolTip">
+                        <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Debug Mode. Automatically reload active shaders when they are modified on filesystem.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+                      </property>
+                      <property name="text">
+                        <string>Live reload</string>
+                      </property>
+                    </widget>
+                  </item>
+                  <item>
+                    <widget class="QCheckBox" name="postprocessTransparentPostpassCheckBox">
+                      <property name="enabled">
+                        <bool>false</bool>
+                      </property>
+                      <property name="toolTip">
+                      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Re-render transparent objects with forced alpha clipping.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+                      </property>
+                      <property name="text">
+                        <string>Transparent postpass</string>
+                      </property>
+                    </widget>
+                  </item>
+                  <item row="1" column="0">
+                    <layout class="QHBoxLayout">
+                      <item>
+                      <widget class="QLabel" name="postprocessHDRTimeLabel">
+                        <property name="enabled">
+                          <bool>false</bool>
+                        </property>
+                        <property name="toolTip">
+                        <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Controls how much eye adaptation can change from frame to frame. Smaller values makes for slower transitions.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+                        </property>
+                        <property name="text">
+                        <string>HDR exposure time</string>
+                        </property>
+                      </widget>
+                      </item>
+                      <item>
+                      <widget class="QDoubleSpinBox" name="postprocessHDRTimeComboBox">
+                        <property name="enabled">
+                          <bool>false</bool>
+                        </property>
+                        <property name="decimals">
+                        <number>3</number>
+                        </property>
+                        <property name="minimum">
+                        <double>0.000000000000000</double>
+                        </property>
+                        <property name="maximum">
+                        <double>1.000000000000000</double>
+                        </property>
+                        <property name="singleStep">
+                        <double>0.001000000000000</double>
+                        </property>
+                      </widget>
+                      </item>
+                    </layout>
+                  </item>
+                </layout>
+              </item>
+             </layout>
+            </widget>
+           </item>
            <item>
             <spacer name="verticalSpacer">
              <property name="orientation">
diff --git a/files/vfs/CMakeLists.txt b/files/vfs/CMakeLists.txt
index 15dcb80ec1928c8a47ab57b5ef94872885dbbe12..16911df573f58f63588b7148058c8a9436403f34 100644
--- a/files/vfs/CMakeLists.txt
+++ b/files/vfs/CMakeLists.txt
@@ -5,6 +5,7 @@ endif()
 # Copy resource files into the build directory
 set(SDIR ${CMAKE_CURRENT_SOURCE_DIR})
 set(DDIRRELATIVE resources/vfs/textures)
+set(DDIRRELATIVE_SHADERS resources/vfs/shaders)
 
 set(TEXTURE_FILES
     textures/omw_menu_scroll_down.dds
@@ -15,4 +16,10 @@ set(TEXTURE_FILES
     textures/omw_menu_scroll_center_v.dds
 )
 
+set(SHADER_FILES
+    shaders/main.omwfx
+    shaders/displaydepth.omwfx
+)
+
 copy_all_resource_files(${CMAKE_CURRENT_SOURCE_DIR} ${OPENMW_RESOURCES_ROOT} ${DDIRRELATIVE} "${TEXTURE_FILES}")
+copy_all_resource_files(${CMAKE_CURRENT_SOURCE_DIR} ${OPENMW_RESOURCES_ROOT} ${DDIRRELATIVE_SHADERS} "${SHADER_FILES}")
diff --git a/files/vfs/shaders/displaydepth.omwfx b/files/vfs/shaders/displaydepth.omwfx
new file mode 100644
index 0000000000000000000000000000000000000000..8b73a5abab9734229d8e6817f00daf02760c5b94
--- /dev/null
+++ b/files/vfs/shaders/displaydepth.omwfx
@@ -0,0 +1,26 @@
+uniform_float uFactor {
+    step = 0.1;
+    min = 0.01;
+    max = 20.0;
+    default = 1.0;
+}
+
+fragment main {
+
+    omw_In vec2 omw_TexCoord;
+
+    void main()
+    {
+        float depth = omw_GetDepth(omw_TexCoord);
+        float zNear = omw.near;
+        float zFar = omw.far;
+        omw_FragColor = vec4(vec3((2.0 * zNear) / (zFar + zNear - depth * (zFar - zNear))) * uFactor, 1.0);
+    }
+}
+
+technique {
+    passes = main;
+    description = "Visualizes the depth buffer.";
+    author = "OpenMW";
+    version = "1.0";
+}
diff --git a/files/vfs/shaders/main.omwfx b/files/vfs/shaders/main.omwfx
new file mode 100644
index 0000000000000000000000000000000000000000..8d12cebf81584ba541bfc7e3ec59c8b817b6df73
--- /dev/null
+++ b/files/vfs/shaders/main.omwfx
@@ -0,0 +1,45 @@
+main_pass {
+    wrap_s = clamp_to_edge;
+    wrap_t = clamp_to_edge;
+    internal_format = rgba;
+    source_type = unsigned_int;
+    source_format = rgba;
+}
+
+uniform_float uGamma {
+    default = 1.0;
+    step = 0.01;
+    min = 0.0;
+    max = 5.0;
+    description = "gamma level";
+}
+
+uniform_float uContrast {
+    default = 1.0;
+    step = 0.01;
+    min = 0.0;
+    max = 5.0;
+    description = "constrast level";
+}
+
+fragment main {
+
+    omw_In vec2 omw_TexCoord;
+
+    void main()
+    {
+        vec4 color = omw_GetLastShader(omw_TexCoord);
+        color.rgb = (color.rgb - vec3(0.5)) * uContrast + 0.5;
+        color.rgb = pow(color.rgb, vec3(1.0 / uGamma));
+
+        omw_FragColor = color;
+    }
+}
+
+technique {
+    description = "Main pass.";
+    version = "1.0";
+    author = "OpenMW";
+    passes = main;
+    hdr = false;
+}
